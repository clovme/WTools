{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"This document is a usage manual for JEB 4. The latest version is available online . JEB is a reverse-engineering platform to perform disassembly, decompilation, debugging, and analysis of code and document files, manually or as part of an analysis pipeline. The first part of this guide is a user manual that covers basic usage related to analyzing, decompiling and debugging applications (Android apps, as well as native binaries). It is not an exhaustive resource. We recommend visiting our blog for additional, pointed resources describing a variety of use cases. The second half is a developer portal for advanced users who will want to use the JEB API to script tasks, develop plugins, or even craft their own front-ends. Alongside these pages, the API reference documentation website will be an indispensable resource. Hint Use the N key to navigate to the next page. Use the P key to navigate to the previous page. Use the S key to focus the search box. Installation # Delivery # JEB is delivered electronically over email. Software updates are also delivered over email. Missing emails? To ensure the software delivery and update emails do not end-up in spam folders, white-list the sender software@pnfsoftware.com . Software Package # The software package is distributed as a zip archive, custom-generated for each registered user. It contains the back-end components as well as the reference front-end implementation for desktop platforms, referred to as the UI client through the rest of this manual. This manual focuses mostly on using JEB through the UI client. The UI client runs on the following platforms: Windows (x64) Linux/GTK (x64, arm64) macOS (x64, arm64) Requirements # JEB requires a recent Java SE Development Kit (JDK) : JEB GUI client: Minimal requirement: a recent JDK 8 Recommended: JDK 11 or above (JDK 11 will be made a requirement in 2022) Command-line client: JDK 8 or above. Test environments JEB is built with Java 8, and tested with two JDKs: Oracle JDK 8 and Oracle JDK 11. Java 18+ Java 18 or above is not recommended at the time of writing. Setup # Make sure you have a JRE or JDK installed. The java binary must be accessible from the PATH environment variable. Optionally, you may also want to set a JAVA_HOME environment variable pointing to your Java installation folder. 64-bit OS with 32-bit JRE A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH. You may have different versions of Java installed, but always make sure that your PATH or JAVA_HOME refers to one that matches your system specifications. Startup # Floating Licenses If you are setting up a floating Controller, stop here and visit this page . Execute the startup script appropriate for your environment: Windows $ jeb_wincon.bat Linux $ jeb_linux.sh macOS $ jeb_macos.sh The startup script will locate and decrypt the JEB binary file. It may prompt the user and ask for the decryption password, which can be found within the software delivery email issued by PNF Software. Enter the password to allow the startup script to finish the installation process. JEB will start. Note Start-up scripts get overwritten during an update. Therefore, if you wish to customize your start-up script, we recommend you copy it to a separate file, e.g. jeb.sh or jeb.bat . Registration # If it is the first time you are launching a non-floating JEB client (e.g., JEB Pro, JEB Android), you will be asked to accept the end-user license agreement, and generate a license key: If your machine is connected to the Internet, the license key can be automatically generated by clicking \"Generate a Key\". If need be, you may also configure your Proxy settings. If your machine is not connected to the Internet, you will need to generate a manual key. Click \"Manual Key Generation\" and follow the instructions. You will be asked to visit the key generation portal on a separate machine (connected to the Internet), and provide your license data. The license key will be stored in the bin/jeb-client.cfg file, under the .LicenseKey key entry. A key is specific to the user-account and machine configuration on which JEB is running. Do not attempt to reuse a key on another system. Key revocation If you need to deprecate an older key (e.g., because of a machine replacement, user departure, or else), email Licensing . First use # Congratulation! JEB is now running.","title":"Getting Started"},{"location":"index.html#installation","text":"","title":"Installation"},{"location":"index.html#delivery","text":"JEB is delivered electronically over email. Software updates are also delivered over email. Missing emails? To ensure the software delivery and update emails do not end-up in spam folders, white-list the sender software@pnfsoftware.com .","title":"Delivery"},{"location":"index.html#software-package","text":"The software package is distributed as a zip archive, custom-generated for each registered user. It contains the back-end components as well as the reference front-end implementation for desktop platforms, referred to as the UI client through the rest of this manual. This manual focuses mostly on using JEB through the UI client. The UI client runs on the following platforms: Windows (x64) Linux/GTK (x64, arm64) macOS (x64, arm64)","title":"Software Package"},{"location":"index.html#requirements","text":"JEB requires a recent Java SE Development Kit (JDK) : JEB GUI client: Minimal requirement: a recent JDK 8 Recommended: JDK 11 or above (JDK 11 will be made a requirement in 2022) Command-line client: JDK 8 or above. Test environments JEB is built with Java 8, and tested with two JDKs: Oracle JDK 8 and Oracle JDK 11. Java 18+ Java 18 or above is not recommended at the time of writing.","title":"Requirements"},{"location":"index.html#setup","text":"Make sure you have a JRE or JDK installed. The java binary must be accessible from the PATH environment variable. Optionally, you may also want to set a JAVA_HOME environment variable pointing to your Java installation folder. 64-bit OS with 32-bit JRE A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH. You may have different versions of Java installed, but always make sure that your PATH or JAVA_HOME refers to one that matches your system specifications.","title":"Setup"},{"location":"index.html#startup","text":"Floating Licenses If you are setting up a floating Controller, stop here and visit this page . Execute the startup script appropriate for your environment: Windows $ jeb_wincon.bat Linux $ jeb_linux.sh macOS $ jeb_macos.sh The startup script will locate and decrypt the JEB binary file. It may prompt the user and ask for the decryption password, which can be found within the software delivery email issued by PNF Software. Enter the password to allow the startup script to finish the installation process. JEB will start. Note Start-up scripts get overwritten during an update. Therefore, if you wish to customize your start-up script, we recommend you copy it to a separate file, e.g. jeb.sh or jeb.bat .","title":"Startup"},{"location":"index.html#registration","text":"If it is the first time you are launching a non-floating JEB client (e.g., JEB Pro, JEB Android), you will be asked to accept the end-user license agreement, and generate a license key: If your machine is connected to the Internet, the license key can be automatically generated by clicking \"Generate a Key\". If need be, you may also configure your Proxy settings. If your machine is not connected to the Internet, you will need to generate a manual key. Click \"Manual Key Generation\" and follow the instructions. You will be asked to visit the key generation portal on a separate machine (connected to the Internet), and provide your license data. The license key will be stored in the bin/jeb-client.cfg file, under the .LicenseKey key entry. A key is specific to the user-account and machine configuration on which JEB is running. Do not attempt to reuse a key on another system. Key revocation If you need to deprecate an older key (e.g., because of a machine replacement, user departure, or else), email Licensing .","title":"Registration"},{"location":"index.html#first-use","text":"Congratulation! JEB is now running.","title":"First use"},{"location":"actions.html","text":"The primary use case for JEB is the analysis of binary code. This section focuses on the basics of code analysis and refactoring: Renaming items such as methods or fields Changing the code structure by moving items to packages Commenting Navigating a code base via cross-references Viewing type hierarchies Viewing method overrides Graphing routines (CFG) Replacing items or rebasing immediates Auto-renaming all items In the UI client, many fundamental interactions can be achieved via the Action and Navigation menus. Those actions are implemented by most JEB analysis modules that perform code disassembly. Other action groups such as Native code actions and Debugging actions are detailed in separate sections of this manual. Warning The examples in this section are based on the analysis of a sample Android app using the Android Dex parser. Keep in mind that features and behaviors of Actions depend on the module implementing and performing them. Decompiling # The next section covers decompiling code in depth. Graphing # Users can alternate between the default interactive full disassembly view and the interactive control flow graph of the currently examined method/routine. Press the Space key to go back and forth. In some circumstances, users may prefer graph navigation. CFG fragment of a routine Renaming # An important requirement for analysts is the ability to rename code items such as types, methods and routines, fields and data items, packages, etc. consistently across a code base. Position the caret on the item to be renamed Hit the N key or select Action, Rename Enter the new name and press Enter Tip Within the Rename dialog box, press Ctrl+Space (Command+Space on macOS) to bring up your renaming history. Commenting # When in a code view, press the / (slash) key to add a comment. Warning Comments are attached to addresses or items, therefore make sure to be on a valid address - else no comment can be attached. The caret address is always displayed in the status bar: Navigating # Pressing the Enter key on an item or double-clicking it will bring the caret to the definition of the item. You can navigate backward and forward using the traditional Alt + Arrow Left (or Escape ) and Alt + Arrow Right key combos, or via the Navigation menu. The Next Item and Previous Item command allow you to jump to the similar item after or before the currently selected item. Cross-references # Cross-references on an item allow the examination of items referencing it. Press the X key to visualize them. You can jump to a cross-reference by double-clicking it. The cross-reference dialog generally includes additional information attached to the referenced location. That information is plugin-dependent. Below, the Details column provides the kind of reference (on a field item, in that case), e.g. a GET (read), or something else. Restructuring # The Create Package and Move to Package actions offer powerful refactoring possibilities, especially useful in the case of large obfuscated binary files. If the module supports it, users are able to: Create artificial packages (aka, namespaces) using the K key. Move items, such as types, to existing or artificial packages using the L key. Workflow The following screenshot is an example where the class AppHelp was moved from the com.pnfsoftware.raasta package to a newly created package named com.abc . Info Have a look at our YouTube demo video that demonstrates advanced refactoring and automatic restructuring of a heavily obfuscated Android malware application. Type Hierarchies # The H key allows the examination of type hierarchy, such as parent classes, descendant classes, implemented interfaces, etc. Object Overrides # The O key allows the examination of overrides, such as virtual method redefinitions in the case of object-oriented bytecode files. Rebasing Constants # This feature allows the selection of the radix used to render immediate constant integers. Press the B key repeatedly to cycle through the bases offered by the plugin. Typically, bases 8, 10, 16 are offered. Some plugins may offer additional bases such as base 2, or non-conventional representation modes, such as character-based immediate rendering. Auto-Rename All # This action may be offered by plugins to allow blanket renaming of all items to automatically-generated names. Info The Dex plugin provides this option to auto-rename types, fields, and methods to better names if they have been obfuscated to unreadable or compressed strings. Have a look at the Android section to learn more. Favorites # You may bookmark favorite locations and quickly retrieve positioned favorites using the Action menu. The Favorites dialog (F12 by default) shows all favorites in your project. Navigate to a positioned favorite by double-clicking on a row. The dialog is modeless (it can stay open while you work on the project). Highlights # Lines in interactive text views, such as disassembly or decompiled views, can be highlighted using the Action, Toggle Highlight (Control/Command + M by default).","title":"Actions"},{"location":"actions.html#decompiling","text":"The next section covers decompiling code in depth.","title":"Decompiling"},{"location":"actions.html#graphing","text":"Users can alternate between the default interactive full disassembly view and the interactive control flow graph of the currently examined method/routine. Press the Space key to go back and forth. In some circumstances, users may prefer graph navigation. CFG fragment of a routine","title":"Graphing"},{"location":"actions.html#renaming","text":"An important requirement for analysts is the ability to rename code items such as types, methods and routines, fields and data items, packages, etc. consistently across a code base. Position the caret on the item to be renamed Hit the N key or select Action, Rename Enter the new name and press Enter Tip Within the Rename dialog box, press Ctrl+Space (Command+Space on macOS) to bring up your renaming history.","title":"Renaming"},{"location":"actions.html#commenting","text":"When in a code view, press the / (slash) key to add a comment. Warning Comments are attached to addresses or items, therefore make sure to be on a valid address - else no comment can be attached. The caret address is always displayed in the status bar:","title":"Commenting"},{"location":"actions.html#navigating","text":"Pressing the Enter key on an item or double-clicking it will bring the caret to the definition of the item. You can navigate backward and forward using the traditional Alt + Arrow Left (or Escape ) and Alt + Arrow Right key combos, or via the Navigation menu. The Next Item and Previous Item command allow you to jump to the similar item after or before the currently selected item.","title":"Navigating"},{"location":"actions.html#cross-references","text":"Cross-references on an item allow the examination of items referencing it. Press the X key to visualize them. You can jump to a cross-reference by double-clicking it. The cross-reference dialog generally includes additional information attached to the referenced location. That information is plugin-dependent. Below, the Details column provides the kind of reference (on a field item, in that case), e.g. a GET (read), or something else.","title":"Cross-references"},{"location":"actions.html#restructuring","text":"The Create Package and Move to Package actions offer powerful refactoring possibilities, especially useful in the case of large obfuscated binary files. If the module supports it, users are able to: Create artificial packages (aka, namespaces) using the K key. Move items, such as types, to existing or artificial packages using the L key. Workflow The following screenshot is an example where the class AppHelp was moved from the com.pnfsoftware.raasta package to a newly created package named com.abc . Info Have a look at our YouTube demo video that demonstrates advanced refactoring and automatic restructuring of a heavily obfuscated Android malware application.","title":"Restructuring"},{"location":"actions.html#type-hierarchies","text":"The H key allows the examination of type hierarchy, such as parent classes, descendant classes, implemented interfaces, etc.","title":"Type Hierarchies"},{"location":"actions.html#object-overrides","text":"The O key allows the examination of overrides, such as virtual method redefinitions in the case of object-oriented bytecode files.","title":"Object Overrides"},{"location":"actions.html#rebasing-constants","text":"This feature allows the selection of the radix used to render immediate constant integers. Press the B key repeatedly to cycle through the bases offered by the plugin. Typically, bases 8, 10, 16 are offered. Some plugins may offer additional bases such as base 2, or non-conventional representation modes, such as character-based immediate rendering.","title":"Rebasing Constants"},{"location":"actions.html#auto-rename-all","text":"This action may be offered by plugins to allow blanket renaming of all items to automatically-generated names. Info The Dex plugin provides this option to auto-rename types, fields, and methods to better names if they have been obfuscated to unreadable or compressed strings. Have a look at the Android section to learn more.","title":"Auto-Rename All"},{"location":"actions.html#favorites","text":"You may bookmark favorite locations and quickly retrieve positioned favorites using the Action menu. The Favorites dialog (F12 by default) shows all favorites in your project. Navigate to a positioned favorite by double-clicking on a row. The dialog is modeless (it can stay open while you work on the project).","title":"Favorites"},{"location":"actions.html#highlights","text":"Lines in interactive text views, such as disassembly or decompiled views, can be highlighted using the Action, Toggle Highlight (Control/Command + M by default).","title":"Highlights"},{"location":"android-debugging.html","text":"JEB supports debugging Dalvik code via JDWP and Native *.so libraries via gdb/lldb. A debugging session allows seamless transition between debugging the Dalvik VM, jumping into native methods invoked via JNI, debugging native code (arm, x86, else), and switching back to Dalvik. Previous material It is recommended to read the generic debugging page first. Prerequisites # The Android debuggers run on all JEB-supported platforms (Windows, Linux, macOS). Verify the following before attempting to start a debugging session: Make sure to have the Android SDK installed. You also want to have the ANDROID_SDK_ROOT environment variable pointing to the SDK folder. (The ANDROID_HOME variable is also checked, although it was deprecated.) Enable Developer options and allow USB debugging on the intended physical target device. (Debugging is enabled by default on the emulators.) On physical devices running Android 4.2 and above, one way to make sure that USB debugging is enabled is to run the adb devices command. If the device is shown as unauthorized , a pop-up on your phone will appear to request authorization. Fundamentals # There are two types of debuggable entities on Android OS: Android/Linux processes Higher-level Dalvik virtual machines, running inside processes Debugging is generally performed remotely, on a separate computer. Nothing prevents you from debugging on the device itself though. Dalvik VM debugging is done over the Java Debug Wire Protocol (JDWP) protocol. The JDWP server runs inside the process hosting the DVM. JEB implements the JDWP client. Native code debugging is done via ptrace(2) . On the device, the debugger server process (generally gdb or lldb), runs alongside the target process and controls it via ptrace. JEB implements a gdb/lldb client. The DVM runs inside a native process Debugging non-debuggable apps # Normally, only apps whose Android Manifest explicitly has a debuggable flag set to true are debuggable. However, this is rarely the case when analyzing in-the-wild malware or production applications. In such cases, you have several options: Run the app in an emulator. Emulators have the ro.debuggable property set to 1 (with an exception, see note below). This means they will debug all apps, regardless of the debuggable flag in the Manifest. In some situation, this may not be enough since several components, in the OS or the app itself, may check for the Manifest's debuggable flag before or during the app execution. Use a rooted phone. A rooted phone will allow you to modify the ro.debuggable property, and change it from 0 (standard on production devices) to 1. A rooted phone will also allow you to install additional low-level programs to ease debugging and potentially solve problems mentioned in the above bullet point. (The rooting process is out-of-scope here: it is device-specific and rooting instructions can easily be found online.) Repackage your app. This may be the simplest option. Use JEB's built-in tool makeapkdebug to generate a debuggable app. You will have to sign the generated app using your own key; be aware of the implications if you choose that option. See below for more details. Warning If you choose to debug in a Google-provided emulator image, make sure to use a non \"Google Play image\". Those images are lock-down production images. Instead, use a \"Google APIs image\" or a vanilla image (that doesn't ship with Google-specific libs). Native code in non-debuggable apps # When it comes to debugging native code of non-debuggable apps on a rooted phone or emulator, other limitations apply. JEB tries its best at abstracting them away. However, things might be unstable depending on which phone and OS is being used. Do not hesitate to let us know if you encounter issues. Info Some limitations stem from the trusted run-as Android utility, which verifies whether an app is marked debuggable, regardless of the system's overall debuggability. JEB ships with a modified version of the utility, named ranod , which does not perform such checks. Decompiling the x86 build of run-as Note that most of our tests are done on Pixel devices running vanilla Android Oreo. Using similar devices for debugging will likely reduce the chances of running into corner-case problematic situations. Generating a debuggable APK # It is generally easier to debug Android applications explicitly marked debuggable in their Manifest: <application android:debuggable=\"true\" ...>; JEB has built-in utility to rebuild a non-debuggable APK into a debuggable one, while maintaining the entire structure of the application intact, except for its signing data of course. Navigate to your JEB folder, and use the start-up script, e.g. on Windows: $ jeb_wincon.bat -c --makeapkdebug -- file.apk Upon success, file_debuggable.apk will be generated. Sign it using the Android SDK's apksigner , e.g. on Windows: $ apksigner.bat sign -ks SOME_KEYSTORE.JKS file_debuggable.apk Install it on your device, and start debugging. Warning Keep in mind that this solution has shortcomings: Anti-debugging code may check at runtime that the app is not debuggable, as would be expected. More elaborate protections may implement certificate pinning-style checks, where the code verifies that it is signed using a specific certificate. App Bundles (multi-APK apps) # When a vendor develops their app as an Android App Bundle , the distributing store will send the app as a collection of smaller-sized APKs tailored to the requesting device configuration. A common split is the following: base APK (common for all devices) graphical resources APK (low-dpi, medium-dpi, high-dpi, etc.) localized resources APK (English locale, French locale, etc.) native libs APK (x86, arm, arm64, etc.) If you need to pull those apps from a device and make them debuggable, you should run --makeapkdebug on all APKs and re-sign them with the same key of your choice. You may then install the app as usual via adb install-multiple . Starting a debugging session # Android debugging sessions can be started when analyzing APK files. If your main artifact is an orphan DEX file, the client will refuse to start a debugging session. First, retrieve your target APK and get the app ready for debugging: Make sure the APK matches the one that will be executed on the target phone. You can download the APK using adb : adb shell pm list packages -f to retrieve a list of packages and the associated path to APK adb pull <pathToAPK> to download the APK Start the app on the phone Via the App Launcher for instance, if attaching to an already running app is an acceptable scenario If you want the app to wait for the debuggers to attach to it before it starts executing any code, you can run something like: adb shell am start -D -S -n <packageName>/<activityName> A pop-up will be displayed on the phone, indicating it is waiting for a debugger to attach to the VM Second, in the UI client: Load the APK file Open a view of a primary DEX unit Once the focus is on the DEX view, open the Debugger menu, and click on Start... The Debugger/Start command, used to start or attach a debugger, is available once the code view of a supported code unit has the focus. Here, the focus was on Dalvik bytecode. In the Attach dialog window: Select the target phone and the target process that matches your app, and click Attach. Unless you tick the \"Suspend all threads\", The app will be immediately be run/resumed after attaching. The process filter is normally filled out with the APK package name. Simply press enter to filter out entries. Heads-up Tick \"Allow children debuggers\" if you wish to debug native code as well. Common problems # Unable to debug native code of an Android app? Make sure to tick the box \"Allow children debuggers\" before attaching. Impossibility to read (most) local vars in Dalvik The issue is affecting Android Pie (API 28) and Q (API 29). We wrote a blog explaining the details of the problem (unfortunately, not a fixable one). If possible, switch to Android Oreo or below (<= API 27) or Android R or above (>= API 30). Cannot attach to a non-debuggable app but the phone is rooted Having a rooted phone is not enough. System components checks for the app's debuggability (i.e., the Manifest's android:debuggable flag) in various places, regardless of whether the image is a locked production image, rooted image, debug or dev build, etc. While it is relatively easy to debug Dalvik, native debugging is generally more tricky. JEB does a few things to ease settings things up: It attempts to set the system property ro.debuggable to 1 It attempts to replace the run-as utility by one that does not check the debuggable flag (more details later in this doc). In order to do any of the above, root privilege is required, and JEB assumes the su tool has been dropped in a standard location ( /bin/su , /sbin/su , /system/bin/su , /system/xbin/su , /data/local/su , /data/local/bin/su , /data/local/xbin/su , /system/sd/xbin/su , /system/bin/failsafe/su , /su/bin/su ). Files may have to be dropped in the /system folder. That folder is read-only by default and needs to be remounted read-write. Root privileges may not suffice: if you are using an emulator, configuration may default to a read-only system image. You will need to explicitly specify that the system can be written to, e.g.: $ <SDK>/emulator/emulator -avd [image_folder_name] -writable-system JEB also attempts to disable SEAndroid by issuing a setenforce 0 command. The aforementioned settings and techniques may not suffice. Whenever possible, we encourage debugging on the Lolipop-Oreo range (5.0 to 8.1 / API 21 to 27) with vanilla images. Ideally, you'll want to have a debuggable app. Again, it may not be always possible or realistic (e.g., debugging a system app and a custom vendor's locked image), but in many cases (e.g., malware analysis), it is possible. Debugger nodes # After attaching, the app, you should see one or two additional nodes in the Project tree view. One debugger node for Dalvik, an optional debugger node for native code. Two debugger nodes ( VM , Process ) attached to the target Note When a debugger is successfully attached, the corresponding node has a light green background. Additional views and fragments displaying the debuggers' states and commands are added to the workspace: Native threads # Caution Keep in mind that pausing the Process debugger (i.e., suspending the native threads) will freeze the higher-level Dalvik VM! An app's Dalvik VM runs inside a Linux process. Therefore, any action taken using the native debugger (if native debugger was attached) may affect a VM debugging session as well. Dalvik debugging # Active debugger # In the general case, the focused UI fragment will determine which debugger will receive input commands. Therefore, be mindful of which debugger is being controlled when invoking commands (via menu entries, toolbar or keyboard). E.g., if the focus is on a DEX view, the controls are connected to the VM (Dalvik) debugger; if the focus is within a code view connected to the Process debugger, the controls are connected to the Process debugger. Controls # Standard debugger controls can be accessed via the Debugger menu or the toolbar area. They allow: Attaching, detaching, terminating the process Pausing and resuming the process and, possibly, its individual threads Stepping (into, over, out of) Toggling execution breakpoints Not all controls can or are implemented for both debuggers. Currently for instance, pausing individual threads of the Process debugger is not possible. When a control is not available, depending on which control it is and the severity of the failed operation, the user may be unable to activate it (e.g., grayed button), receive an error in the logger, or receive a pop-up error in the client. Setting breakpoints # Breakpoints can be set/unset using the handy Control+B (Command+B on macOS) shortcut. An icon is displayed in the left vertical bar of a code view to represent enabled/disabled breakpoints. Two breakpoints, one is enabled, the other one is disabled Note Toggling breakpoints on and off is currently not available in decompiled views. Registering additions # When starting a debugging session, the debugger attaches to an APK's DEX unit as well as subsequent compatible code units dynamically added to your Project. Dynamic additions: Dex code # However, in some cases, the debugger will not automatically pick up and attach to additional DEX units (e.g., nested DEX units). You may ask the debugger to register additional code units via the Debugger, Register Addition action: The handler will be enabled and can be invoked when a debugger fragment has the focus We are attaching classes.jar to the current debugging Note Make sure to focus a fragment pertaining to the debugger which should link the target code unit before executing Debugger, Register Addition . Dynamic additions: Native code # Similarly, native library artifacts may be added to a project, processed, and attached to a native debugger after a debugging session has started. Note For native unit additions, the unit name must reflect the library name loaded in the process. Use the libs command in the debugger terminal to determine an actual library name. If names mismatch, the debugger will not be able to find out the actual library image base. If you need to rename a unit, right-click the unit node in the Project Explorer panel, and select Properties. Demo video: Dynamically adding an .so file to a debugging session Views and fragments # Threads # The Threads view displays thread identifiers, status (running, suspended, waiting, etc.) as well as the stackframes when a thread is paused. Depending on the target processor, there may be one or more stackframes, showing the location (program counter register or address) of the current thread. Info Full status list: CREATED, RUNNING, PAUSED (=SUSPENDED), SLEEPING, WAITING, ZOMBIE, MONITOR, TERMINATED. Not all status may be relevant to a given architecture. The default thread can be selected by double-clicking or right-clicking, Set as default thread . By default, when a breakpoint is hit, only the active thread is suspended . The other threads are not. Other threads can be suspended with Terminal commands. A suspended thread after execution hit a breakpoint Breakpoints # The Breakpoints view displays active and inactive code breakpoints. Note The JEB API allows settings breakpoints on instructions and breakpoint on methods (method entry, method exit). Other capabilities exist, not readily available in UI client, e.g. breakpoint on class load event, breakpoint on exception, etc. Two breakpoints, one is enabled, the other one is disabled Locals # The Locals view displays generic variables registers. They can be virtual slots of a VM, registers of a native process, complex variables inferred by the decompiler, etc. For JDWP, what is displayed is: this for Non-static methods locals of the selected (and paused) thread's top frame; variables for other frames can be examined via Terminal commands Primitives and String values can be updated. click on the cell of the value to be written, in the Value column set the new value and press Enter Updating a String object Note that JEB attempts to maintain the state of this fragment across your debugging sessions, even though variables references, values (and subs) may change as you step through code, etc. JEB does its best at displaying very large arrays efficiently as well. However, keep in mind that adb is slow, and maintaining live variable views up-to-date across stepping can be costly. You may temporarily disable Refresh by pressing the \"Freeze Refresh\" button. Variable types For safety reasons, Dex metadata providing locals types and/or names information is disregarded, since it cannot be trusted and using bad types can crash the DVM debugging server. See the sub-section below about JDWPD caveats. Live overlays # Hover over a variable, register, or field to see its contents. The thread must be paused. Hovering over p0 (equivalent to v7 in the examined method) Other fragments # The Stack and Memory fragments are irrelevant for JDWP debugging JDWP caveats # Info This short section highlights limitations pertaining the Dalvik debugging via JDWP, both on the server (device) and the client (JEB) side. JDWP was specified and designed by Oracle for the Java VM. The Dalvik VM implements parts of the specifications and the Binary Protocol . Capabilities # The Capabilities and CapabilitiesNew commands of the VirtualMachine command set can be used to retrieve the list of features offered by a JDWP server. E.g., register watches are not supported by the Dalvik debugger server. Although the JEB Android debugging modules implement JDWP with regards to what the Dalvik JDWP server provides, not all JDWP are currently exposed through the UI client or even API. E.g., JDWP allows debugger clients to specify if one or all threads should be stopped when a breakpoint is hit; currently, JEB debugger API does not provide a method to control that setting. Variable typing # Why are most locals typed as 'int' by default? The general reason is safety. Caution The Dalvik VM will crash the JDWP server attempts to read a non-reference as a reference; most non-references are obvious (e.g., 1, 2, small ints -> non refs.) but some ints may not be - relying on DEX metadata is also unsafe. However, most variables can be retyped. Click on a type cell to edit contents: Changing the type of v0 to long: type long , press Enter. The resulting value is the long interpretation of {v0,v1} Changing the type of p0 to object: type object , press Enter. If the reference truly is an object, the correct type will be retrieved. If it is not, the VM may crash. Variable vs Parameter # In Dalvik, vX is the preferred notation to reference variables of a method's stack frame. In this case, X is an index relative to the top of the frame. Another notation, originating from Java, is pX . That notation is primarily used to specify parameters, X being an index such that all of a method's parameters (including this) are located at the very bottom of the frame. (Converting from vX to pX and vice-versa is detailed in the Android page.) The JDWP protocol was designed by Sun/Oracle. As such, and although JDWP specifications do not explicitly specify that, it may seem intuitive to assume that the indices used by JDWP to designate variables in a frame would be pX indices. It seems that used to be the case until API 27 (included). From API 28 onward, indices used to refer to variables are vX indices. Knowing this fact is crucial when it comes to reading and writing variables of a frame. JEB attempts to determine this automatically. However, if incongruities seem to show in the Variables GUI fragment, it may be that wrong indices are being sent out in JDWP commands. In such a case, use the debugger interpreter's frameSlotIndexMode command to manually set the index mode. See the section below for details about the Interpreter and how to use it. Unreadable variables # On Android P and Q (API levels 28 and 29), the values of variables without valid debug information are not provided by the debugging server. If an attempt to read them is made, the debugger server issues a JDWP error 35 (\"Invalid slot\"). Therefore, when debugging applications on Android P/Q, JEB will not be able to provide the values of all variables. To see which locals are declared in the debug information of a method, enable \"Show Debug Directives\" in the options (right-click in the Assembly view, Rendering Options). The debug variables are declared with \".local vX ...\". This problem was fixed in Android R and above: All initialized local variables are readable. More information on this blog post . Interpreter Commands # The debugger units implement IUnit.getCommandInterpreter method to provide clients with command interpreters used to execute fine-grained debugger commands that may not be readily available in the UI client. All command interpreters are accessible via the Console tab. Once the Android debuggers are attached, switch over to the Console view, and type list . This command will list all command interpreters currently attached to the console: The terminal below that can be bound to 3 command interpreters, including two provided by active Debugger units An interpreter has a numeric id as well as the name of the unit that created it. Switch to an interpreter with the use <id|name> command. The special command help , available in all interpreter contexts, lists all commands made available by the interpreter currently in use. > list 3 interpreters available (0) py: Python Interpreter (built on Jython 2.7) (1) VM: Debugger interpreter for VM (2) Process: Debugger interpreter for Process > use 1 VM> help info : Display basic information about the debuggee libs|modules [name-filter] : Display information about the target modules resume [tid] : Run or resume the target, a thread, or the default thread (tid 0) pause : Pause the target detach : Detach the target (if possible) kill|terminate : Kill the target (unstable) threads : List the process threads thread [tid] : Set or get the default thread step|stepi : Step \"into\" one instruction in the default thread stepo : Step \"over\" one instruction in the default thread stepu : Step \"up\"/\"out\" (run until return) in the default thread b|bp [address] : Set or list breakpoints bc [index] : Clear one or all breakpoints frameSlotIndexMode mode : Set the index type used to retrieve thread frames' variables (AUTO, PAR, VAR) classes : List the classes loaded by the VM signature|sig [OPTION]... cid : Information about a specific class fields [OPTION]... cid : List the fields of a type methods [OPTION]... cid : List the methods of a type call|invoke [OPTION]... cid method : invoke a method. read|get [OPTION]... objectId : Read an object or array. set [OPTION]... objectId new_value : Set a method variable or parameter as a typed-value pull remotePath localPath : adb-pull on steroid VM> Warning Many commands can only run when the target or target thread is suspended or paused. Hint Type help <command> to see specific help for that command. Hint Press Enter on a white-line to repeat the previously executed command. There are three types of commands offered by the Dalvik debugger VM interpreter: program commands: info , libs , detach , kill , pull , frameSlotIndexMode thread commands: thread , threads , pause , resume , step , stepo , stepu , b , bc object interaction commands: classes , sig , fields , methods , call , get , set Program commands # info will provide information about JDWP. Below, Java 8 and JVM-DI 2. VM> info Debuggee is running on ? VM information: JDWP:\"Java Debug Wire Protocol (Reference Implementation) version 1.8 JVM Debug Interface version 1.2 JVM version 8 (Dalvik, )\" v1.8 (VM:Dalvik v8) VM identifier sizes: f=8,m=8,o=8,rt=8,fr=8 libs will always be empty for a JDWP debugger: libraries are not application to Dalvik bytecode running in a VM. Info A native debugger's libs command does provide information. detach will attempt to detach the target without killing it kill will terminate the target process (and therefore detach from it as well) pull is similar to adb pull ... but will make use of the su binary to elevate privileges when necessary (assuming su be present and found on the target device). frameSlotIndexMode is used to switch between parameter-indices (pX) and variable-indices (vX) when issuing thread frame slot read/write commands. (See above for details on which scenarios this command may be useful.) Thread commands # thread is used to retrieve or set the default thread, i.e. the thread to which most commands will be applied to if no thread id is explicitly provided. threads lists the threads and their states pause suspends the target: all threads will be suspended resume resumes the target: all threads will be resumed. Warning Keep in mind that pausing/resuming actions are stacked. E.g., a a thread X was already suspended, executing pause , then resume , will not resume thread X. step or stepi is used to perform a single-step, and enter methods (Dalvik or Native) if necessary stepo performs a single-step but does not enter methods. stepu will step until the current method returns. b is used to list or add breakpoints on method's bytecode (not the method itself) or fields. Breakpoints on fields will trigger on field access (read or write). VM> b 0 - Lcom/xyz/appcheck/AppCheck;->vFloat:F [enabled: true] 1 - Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+23Ah [enabled: true] 2 - Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+248h [enabled: false] 3 - Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+250h [enabled: true] VM> b Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+21Ah Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+21Ah (u={Unit:name={Bytecode},type={dex}},a={Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+21Ah}) [enabled=true] bc is used to clear one or all breakpoints. VM> bc 5 # clear breakpoint #5 VM> bc # clear all breakpoints Class/object commands # classes lists all currently loaded classes. Not all classes of an app may be loaded when the command is executed. Info Types are referenced by their canonical JVM name (Lcom/abc/Foo;) or their cid (internal id representing a type during for a given debugging session). A target class can also be inferred from an object reference: this object the object id, prefixed with @ character any object that can be referenced from these ones. Types have an associated type tag (1 for a class, 2 for an interface, 3 for an array) and a status bit flags (0x1 if the type was verified, 0x2 if it was prepared, 0x4 if it's been loaded, 0x8 on error; most types listed by the classes command should have status 7, meaning they have been verified, prepared and loaded). VM> classes 15822 classes - id=4542,tag=2,status=0x7,sig=Landroid/hardware/radio/V1_4/IRadioResponse; - id=1849,tag=1,status=0x7,sig=Lcom/android/internal/telephony/uicc/euicc/-$$Lambda$EuiccCard$okradEAowCk8rNBK1OaJIA6l6eA; - id=8675,tag=1,status=0x7,sig=Landroid/net/NetworkRequest$2; - id=4819,tag=1,status=0x7,sig=Landroid/net/NetworkRequest$Type;,genSig=Ljava/lang/Enum<Landroid/net/NetworkRequest$Type;>; - id=3277,tag=1,status=0x7,sig=Landroid/os/IProgressListener$Stub; - id=12717,tag=2,status=0x7,sig=Ljava/net/SocketImplFactory; ... methods is used to list the methods of a type: VM> methods Ljava/lang/String; sig=Ljava/lang/String;,genSig=Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable<Ljava/lang/String;>;Ljava/lang/CharSequence; 98 methods: - id=1892428248,mod=0x8,name=<clinit>,sig=()V - id=1892428288,mod=0x1,name=<init>,sig=()V - id=1892428328,mod=0x0,name=<init>,sig=(II[C)V - id=1892428368,mod=0x1,name=<init>,sig=(Ljava/lang/String;)V - id=1892428408,mod=0x1,name=<init>,sig=(Ljava/lang/StringBuffer;)V - id=1892428448,mod=0x1,name=<init>,sig=(Ljava/lang/StringBuilder;)V - id=1892428488,mod=0x1,name=<init>,sig=([B)V ... VM> methods this.mActionBar Lcom/android/internal/app/WindowDecorActionBar; 110 methods: - id=9639,mod=0x8,name=<clinit>,sig=()V - id=9641,mod=0x1,name=<init>,sig=(Landroid/app/Activity;)V - id=9643,mod=0x1,name=<init>,sig=(Landroid/app/Dialog;)V - id=9645,mod=0x1,name=<init>,sig=(Landroid/view/View;)V - id=9647,mod=0xF0001008,name=access$000,sig=(Lcom/android/internal/app/WindowDecorActionBar;)Z - id=9649,mod=0xF0001008,name=access$100,sig=(Lcom/android/internal/app/WindowDecorActionBar;)Landroid/view/View; ... fields is used to list the fields of a type: VM> fields this Lcom/xyz/appcheck/AppCheck; 23 fields: - id=87,mod=0x18,name=MODTS,sig=Ljava/lang/String; - id=89,mod=0x18,name=TAG,sig=Ljava/lang/String; - id=91,mod=0xA,name=instance,sig=Lcom/xyz/appcheck/AppCheck; - id=93,mod=0x1,name=key,sig=Ljava/lang/String; - id=95,mod=0x1,name=tTGroup,sig=Ljava/lang/ThreadGroup; - id=97,mod=0x1,name=vArrayInt,sig=[I ... call is used to invoke any method on objects or classes. Arguments must be separated by commas, e.g. VM> call this toString string@9399:\"com.xyz.appcheck.AppCheck@7d6f5da\" VM> call v0 f1 \"hello\", \"world\" ... Warning Code is executed on the target when using the call command. The target state may be modified. get and set are used to read and write stack-frame local variables (similar to what the Locals view provide), object fields, and static fields: Reading a local variable: VM> get v0 1 VM> set v0 10 VM> get v0 10(Ah) Setting and reading an object's attributes: VM> set this.vArrayInt [I{1, 2, 3, 4} VM> get this.vArrayInt array@16049 (type=[I) [1, 2, 3, 4] VM> set this.mystring \"FOOBAR\" VM> get this.mystring string@1234:\"FOOBAR\" Reading a static field: VM> get Lcom/xyz/appcheck/AppCheck;->TAG string@15848:\"APPCHECK\" VM> set Lcom/xyz/appcheck/AppCheck;->TAG \"blah\" VM> get Lcom/xyz/appcheck/AppCheck;->TAG string@15844:\"blah\" Hint The interpreters support auto-completion with the Tab key. Native debugging # Note This section assumes that the app has bytecode and native libraries stored in the standard APK's lib/ folder. To debug native code only (Android or not), you will need to start gdbserver on the target manually, and connect remotely ( Debugger, Attach, Remote tab). Native debugging of Android apps is done remotely over the gdb protocol and the lldb extensions. JEB implements a gdb/lddb client and connects to the on-device gdb-server/lldb-server. By default, lldb-server is the preferred debugger server dropped on the target. Warning When attaching to the target app, remember to tick \"Allow Children Debuggers\". Needless to say, it is worth getting familiar with x86 and arm assembly (preferably their 64-bit variants, for which getting acquainted with their 32-bit parent if necessary). Active Debugger # Focus a fragment related to native debugging to ensure debugging commands are issued to the native debugger. If the Terminal is opened, the prompt will change to Process to reflect the change as well: interpreter commands will be issued to the gdbserver. Issue an info command, you should see basic target information, e.g.: Process> info Debuggee is running on ARM64 (LITTLE_ENDIAN) Target process id: 19218 Target is being debugged by lldb-server A breakpoint was hit in a SO file, and all native threads are paused Native threads vs VM threads # Warning Always remember that the Dalvik VM runs within the Native process, and that VM threads are backed by Native threads. That includes the JDWP server thread as well! If you pause Native threads, the VM threads will freeze as well, despite what the Dalvik debugger fragments may indicate. This \"nested debuggers\" situation, if not managed properly, can lead to strange situations, and in fine, the JDWP debugger may lose control of the target. Rules of thumb: when debugging native code, do not attempt to interact with the JDWP debugger make sure the Native process is not paused when issuing JDWP commands, e.g., unless necessary/wanted, you should disable Native breakpoints that may be hit and interrupt a VM debugging session abruptly Java to Native code transitions # Dalvik code can call into Native code by invoking methods with that have the Java modifier (attribute) native . Set a breakpoint on the dispatch instruction, not on the Java native method itself. When the breakpoint is hit, issue a Step Into command to auto-switch to Native code debugging Be patient, native code analysis is taking place as you're switching code The native breakpoint was automatically created and will be automatically released upon returning to Dalvik Resume native debugging to go back to Dalvik; the code will auto-break on return from invoke-xxx Example: Source: Java code: package com.xyz.appcheck ; class AppCheck { static { System . loadLibrary ( \"somelib\" ); } ... String foo () { ... return getPlatform (); } public native String getPlatform (); } ... C code: jstring Java_com_xyz_appcheck_AppCheck_getPlatform ( JNIEnv * env , jobject thiz ) { ... } Transition in JEB: How was Java's com.xyz.appcheck.AppCheck.getPlatform linked to C's Java_com_xyz_appcheck_AppCheck_getPlatform ? The process of binding Java methods to native methods (in the case above, binding was done automatically), as well as input and output object conversions and the library code to manipulate them while executing native code, is defined in the Java Native Interfaces specifications. JNI basics # Method linking and dispatching is an important aspect of JNI, which reverse-engineers should understand in order to work around difficult cases, including Java methods statically linked. Dynamic linking # When a native Java method is executed, the VM will look for a native method having: the following name: Short_Form= \"Java_\" + mangled_classname + \"_\" + mangled_methodname or, if the method is overloaded, the following name: Long_Form = Short_Form + \"__\" + mangled_argsigs The mangling scheme is the following: . => _ / => _ _ => _1 ; => _2 [ => _3 \\uXXXX => _0xxxx (unicode char.) Types names for mangled_argsigs are using the canonical JVM convention: boolean => Z byte => B char => C short => S int => I long => J float => F double => D classname => La/b/c/SomeClass; Details For additional details, refer to this part of the official specifications. Examples for auto-binding: void f(int x) in class com.xyz.A => short form: Java_com_xyz_A_f => long form: Java_com_xyz_A_f__I void g(long array[], String s) in class com.\\x4f60\\x597d => short form: Java_com__04f60_0597d_g => long form: Java_com__04f60_0597d_g___3JLjava_lang_String_2 Static linking # Native libraries can use the JNI function RegisterNatives to manually bind native methods to Java counterparts, while not adhering to the JNI naming convention used for dynamic linking. RegisterNatives can be called anywhere. Example In the snippet, a Java method a.b.c.Foo.methodX()V is bound to a static, non-exported native method routineX . jint JNI_OnLoad ( JavaVM * vm , void * reserved ) { JNIEnv * env = NULL ; if ( vm -> GetEnv ( & env , JNI_VERSION_1_4 ) != JNI_OK ) { return - 1 ; } if ( registerNatives ( env ) != JNI_TRUE ) { return - 1 ; } return JNI_VERSION_1_4 ; } int registerNatives ( JNIEnv * env ) { if ( ! registerNativeMethods ( env , classPathName , methods , sizeof ( methods ) / sizeof ( methods [ 0 ]))) { return JNI_FALSE ; } return JNI_TRUE ; } int registerNativeMethods ( JNIEnv * env , const char * className , JNINativeMethod * gMethods , int numMethods ) { jclass clazz = env -> FindClass ( className ); if ( clazz == NULL ) { return JNI_FALSE ; } if ( env -> RegisterNatives ( clazz , gMethods , numMethods ) < 0 ) { return JNI_FALSE ; } return JNI_TRUE ; } static const char * classPathName = \"a/b/c/Foo\" ; static JNINativeMethod methods [] = { { \"methodX\" , \"()V\" , ( void * ) routineX }, }; // bound to Java method: a.b.c.Foo.methodX()V static jint JNICALL routineX ( JNIEnv * env , jobject thiz , jint a , jint b , jint c ) { //... } Additional views # On top of the usual debugger fragment that were described in the Dalvik debugger section (threads, breakpoints, locals), native debuggers provide additional fragments. Memory code # The memory fragment displays the data and instructions located at any address within the target process. It is helpful in many situations, such as: - simple memory exploration and scanning - snooping around Dalvik VM internal structures, and modifying them - single-stepping over code outside the analyzed .so files contained in the app's lib/ folder A situation where the third scenario arises is when entering library code located somewhere in the process memory, outside a pre-analyzed so file. The execution will seem to have stalled in the main view (fixed blue line). Switch to the Memory Code fragment to see what is being executed. Stack # The stack view is similar to the memory fragment: it represents words of memory located at around the standard stack pointer on the target architecture (esp, rsp, r13, x31, etc.). Additional interpreter commands # ... Settings # The Android debuggers offer options to control low-level debugger parameters, such as ports and timeouts. Filter on dbug_apk and dbug_elf in the Engines options: The full documentation of each option can be found on this page . API, Scripts, Plugins # Debugger modules in implement the set of interfaces contained in the com.pnfsoftware.jeb.core.units.code.debug package. The principal interface in this package is IDebuggerUnit . Plugins, scripts, or third-party clients wishing to automate the usage of debuggers can use these well-defined interfaces. The official UI client uses this public API as well. Anything that the UI client does can be done and/or automated by third-party code. Example Check out our blog post on Android crypto primitives hooking to see how the API can be used to retrieve pre-encryption or post-decryption data on the fly. Further Reading # A note on debugging caveats with recent Android versions (p, Q): Debugging Android apps on Android Pie and above API/Scripting: Crypto Monitoring with the Android Debuggers API Use-case, obfuscation: Defeating AppSolid Android application protector Use-case, dynamic dex: Debugging Dynamically Loaded DEX Bytecode Files JNI debugging helper: Dynamic JNI Detection Plugin Reference: List to all blog articles on debugging","title":"Android Debugging"},{"location":"android-debugging.html#prerequisites","text":"The Android debuggers run on all JEB-supported platforms (Windows, Linux, macOS). Verify the following before attempting to start a debugging session: Make sure to have the Android SDK installed. You also want to have the ANDROID_SDK_ROOT environment variable pointing to the SDK folder. (The ANDROID_HOME variable is also checked, although it was deprecated.) Enable Developer options and allow USB debugging on the intended physical target device. (Debugging is enabled by default on the emulators.) On physical devices running Android 4.2 and above, one way to make sure that USB debugging is enabled is to run the adb devices command. If the device is shown as unauthorized , a pop-up on your phone will appear to request authorization.","title":"Prerequisites"},{"location":"android-debugging.html#fundamentals","text":"There are two types of debuggable entities on Android OS: Android/Linux processes Higher-level Dalvik virtual machines, running inside processes Debugging is generally performed remotely, on a separate computer. Nothing prevents you from debugging on the device itself though. Dalvik VM debugging is done over the Java Debug Wire Protocol (JDWP) protocol. The JDWP server runs inside the process hosting the DVM. JEB implements the JDWP client. Native code debugging is done via ptrace(2) . On the device, the debugger server process (generally gdb or lldb), runs alongside the target process and controls it via ptrace. JEB implements a gdb/lldb client. The DVM runs inside a native process","title":"Fundamentals"},{"location":"android-debugging.html#debugging-non-debuggable-apps","text":"Normally, only apps whose Android Manifest explicitly has a debuggable flag set to true are debuggable. However, this is rarely the case when analyzing in-the-wild malware or production applications. In such cases, you have several options: Run the app in an emulator. Emulators have the ro.debuggable property set to 1 (with an exception, see note below). This means they will debug all apps, regardless of the debuggable flag in the Manifest. In some situation, this may not be enough since several components, in the OS or the app itself, may check for the Manifest's debuggable flag before or during the app execution. Use a rooted phone. A rooted phone will allow you to modify the ro.debuggable property, and change it from 0 (standard on production devices) to 1. A rooted phone will also allow you to install additional low-level programs to ease debugging and potentially solve problems mentioned in the above bullet point. (The rooting process is out-of-scope here: it is device-specific and rooting instructions can easily be found online.) Repackage your app. This may be the simplest option. Use JEB's built-in tool makeapkdebug to generate a debuggable app. You will have to sign the generated app using your own key; be aware of the implications if you choose that option. See below for more details. Warning If you choose to debug in a Google-provided emulator image, make sure to use a non \"Google Play image\". Those images are lock-down production images. Instead, use a \"Google APIs image\" or a vanilla image (that doesn't ship with Google-specific libs).","title":"Debugging non-debuggable apps"},{"location":"android-debugging.html#native-code-in-non-debuggable-apps","text":"When it comes to debugging native code of non-debuggable apps on a rooted phone or emulator, other limitations apply. JEB tries its best at abstracting them away. However, things might be unstable depending on which phone and OS is being used. Do not hesitate to let us know if you encounter issues. Info Some limitations stem from the trusted run-as Android utility, which verifies whether an app is marked debuggable, regardless of the system's overall debuggability. JEB ships with a modified version of the utility, named ranod , which does not perform such checks. Decompiling the x86 build of run-as Note that most of our tests are done on Pixel devices running vanilla Android Oreo. Using similar devices for debugging will likely reduce the chances of running into corner-case problematic situations.","title":"Native code in non-debuggable apps"},{"location":"android-debugging.html#generating-a-debuggable-apk","text":"It is generally easier to debug Android applications explicitly marked debuggable in their Manifest: <application android:debuggable=\"true\" ...>; JEB has built-in utility to rebuild a non-debuggable APK into a debuggable one, while maintaining the entire structure of the application intact, except for its signing data of course. Navigate to your JEB folder, and use the start-up script, e.g. on Windows: $ jeb_wincon.bat -c --makeapkdebug -- file.apk Upon success, file_debuggable.apk will be generated. Sign it using the Android SDK's apksigner , e.g. on Windows: $ apksigner.bat sign -ks SOME_KEYSTORE.JKS file_debuggable.apk Install it on your device, and start debugging. Warning Keep in mind that this solution has shortcomings: Anti-debugging code may check at runtime that the app is not debuggable, as would be expected. More elaborate protections may implement certificate pinning-style checks, where the code verifies that it is signed using a specific certificate.","title":"Generating a debuggable APK"},{"location":"android-debugging.html#app-bundles-multi-apk-apps","text":"When a vendor develops their app as an Android App Bundle , the distributing store will send the app as a collection of smaller-sized APKs tailored to the requesting device configuration. A common split is the following: base APK (common for all devices) graphical resources APK (low-dpi, medium-dpi, high-dpi, etc.) localized resources APK (English locale, French locale, etc.) native libs APK (x86, arm, arm64, etc.) If you need to pull those apps from a device and make them debuggable, you should run --makeapkdebug on all APKs and re-sign them with the same key of your choice. You may then install the app as usual via adb install-multiple .","title":"App Bundles (multi-APK apps)"},{"location":"android-debugging.html#starting-a-debugging-session","text":"Android debugging sessions can be started when analyzing APK files. If your main artifact is an orphan DEX file, the client will refuse to start a debugging session. First, retrieve your target APK and get the app ready for debugging: Make sure the APK matches the one that will be executed on the target phone. You can download the APK using adb : adb shell pm list packages -f to retrieve a list of packages and the associated path to APK adb pull <pathToAPK> to download the APK Start the app on the phone Via the App Launcher for instance, if attaching to an already running app is an acceptable scenario If you want the app to wait for the debuggers to attach to it before it starts executing any code, you can run something like: adb shell am start -D -S -n <packageName>/<activityName> A pop-up will be displayed on the phone, indicating it is waiting for a debugger to attach to the VM Second, in the UI client: Load the APK file Open a view of a primary DEX unit Once the focus is on the DEX view, open the Debugger menu, and click on Start... The Debugger/Start command, used to start or attach a debugger, is available once the code view of a supported code unit has the focus. Here, the focus was on Dalvik bytecode. In the Attach dialog window: Select the target phone and the target process that matches your app, and click Attach. Unless you tick the \"Suspend all threads\", The app will be immediately be run/resumed after attaching. The process filter is normally filled out with the APK package name. Simply press enter to filter out entries. Heads-up Tick \"Allow children debuggers\" if you wish to debug native code as well.","title":"Starting a debugging session"},{"location":"android-debugging.html#common-problems","text":"Unable to debug native code of an Android app? Make sure to tick the box \"Allow children debuggers\" before attaching. Impossibility to read (most) local vars in Dalvik The issue is affecting Android Pie (API 28) and Q (API 29). We wrote a blog explaining the details of the problem (unfortunately, not a fixable one). If possible, switch to Android Oreo or below (<= API 27) or Android R or above (>= API 30). Cannot attach to a non-debuggable app but the phone is rooted Having a rooted phone is not enough. System components checks for the app's debuggability (i.e., the Manifest's android:debuggable flag) in various places, regardless of whether the image is a locked production image, rooted image, debug or dev build, etc. While it is relatively easy to debug Dalvik, native debugging is generally more tricky. JEB does a few things to ease settings things up: It attempts to set the system property ro.debuggable to 1 It attempts to replace the run-as utility by one that does not check the debuggable flag (more details later in this doc). In order to do any of the above, root privilege is required, and JEB assumes the su tool has been dropped in a standard location ( /bin/su , /sbin/su , /system/bin/su , /system/xbin/su , /data/local/su , /data/local/bin/su , /data/local/xbin/su , /system/sd/xbin/su , /system/bin/failsafe/su , /su/bin/su ). Files may have to be dropped in the /system folder. That folder is read-only by default and needs to be remounted read-write. Root privileges may not suffice: if you are using an emulator, configuration may default to a read-only system image. You will need to explicitly specify that the system can be written to, e.g.: $ <SDK>/emulator/emulator -avd [image_folder_name] -writable-system JEB also attempts to disable SEAndroid by issuing a setenforce 0 command. The aforementioned settings and techniques may not suffice. Whenever possible, we encourage debugging on the Lolipop-Oreo range (5.0 to 8.1 / API 21 to 27) with vanilla images. Ideally, you'll want to have a debuggable app. Again, it may not be always possible or realistic (e.g., debugging a system app and a custom vendor's locked image), but in many cases (e.g., malware analysis), it is possible.","title":"Common problems"},{"location":"android-debugging.html#debugger-nodes","text":"After attaching, the app, you should see one or two additional nodes in the Project tree view. One debugger node for Dalvik, an optional debugger node for native code. Two debugger nodes ( VM , Process ) attached to the target Note When a debugger is successfully attached, the corresponding node has a light green background. Additional views and fragments displaying the debuggers' states and commands are added to the workspace:","title":"Debugger nodes"},{"location":"android-debugging.html#native-threads","text":"Caution Keep in mind that pausing the Process debugger (i.e., suspending the native threads) will freeze the higher-level Dalvik VM! An app's Dalvik VM runs inside a Linux process. Therefore, any action taken using the native debugger (if native debugger was attached) may affect a VM debugging session as well.","title":"Native threads"},{"location":"android-debugging.html#dalvik-debugging","text":"","title":"Dalvik debugging"},{"location":"android-debugging.html#active-debugger","text":"In the general case, the focused UI fragment will determine which debugger will receive input commands. Therefore, be mindful of which debugger is being controlled when invoking commands (via menu entries, toolbar or keyboard). E.g., if the focus is on a DEX view, the controls are connected to the VM (Dalvik) debugger; if the focus is within a code view connected to the Process debugger, the controls are connected to the Process debugger.","title":"Active debugger"},{"location":"android-debugging.html#controls","text":"Standard debugger controls can be accessed via the Debugger menu or the toolbar area. They allow: Attaching, detaching, terminating the process Pausing and resuming the process and, possibly, its individual threads Stepping (into, over, out of) Toggling execution breakpoints Not all controls can or are implemented for both debuggers. Currently for instance, pausing individual threads of the Process debugger is not possible. When a control is not available, depending on which control it is and the severity of the failed operation, the user may be unable to activate it (e.g., grayed button), receive an error in the logger, or receive a pop-up error in the client.","title":"Controls"},{"location":"android-debugging.html#setting-breakpoints","text":"Breakpoints can be set/unset using the handy Control+B (Command+B on macOS) shortcut. An icon is displayed in the left vertical bar of a code view to represent enabled/disabled breakpoints. Two breakpoints, one is enabled, the other one is disabled Note Toggling breakpoints on and off is currently not available in decompiled views.","title":"Setting breakpoints"},{"location":"android-debugging.html#registering-additions","text":"When starting a debugging session, the debugger attaches to an APK's DEX unit as well as subsequent compatible code units dynamically added to your Project.","title":"Registering additions"},{"location":"android-debugging.html#dynamic-additions-dex-code","text":"However, in some cases, the debugger will not automatically pick up and attach to additional DEX units (e.g., nested DEX units). You may ask the debugger to register additional code units via the Debugger, Register Addition action: The handler will be enabled and can be invoked when a debugger fragment has the focus We are attaching classes.jar to the current debugging Note Make sure to focus a fragment pertaining to the debugger which should link the target code unit before executing Debugger, Register Addition .","title":"Dynamic additions: Dex code"},{"location":"android-debugging.html#dynamic-additions-native-code","text":"Similarly, native library artifacts may be added to a project, processed, and attached to a native debugger after a debugging session has started. Note For native unit additions, the unit name must reflect the library name loaded in the process. Use the libs command in the debugger terminal to determine an actual library name. If names mismatch, the debugger will not be able to find out the actual library image base. If you need to rename a unit, right-click the unit node in the Project Explorer panel, and select Properties. Demo video: Dynamically adding an .so file to a debugging session","title":"Dynamic additions: Native code"},{"location":"android-debugging.html#views-and-fragments","text":"","title":"Views and fragments"},{"location":"android-debugging.html#threads","text":"The Threads view displays thread identifiers, status (running, suspended, waiting, etc.) as well as the stackframes when a thread is paused. Depending on the target processor, there may be one or more stackframes, showing the location (program counter register or address) of the current thread. Info Full status list: CREATED, RUNNING, PAUSED (=SUSPENDED), SLEEPING, WAITING, ZOMBIE, MONITOR, TERMINATED. Not all status may be relevant to a given architecture. The default thread can be selected by double-clicking or right-clicking, Set as default thread . By default, when a breakpoint is hit, only the active thread is suspended . The other threads are not. Other threads can be suspended with Terminal commands. A suspended thread after execution hit a breakpoint","title":"Threads"},{"location":"android-debugging.html#breakpoints","text":"The Breakpoints view displays active and inactive code breakpoints. Note The JEB API allows settings breakpoints on instructions and breakpoint on methods (method entry, method exit). Other capabilities exist, not readily available in UI client, e.g. breakpoint on class load event, breakpoint on exception, etc. Two breakpoints, one is enabled, the other one is disabled","title":"Breakpoints"},{"location":"android-debugging.html#locals","text":"The Locals view displays generic variables registers. They can be virtual slots of a VM, registers of a native process, complex variables inferred by the decompiler, etc. For JDWP, what is displayed is: this for Non-static methods locals of the selected (and paused) thread's top frame; variables for other frames can be examined via Terminal commands Primitives and String values can be updated. click on the cell of the value to be written, in the Value column set the new value and press Enter Updating a String object Note that JEB attempts to maintain the state of this fragment across your debugging sessions, even though variables references, values (and subs) may change as you step through code, etc. JEB does its best at displaying very large arrays efficiently as well. However, keep in mind that adb is slow, and maintaining live variable views up-to-date across stepping can be costly. You may temporarily disable Refresh by pressing the \"Freeze Refresh\" button. Variable types For safety reasons, Dex metadata providing locals types and/or names information is disregarded, since it cannot be trusted and using bad types can crash the DVM debugging server. See the sub-section below about JDWPD caveats.","title":"Locals"},{"location":"android-debugging.html#live-overlays","text":"Hover over a variable, register, or field to see its contents. The thread must be paused. Hovering over p0 (equivalent to v7 in the examined method)","title":"Live overlays"},{"location":"android-debugging.html#other-fragments","text":"The Stack and Memory fragments are irrelevant for JDWP debugging","title":"Other fragments"},{"location":"android-debugging.html#jdwp-caveats","text":"Info This short section highlights limitations pertaining the Dalvik debugging via JDWP, both on the server (device) and the client (JEB) side. JDWP was specified and designed by Oracle for the Java VM. The Dalvik VM implements parts of the specifications and the Binary Protocol .","title":"JDWP caveats"},{"location":"android-debugging.html#capabilities","text":"The Capabilities and CapabilitiesNew commands of the VirtualMachine command set can be used to retrieve the list of features offered by a JDWP server. E.g., register watches are not supported by the Dalvik debugger server. Although the JEB Android debugging modules implement JDWP with regards to what the Dalvik JDWP server provides, not all JDWP are currently exposed through the UI client or even API. E.g., JDWP allows debugger clients to specify if one or all threads should be stopped when a breakpoint is hit; currently, JEB debugger API does not provide a method to control that setting.","title":"Capabilities"},{"location":"android-debugging.html#variable-typing","text":"Why are most locals typed as 'int' by default? The general reason is safety. Caution The Dalvik VM will crash the JDWP server attempts to read a non-reference as a reference; most non-references are obvious (e.g., 1, 2, small ints -> non refs.) but some ints may not be - relying on DEX metadata is also unsafe. However, most variables can be retyped. Click on a type cell to edit contents: Changing the type of v0 to long: type long , press Enter. The resulting value is the long interpretation of {v0,v1} Changing the type of p0 to object: type object , press Enter. If the reference truly is an object, the correct type will be retrieved. If it is not, the VM may crash.","title":"Variable typing"},{"location":"android-debugging.html#variable-vs-parameter","text":"In Dalvik, vX is the preferred notation to reference variables of a method's stack frame. In this case, X is an index relative to the top of the frame. Another notation, originating from Java, is pX . That notation is primarily used to specify parameters, X being an index such that all of a method's parameters (including this) are located at the very bottom of the frame. (Converting from vX to pX and vice-versa is detailed in the Android page.) The JDWP protocol was designed by Sun/Oracle. As such, and although JDWP specifications do not explicitly specify that, it may seem intuitive to assume that the indices used by JDWP to designate variables in a frame would be pX indices. It seems that used to be the case until API 27 (included). From API 28 onward, indices used to refer to variables are vX indices. Knowing this fact is crucial when it comes to reading and writing variables of a frame. JEB attempts to determine this automatically. However, if incongruities seem to show in the Variables GUI fragment, it may be that wrong indices are being sent out in JDWP commands. In such a case, use the debugger interpreter's frameSlotIndexMode command to manually set the index mode. See the section below for details about the Interpreter and how to use it.","title":"Variable vs Parameter"},{"location":"android-debugging.html#unreadable-variables","text":"On Android P and Q (API levels 28 and 29), the values of variables without valid debug information are not provided by the debugging server. If an attempt to read them is made, the debugger server issues a JDWP error 35 (\"Invalid slot\"). Therefore, when debugging applications on Android P/Q, JEB will not be able to provide the values of all variables. To see which locals are declared in the debug information of a method, enable \"Show Debug Directives\" in the options (right-click in the Assembly view, Rendering Options). The debug variables are declared with \".local vX ...\". This problem was fixed in Android R and above: All initialized local variables are readable. More information on this blog post .","title":"Unreadable variables"},{"location":"android-debugging.html#interpreter-commands","text":"The debugger units implement IUnit.getCommandInterpreter method to provide clients with command interpreters used to execute fine-grained debugger commands that may not be readily available in the UI client. All command interpreters are accessible via the Console tab. Once the Android debuggers are attached, switch over to the Console view, and type list . This command will list all command interpreters currently attached to the console: The terminal below that can be bound to 3 command interpreters, including two provided by active Debugger units An interpreter has a numeric id as well as the name of the unit that created it. Switch to an interpreter with the use <id|name> command. The special command help , available in all interpreter contexts, lists all commands made available by the interpreter currently in use. > list 3 interpreters available (0) py: Python Interpreter (built on Jython 2.7) (1) VM: Debugger interpreter for VM (2) Process: Debugger interpreter for Process > use 1 VM> help info : Display basic information about the debuggee libs|modules [name-filter] : Display information about the target modules resume [tid] : Run or resume the target, a thread, or the default thread (tid 0) pause : Pause the target detach : Detach the target (if possible) kill|terminate : Kill the target (unstable) threads : List the process threads thread [tid] : Set or get the default thread step|stepi : Step \"into\" one instruction in the default thread stepo : Step \"over\" one instruction in the default thread stepu : Step \"up\"/\"out\" (run until return) in the default thread b|bp [address] : Set or list breakpoints bc [index] : Clear one or all breakpoints frameSlotIndexMode mode : Set the index type used to retrieve thread frames' variables (AUTO, PAR, VAR) classes : List the classes loaded by the VM signature|sig [OPTION]... cid : Information about a specific class fields [OPTION]... cid : List the fields of a type methods [OPTION]... cid : List the methods of a type call|invoke [OPTION]... cid method : invoke a method. read|get [OPTION]... objectId : Read an object or array. set [OPTION]... objectId new_value : Set a method variable or parameter as a typed-value pull remotePath localPath : adb-pull on steroid VM> Warning Many commands can only run when the target or target thread is suspended or paused. Hint Type help <command> to see specific help for that command. Hint Press Enter on a white-line to repeat the previously executed command. There are three types of commands offered by the Dalvik debugger VM interpreter: program commands: info , libs , detach , kill , pull , frameSlotIndexMode thread commands: thread , threads , pause , resume , step , stepo , stepu , b , bc object interaction commands: classes , sig , fields , methods , call , get , set","title":"Interpreter Commands"},{"location":"android-debugging.html#program-commands","text":"info will provide information about JDWP. Below, Java 8 and JVM-DI 2. VM> info Debuggee is running on ? VM information: JDWP:\"Java Debug Wire Protocol (Reference Implementation) version 1.8 JVM Debug Interface version 1.2 JVM version 8 (Dalvik, )\" v1.8 (VM:Dalvik v8) VM identifier sizes: f=8,m=8,o=8,rt=8,fr=8 libs will always be empty for a JDWP debugger: libraries are not application to Dalvik bytecode running in a VM. Info A native debugger's libs command does provide information. detach will attempt to detach the target without killing it kill will terminate the target process (and therefore detach from it as well) pull is similar to adb pull ... but will make use of the su binary to elevate privileges when necessary (assuming su be present and found on the target device). frameSlotIndexMode is used to switch between parameter-indices (pX) and variable-indices (vX) when issuing thread frame slot read/write commands. (See above for details on which scenarios this command may be useful.)","title":"Program commands"},{"location":"android-debugging.html#thread-commands","text":"thread is used to retrieve or set the default thread, i.e. the thread to which most commands will be applied to if no thread id is explicitly provided. threads lists the threads and their states pause suspends the target: all threads will be suspended resume resumes the target: all threads will be resumed. Warning Keep in mind that pausing/resuming actions are stacked. E.g., a a thread X was already suspended, executing pause , then resume , will not resume thread X. step or stepi is used to perform a single-step, and enter methods (Dalvik or Native) if necessary stepo performs a single-step but does not enter methods. stepu will step until the current method returns. b is used to list or add breakpoints on method's bytecode (not the method itself) or fields. Breakpoints on fields will trigger on field access (read or write). VM> b 0 - Lcom/xyz/appcheck/AppCheck;->vFloat:F [enabled: true] 1 - Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+23Ah [enabled: true] 2 - Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+248h [enabled: false] 3 - Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+250h [enabled: true] VM> b Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+21Ah Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+21Ah (u={Unit:name={Bytecode},type={dex}},a={Lcom/xyz/appcheck/AppCheck;->runTest(Lcom/xyz/appcheck/TestId;)Z+21Ah}) [enabled=true] bc is used to clear one or all breakpoints. VM> bc 5 # clear breakpoint #5 VM> bc # clear all breakpoints","title":"Thread commands"},{"location":"android-debugging.html#classobject-commands","text":"classes lists all currently loaded classes. Not all classes of an app may be loaded when the command is executed. Info Types are referenced by their canonical JVM name (Lcom/abc/Foo;) or their cid (internal id representing a type during for a given debugging session). A target class can also be inferred from an object reference: this object the object id, prefixed with @ character any object that can be referenced from these ones. Types have an associated type tag (1 for a class, 2 for an interface, 3 for an array) and a status bit flags (0x1 if the type was verified, 0x2 if it was prepared, 0x4 if it's been loaded, 0x8 on error; most types listed by the classes command should have status 7, meaning they have been verified, prepared and loaded). VM> classes 15822 classes - id=4542,tag=2,status=0x7,sig=Landroid/hardware/radio/V1_4/IRadioResponse; - id=1849,tag=1,status=0x7,sig=Lcom/android/internal/telephony/uicc/euicc/-$$Lambda$EuiccCard$okradEAowCk8rNBK1OaJIA6l6eA; - id=8675,tag=1,status=0x7,sig=Landroid/net/NetworkRequest$2; - id=4819,tag=1,status=0x7,sig=Landroid/net/NetworkRequest$Type;,genSig=Ljava/lang/Enum<Landroid/net/NetworkRequest$Type;>; - id=3277,tag=1,status=0x7,sig=Landroid/os/IProgressListener$Stub; - id=12717,tag=2,status=0x7,sig=Ljava/net/SocketImplFactory; ... methods is used to list the methods of a type: VM> methods Ljava/lang/String; sig=Ljava/lang/String;,genSig=Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable<Ljava/lang/String;>;Ljava/lang/CharSequence; 98 methods: - id=1892428248,mod=0x8,name=<clinit>,sig=()V - id=1892428288,mod=0x1,name=<init>,sig=()V - id=1892428328,mod=0x0,name=<init>,sig=(II[C)V - id=1892428368,mod=0x1,name=<init>,sig=(Ljava/lang/String;)V - id=1892428408,mod=0x1,name=<init>,sig=(Ljava/lang/StringBuffer;)V - id=1892428448,mod=0x1,name=<init>,sig=(Ljava/lang/StringBuilder;)V - id=1892428488,mod=0x1,name=<init>,sig=([B)V ... VM> methods this.mActionBar Lcom/android/internal/app/WindowDecorActionBar; 110 methods: - id=9639,mod=0x8,name=<clinit>,sig=()V - id=9641,mod=0x1,name=<init>,sig=(Landroid/app/Activity;)V - id=9643,mod=0x1,name=<init>,sig=(Landroid/app/Dialog;)V - id=9645,mod=0x1,name=<init>,sig=(Landroid/view/View;)V - id=9647,mod=0xF0001008,name=access$000,sig=(Lcom/android/internal/app/WindowDecorActionBar;)Z - id=9649,mod=0xF0001008,name=access$100,sig=(Lcom/android/internal/app/WindowDecorActionBar;)Landroid/view/View; ... fields is used to list the fields of a type: VM> fields this Lcom/xyz/appcheck/AppCheck; 23 fields: - id=87,mod=0x18,name=MODTS,sig=Ljava/lang/String; - id=89,mod=0x18,name=TAG,sig=Ljava/lang/String; - id=91,mod=0xA,name=instance,sig=Lcom/xyz/appcheck/AppCheck; - id=93,mod=0x1,name=key,sig=Ljava/lang/String; - id=95,mod=0x1,name=tTGroup,sig=Ljava/lang/ThreadGroup; - id=97,mod=0x1,name=vArrayInt,sig=[I ... call is used to invoke any method on objects or classes. Arguments must be separated by commas, e.g. VM> call this toString string@9399:\"com.xyz.appcheck.AppCheck@7d6f5da\" VM> call v0 f1 \"hello\", \"world\" ... Warning Code is executed on the target when using the call command. The target state may be modified. get and set are used to read and write stack-frame local variables (similar to what the Locals view provide), object fields, and static fields: Reading a local variable: VM> get v0 1 VM> set v0 10 VM> get v0 10(Ah) Setting and reading an object's attributes: VM> set this.vArrayInt [I{1, 2, 3, 4} VM> get this.vArrayInt array@16049 (type=[I) [1, 2, 3, 4] VM> set this.mystring \"FOOBAR\" VM> get this.mystring string@1234:\"FOOBAR\" Reading a static field: VM> get Lcom/xyz/appcheck/AppCheck;->TAG string@15848:\"APPCHECK\" VM> set Lcom/xyz/appcheck/AppCheck;->TAG \"blah\" VM> get Lcom/xyz/appcheck/AppCheck;->TAG string@15844:\"blah\" Hint The interpreters support auto-completion with the Tab key.","title":"Class/object commands"},{"location":"android-debugging.html#native-debugging","text":"Note This section assumes that the app has bytecode and native libraries stored in the standard APK's lib/ folder. To debug native code only (Android or not), you will need to start gdbserver on the target manually, and connect remotely ( Debugger, Attach, Remote tab). Native debugging of Android apps is done remotely over the gdb protocol and the lldb extensions. JEB implements a gdb/lddb client and connects to the on-device gdb-server/lldb-server. By default, lldb-server is the preferred debugger server dropped on the target. Warning When attaching to the target app, remember to tick \"Allow Children Debuggers\". Needless to say, it is worth getting familiar with x86 and arm assembly (preferably their 64-bit variants, for which getting acquainted with their 32-bit parent if necessary).","title":"Native debugging"},{"location":"android-debugging.html#active-debugger_1","text":"Focus a fragment related to native debugging to ensure debugging commands are issued to the native debugger. If the Terminal is opened, the prompt will change to Process to reflect the change as well: interpreter commands will be issued to the gdbserver. Issue an info command, you should see basic target information, e.g.: Process> info Debuggee is running on ARM64 (LITTLE_ENDIAN) Target process id: 19218 Target is being debugged by lldb-server A breakpoint was hit in a SO file, and all native threads are paused","title":"Active Debugger"},{"location":"android-debugging.html#native-threads-vs-vm-threads","text":"Warning Always remember that the Dalvik VM runs within the Native process, and that VM threads are backed by Native threads. That includes the JDWP server thread as well! If you pause Native threads, the VM threads will freeze as well, despite what the Dalvik debugger fragments may indicate. This \"nested debuggers\" situation, if not managed properly, can lead to strange situations, and in fine, the JDWP debugger may lose control of the target. Rules of thumb: when debugging native code, do not attempt to interact with the JDWP debugger make sure the Native process is not paused when issuing JDWP commands, e.g., unless necessary/wanted, you should disable Native breakpoints that may be hit and interrupt a VM debugging session abruptly","title":"Native threads vs VM threads"},{"location":"android-debugging.html#java-to-native-code-transitions","text":"Dalvik code can call into Native code by invoking methods with that have the Java modifier (attribute) native . Set a breakpoint on the dispatch instruction, not on the Java native method itself. When the breakpoint is hit, issue a Step Into command to auto-switch to Native code debugging Be patient, native code analysis is taking place as you're switching code The native breakpoint was automatically created and will be automatically released upon returning to Dalvik Resume native debugging to go back to Dalvik; the code will auto-break on return from invoke-xxx Example: Source: Java code: package com.xyz.appcheck ; class AppCheck { static { System . loadLibrary ( \"somelib\" ); } ... String foo () { ... return getPlatform (); } public native String getPlatform (); } ... C code: jstring Java_com_xyz_appcheck_AppCheck_getPlatform ( JNIEnv * env , jobject thiz ) { ... } Transition in JEB: How was Java's com.xyz.appcheck.AppCheck.getPlatform linked to C's Java_com_xyz_appcheck_AppCheck_getPlatform ? The process of binding Java methods to native methods (in the case above, binding was done automatically), as well as input and output object conversions and the library code to manipulate them while executing native code, is defined in the Java Native Interfaces specifications.","title":"Java to Native code transitions"},{"location":"android-debugging.html#jni-basics","text":"Method linking and dispatching is an important aspect of JNI, which reverse-engineers should understand in order to work around difficult cases, including Java methods statically linked.","title":"JNI basics"},{"location":"android-debugging.html#dynamic-linking","text":"When a native Java method is executed, the VM will look for a native method having: the following name: Short_Form= \"Java_\" + mangled_classname + \"_\" + mangled_methodname or, if the method is overloaded, the following name: Long_Form = Short_Form + \"__\" + mangled_argsigs The mangling scheme is the following: . => _ / => _ _ => _1 ; => _2 [ => _3 \\uXXXX => _0xxxx (unicode char.) Types names for mangled_argsigs are using the canonical JVM convention: boolean => Z byte => B char => C short => S int => I long => J float => F double => D classname => La/b/c/SomeClass; Details For additional details, refer to this part of the official specifications. Examples for auto-binding: void f(int x) in class com.xyz.A => short form: Java_com_xyz_A_f => long form: Java_com_xyz_A_f__I void g(long array[], String s) in class com.\\x4f60\\x597d => short form: Java_com__04f60_0597d_g => long form: Java_com__04f60_0597d_g___3JLjava_lang_String_2","title":"Dynamic linking"},{"location":"android-debugging.html#static-linking","text":"Native libraries can use the JNI function RegisterNatives to manually bind native methods to Java counterparts, while not adhering to the JNI naming convention used for dynamic linking. RegisterNatives can be called anywhere. Example In the snippet, a Java method a.b.c.Foo.methodX()V is bound to a static, non-exported native method routineX . jint JNI_OnLoad ( JavaVM * vm , void * reserved ) { JNIEnv * env = NULL ; if ( vm -> GetEnv ( & env , JNI_VERSION_1_4 ) != JNI_OK ) { return - 1 ; } if ( registerNatives ( env ) != JNI_TRUE ) { return - 1 ; } return JNI_VERSION_1_4 ; } int registerNatives ( JNIEnv * env ) { if ( ! registerNativeMethods ( env , classPathName , methods , sizeof ( methods ) / sizeof ( methods [ 0 ]))) { return JNI_FALSE ; } return JNI_TRUE ; } int registerNativeMethods ( JNIEnv * env , const char * className , JNINativeMethod * gMethods , int numMethods ) { jclass clazz = env -> FindClass ( className ); if ( clazz == NULL ) { return JNI_FALSE ; } if ( env -> RegisterNatives ( clazz , gMethods , numMethods ) < 0 ) { return JNI_FALSE ; } return JNI_TRUE ; } static const char * classPathName = \"a/b/c/Foo\" ; static JNINativeMethod methods [] = { { \"methodX\" , \"()V\" , ( void * ) routineX }, }; // bound to Java method: a.b.c.Foo.methodX()V static jint JNICALL routineX ( JNIEnv * env , jobject thiz , jint a , jint b , jint c ) { //... }","title":"Static linking"},{"location":"android-debugging.html#additional-views","text":"On top of the usual debugger fragment that were described in the Dalvik debugger section (threads, breakpoints, locals), native debuggers provide additional fragments.","title":"Additional views"},{"location":"android-debugging.html#memory-code","text":"The memory fragment displays the data and instructions located at any address within the target process. It is helpful in many situations, such as: - simple memory exploration and scanning - snooping around Dalvik VM internal structures, and modifying them - single-stepping over code outside the analyzed .so files contained in the app's lib/ folder A situation where the third scenario arises is when entering library code located somewhere in the process memory, outside a pre-analyzed so file. The execution will seem to have stalled in the main view (fixed blue line). Switch to the Memory Code fragment to see what is being executed.","title":"Memory code"},{"location":"android-debugging.html#stack","text":"The stack view is similar to the memory fragment: it represents words of memory located at around the standard stack pointer on the target architecture (esp, rsp, r13, x31, etc.).","title":"Stack"},{"location":"android-debugging.html#additional-interpreter-commands","text":"...","title":"Additional interpreter commands"},{"location":"android-debugging.html#settings","text":"The Android debuggers offer options to control low-level debugger parameters, such as ports and timeouts. Filter on dbug_apk and dbug_elf in the Engines options: The full documentation of each option can be found on this page .","title":"Settings"},{"location":"android-debugging.html#api-scripts-plugins","text":"Debugger modules in implement the set of interfaces contained in the com.pnfsoftware.jeb.core.units.code.debug package. The principal interface in this package is IDebuggerUnit . Plugins, scripts, or third-party clients wishing to automate the usage of debuggers can use these well-defined interfaces. The official UI client uses this public API as well. Anything that the UI client does can be done and/or automated by third-party code. Example Check out our blog post on Android crypto primitives hooking to see how the API can be used to retrieve pre-encryption or post-decryption data on the fly.","title":"API, Scripts, Plugins"},{"location":"android-debugging.html#further-reading","text":"A note on debugging caveats with recent Android versions (p, Q): Debugging Android apps on Android Pie and above API/Scripting: Crypto Monitoring with the Android Debuggers API Use-case, obfuscation: Defeating AppSolid Android application protector Use-case, dynamic dex: Debugging Dynamically Loaded DEX Bytecode Files JNI debugging helper: Dynamic JNI Detection Plugin Reference: List to all blog articles on debugging","title":"Further Reading"},{"location":"android.html","text":"Previous material We recommend the reader to be familiar with the platform-agnostic sections Actions , Views , and Decompiling before proceeding with Android-specific contents. JEB is a well-known industry tool used to reverse-engineer and audit Android applications. You will be able to: Analyze APK files and their contents, including DEX files, Certificates, Resources, Assets, Native Library code, etc. Examine encoded resource files and manifests, including resources with obfuscated names and locations. Examine app certificates (legacy, v2, v3) Decompile DEX bytecode, with full-support for multi-DEX reconstruction. Analyze native library code: more on the Native code analysis section Debug Android applications (Dalvik and Native - x86, arm, mips - code) and transition seamlessly from Dalvik to Native, and vice-versa. Write your own extensions using the API (client scripts in Python, back-end plugins and scripts). Plugins # The plugins used to analyze Android apps consist of: The APK plugin is responsible for processing APK files. Encoded resources (arsc) are decoded by this plugin. Other jobs, such as analyzing dex files, analyzing certificates, processing asset files, analyzing binary files, etc. are delegated to appropriate plugins. The DEX plugins: DEX analyzer (DEX parsing and merging, Dalvik disassembling, etc.), DEX decompiler, DEX debuggers. Native code analyzers: disassemblers, decompilers, etc. A handful of other plugins, such as Certificate parsers, XML/HTML/JSON/etc. parsers. This section mostly focuses on the APK plugin and the DEX analyzer. Other plugins are documented in separate sections of this manual. Technical Blogs # Our blog is filled with technical posts that will help you make the most of JEB. It is the ideal companion to this manual. Link: All PNF Software blog posts tagged Android. API Levels # API levels are regularly mentioned throughout this document. Here is a list of \"recent\" Android versions, their corresponding API levels, as well as notable changes regarding security. Codename Version API level Date New security features Tiramisu 13 32 2022 TBD S 12 31 2021 Privacy dashboard, Private Compute Core, approximate location, a/v indicators R 11 30 2020 Privacy updates, APK Signature Scheme v4 Q 10 29 2019 Permissions for privacy, BiometricPrompt Pie 9 28 2018 ART: Vdex with Cdex, AS-FBE, biometric API, lockdown mode, APK Signature Scheme v3 Oreo 8, 8.1 26, 27 2017 ART: OAT with Vdex (oat w/o dex, separate vdex with dex'es), Google Play Protect Nougat 7, 7.1 24, 25 2016 APK Signature Scheme v2, File Based Encryption (FBE - and consequently, DirectBoot), AS-FDE, Android Things Marshmallow 6 23 2015 Adoptable Storage (AS), granular permissions and permission levels (NORMAL, DANGEROUS), Doze & App Standby, Android Wear Lollipop 5, 5.1 21, 22 2014 ART: OAT with dex'es in .rodata, 64-bit support (x86_64, arm64-v8a), Android Auto KitKat 4.4, 4.4W 19, 20 2013 ART (optional), VerifiedBoot, Full Disk Encryption (FDE) Jelly Bean 4.1, 4.2, 4.3 16, 17, 18 2012 SELinux introduction, multi-users Android Versions Reference APK Structure # This section is a short primer on the Android Package file (APK). It is assumed that the reader is already familiar with the structure of an APK. Good introduction material can be found on the official Android developer portal . An Android app is a zip file containing application code, data, and metadata. Code: Dalvik (bytecode), Native (*.so libs) Data: resources (structured), assets (unstructured) Metadata= manifest (what), certificates (who) When JEB processes an APK, the resulting structure in the Project tree will differ from a raw ZIP tree view. The range of differences goes from slightly for regular apps, to significantly for obfuscated or complex apps. The picture below shows a side-by-side comparison of processing an app as a ZIP file vs processing it as an APK: Manifest: encoded VS decoded Certificates: v1 (visible, in file MANIFEST.MF), v2/v3 (in ZIP) VS parsed certificates Bytecode: split over classes.dex, classes1.dex, ..., classesN.dex VS virtual merged DEX unit Resources: encoded and scattered in resources.arsc, res/, elsewhere (anywhere) VS decoded and reorganized resources Native libs: 1-to-1 Assets: 1-to-1 Certificates # As of Android 11, four types of signatures are in place to sign APKs, versions 1 through 4. Version 1 # Version 1 is the legacy scheme supported by all versions of Android: standard Jar signing (Oracle) signing data goes in META-INF/ each individual file in the archive is signed MANIFEST.MF: list of hashes of all files xxx.SF: hash of hash entries in MANIFEST.MF xxx.{RSA,DSA,...}: signature of xxx.SF + signer certificate (= what JEB displays) note that xxx='CERT', usually The apk/zip itself is not signed: this scheme is both inefficient and incomplete when the goal is to verify the APK as a whole Versions 2/3 # Versions 2 and 3 are specific to Android: What is signed is the APK as a whole Uses a twist in zip format specifications The global signing block is inserted just before the zip Central Directory (and can be located by looking for a magic number) V3 = V2 + support for key rotation What is displayed in the Certificate fragment is the signer's certificate, just like V1's review the reference documentation for additional details Version 4 # The APK signature scheme version 4 scheme was introduced with Android 11 (R) to ease development of larger applications. The signature of the APK is done incrementally via a Merkle tree. The signing data is stored separately in an <APKNAME>.idsig file. Note Version 4 signatures do not seem to be designed for release purposes. At the moment, JEB does not parse idsig files. JEB parses v1/v2/v3 signing data. The certificate is displayed as a tree in the UI client: API To retrieve this data programmatically: refer to IApkUnit , methods getSignatureSchemeVersionFlags and getSignatureSchemeV{2,3}Block Manifest # AndroidManifest.xml defines the Android application to whoever interacts with it, from building, to deployment, to execution. Important parts of the Manifest: Package name (fully qualified Java name) Requirements to run the app (API level, hardware configs) Permissions required by the app (not all may be granted by the system at t0) Components must be declared in apps - except for Broadcast receivers, which can be registered dynamically Activities (UI elements) Services (background execution) Broadcast Receivers (receive and process events from apps/system) Content Providers (offer data to other apps/system) Declares whether the app is debuggable on a production device <application android:debuggable=\"false|true\" ... For example, the simple manifest below... declares a app named (internal package name) com.xyz.appcheck requiring at least and ideally API 26 (Android P) wants read+write access to storage the App is debuggable it declares one main activity (visible on launcher) as well as one implicit broadcast receiver Note Manifests can be very complex and lengthy. For example, the primary Facebook app ( com.facebook.katana ) manifest is well over 2000 lines, mostly Activity descriptions. About Permissions # Permissions provide an indirect insight into what \"functions\" an app needs to perform. They are granted by the user at install and/or runtime: Before API 23, permissions were all granted at install time. A pop-up would display which dangerous permission groups are being requested. With API levels 23+, permissions are granular, and dangerous permissions are granted at run-time unless the Manifest declares targetSdk<23 ! the user will be shown a system pop-up permissions can also be revoked in settings Permissions - whether related code requiring them is used, whether they are granted explicitly or implicitly -, MUST all be declared in the Manifest , i.e. an app cannot programmatically request a permission that was not declared in the Manifest in the first place. Structured Resources # Structured resources of an app consist of XML files (e.g., app layouts, strings, etc.), image files, icons, etc. XML resources are encoded using a binary format called arsc . The manifest, an XML resource, is encoded as well. Common resources\u2019 information goes into the app resources.arsc file Resources references resources.arsc items by id They can also reference Android Framework and other vendor-installed framework resources by id (refer to the section 'Third-party Frameworks') JEB always ships with the latest official Android Framework Note For additional information on Resources: high-level information can be found in the official doc lower-level details of the arsc format can be found by going through the main implementation of the encoder and decoder, on the AOSP's platform/frameworks/base repository. The newest ResourceTypes.h is located here . Oddities and Obfuscation # Resources on Android can be mangled in several ways. JEB unmangles them to the best of its ability. Below, we briefly describe two commonly found obfuscation techniques. Name removal # Resource items are normally identified by a name as well as an id. Several application protectors remove resource names from the compiled resources.arsc file when they reference well-known framework resources. E.g., the manifest below had resource names removed. Note that most XML attribute names are missing. <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" := \"1.1\" android:versionCode= \"2\" platformBuildVersionName= \"6.0-5078647\" platformBuildVersionCode= \"23\" package= \"com.virginoff.player\" > <uses-sdk := \"7\" := \"23\" /> <uses-permission := \"android.permission.ACCESS_NETWORK_STATE\" /> <uses-permission := \"android.permission.SEND_SMS\" /> <uses-permission := \"android.permission.INTERNET\" /> <uses-permission := \"android.permission.WRITE_EXTERNAL_STORAGE\" /> <uses-permission := \"android.permission.WAKE_LOCK\" /> <application := \"@style/Theme.NoTitleBar.Fullscreen\" := \"Anal Sex Video\" := \"@drawable/ic_launcher\" := \".Application\" := \"false\" > <activity := \".activity.WrapperActivity\" := \"true\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> <activity := \"o.\u03df\" := \"0\" := \"a0\" /> <activity := \"o.\u022d\" := \"0\" := \"a0\" /> <service := \"o.\u0182\" /> </application> </manifest> Dump the manifest using aapt to see the actual ids: $ aapt dump xmltree 1 .apk AndroidManifest.xml N: android = http://schemas.android.com/apk/res/android E: manifest ( line = 0 ) A: : ( 0x0101021c )= \"1.1\" ( Raw: \"1.1\" ) A: android:versionCode ( 0x0101021b )=( type 0x10 ) 0x2 A: platformBuildVersionName = \"6.0-5078647\" ( Raw: \"6.0-5078647\" ) A: platformBuildVersionCode =( type 0x10 ) 0x17 A: package = \"com.virginoff.player\" ( Raw: \"com.virginoff.player\" ) E: uses-sdk ( line = 0 ) A: : ( 0x0101020c )=( type 0x10 ) 0x7 A: : ( 0x01010270 )=( type 0x10 ) 0x17 E: uses-permission ( line = 0 ) A: : ( 0x01010003 )= \"android.permission.ACCESS_NETWORK_STATE\" ( Raw: \"android.permission.ACCESS_NETWORK_STATE\" ) ... Above, we can see that the uses-permission tag, for example, specifies the use of an attribute whose id is 0x01010003. Attributes of an Android Manifest are well-known resources and stored as such in the Android framework. You can use aapt on the Android framework file to see them: $ aapt dump --values resources ~/.jeb-android-frameworks/1.apk Package Groups (1) Package Group 0 id=0x01 packageCount=1 name=android Package 0 id=0x01 name=android type 0 configCount=1 entryCount=1543 spec resource 0x01010000 android:attr/theme: flags=0x40000000 spec resource 0x01010001 android:attr/label: flags=0x40000000 spec resource 0x01010002 android:attr/icon: flags=0x40000000 ---> spec resource 0x01010003 android:attr/name: flags=0x40000000 spec resource 0x01010004 android:attr/manageSpaceActivity: flags=0x40000000 spec resource 0x01010005 android:attr/allowClearUserData: flags=0x40000000 ... So, that tag could be restored to: <uses-permission name= \"android.permission.ACCESS_NETWORK_STATE\" /> Note The Android framework contains all base system resources for a given version of Android - it is located in the /system/framework/framework-res.apk (resources only) on a device, or the platforms/<APILEVEL>/android.jar in the Android SDK. JEB also drops the latest stable framework to your home folder's jeb-android-frameworks/1.apk The above process is automated by JEB to restore XML files to a human-readable states. Flattened hierarchy # Although most structured resources (with the notable exception of the Manifest) are typically stored hierarchically under the res folder, they do not have to be. Some application protectors take advantage of this fact to flatten the resources tree, and for example, store them in the APK's root folder. E.g., in the file below (a protected online banking app), most resource files were renamed to mangled names and stored alongside the Manifest; the res/ folder is present and contains only a handful of resources. JEB restores both the hierarchy and names of those resource files. Decoding problems # Other oddities exist, they can be found in apps stretching the limits of the arsc format specifications to their boundaries. They can be used, voluntarily or not, to thwart and crash various open-source tools. We won't detail them here, but you can find additional information here and there on our blog as well as the Apktool's GitHub issue tracker , a prime source to find weird parsing cases. As an example, here is aapt2 (version around spring 2019) failing on version 153 of the Facebook app: $ aapt2 dump Facebook_v153.0.0.54.88.apk error: trying to add resource 'com.facebook.katana:id/(name removed)' with ID 0x7f090001 but resource already has ID 0x7f090000. Assets # Assets are unstructured resources. They can be of any type and stored anywhere in the APK archive. However, the assets/ directory is standard, and used by the Android AssetManager object. Assets stored in the Resources folder res/raw are stored as-is (in particular, XML files are not encoded), and yet, are accessible in code by id, using the R class, just like any other standard resource. The asset file below, edd.bin , is holding encrypted data Native Code # Android applications often contain native code, compiled as ELF library .so files. They can be located anywhere in the app. SO files can be loaded from bytecode via System.loadLibrary(simpleName) and System.load(path) . A common location for SO files is the app's lib/ folder. Libraries stored in this folder and adhering to the JNI naming convention allow the Android system to unpack appropriate SO to the device folder /data/data/<app>/lib , and make it easier for high-level code to load them, i.e. there is no need to implement the logic of figuring out which underlying platform the device is running on. Location: [APK]/lib/<abi>/lib<name>.so Example: high-level request System.loadLibrary(\"native-lib\") on an aarch64 device => lib/arm64-v8a/libnative-lib.so on a Pixel phone with an Arm64 CPU Info For more information on native code analysis, debugging and decompilation, refer to the manual pages relative to native code . Bytecode # Refer to the DEX sub-section below . Dex Bytecode # Dex (or DEX , throughout this section), short for Dalvik Executable , is an object container for Dalvik code. It is Android's equivalent of ELF, PE, COFF, etc. containers for native code. The primary dex file of an app is named classes.dex , located in the app's root folder. (This file is present in the vast majority of apps, although it is optional: apps can be purely native.) DEX splitting # Additional DEX files may be present: classes2.dex , classes3.dex , etc. The reason behind code splitting is a Dalvik VM legacy limitation called the \"64K reference limit\": many items present in a DEX file are referenced by an id stored on a 16-bit integer, e.g. it is the case for methods and fields references. To overcome the limitation, compilers such as d8 (or its predecessor dx ) split the code over additional DEX files classesN.dex , where N>=2. Additional references are created to reference definitions located in other DEX files. JEB merges all classesN.dex in a single, virtual DEX unit. Note that in practice, such DEX units could not be converted back to a single DEX file. Also keep in mind that apps may artificially split their code over multiple DEX files; the 64Krefs limit is not a hard requirement. This app was split over 7 dex files: Warning On pre-API 21 (Android 5) systems, it is the responsibility of the app to load additional files - i.e., the DEX splitting mechanism is not something baked into the Dalvik VM itself. Apps can extend the support class MultiDexApplication to avoid implementing their own DEX loader, as the vast majority of the apps do. However, keep in mind that this is in no way mandatory. Malware files or protected files can implement multi-dex loading facility however they see fit. On API 21 and above, with the advent of the new Android ART runtime, files named classesN.dex are scanned and pre-compiled along with classes.dex . However, this mechanism does not preclude apps to use additional DEX loading facility as well. DEX execution # There are two general types of dex files: regular dex files contain generic code, use standard Dalvik instructions, meant to run on all Android devices odex files, on the other hand - a generic term for \"optimized DEX\" - contain device specific instructions. Optimized dex (odex) # The DEX file(s) located in your app is not the code executed on device - except when debugging. DEX code is executed by a runtime: The legacy runtime (pre-API 21 Lollipop) uses a JIT (just-in-time) compiler and generate odex files on first run. The current runtime is named ART (short for Android Runtime ) and makes use of AOT (ahead-of-time) compilation of Dalvik to native (x86 or ARM) at install time Note The format of optimized DEX files has evolved over time (\"dey\" magic, OAT files with DEX or DEX-like entries, VDEX and CDEX, etc.). The process of reconstructing a DEX from an optimized-DEX is systematic and implemented in several tools, such as baksmali deodex or vdexExtractor . Refer to additional references, such as Lief's notes on OAT and ART , for more information on odex. Link: List of odex instructions . DEX format # This section quickly summarizes important facts about the DEX format. Refer to the official specifications for additional details: DEX format Bytecode format List of instructions . Structure of a DEX file The format can be linearly represented as: In Header: DEX magic, DEX version: dex\\n0NN\\0 where NN= 35: up to Android 7- 37: Android 7, invoke-virtual and invoke-super accept interface methods ids (support for Java 8's default methods) 38: Android 8, added invoke-polymorphic , invoke-custom , call sites and method handles entries ( details ) 39: Android 9, added const-method-handle , const-method-type ( details ) Tables are ordered alphabetically and do not allow duplicates Note that the map section was purely redundant until DEX 38 and the introduction of method handles and call sites. The three links above cannot be overlooked: any Android reverser should strive for Dex and Dalvik proficiency. That being said, below is a list of lesser-known or overlooked details about about Dalvik: Strings are encoded using a variant of CESU-8 called MUTF-8 (modified UTF-8) 1- 2- 3-byte encoding (whereas UTF-8 allows up to 4-byte) Surrogates: 2x3-byte for chars \\u010000 to \\u10FFFF (whereas canonical representations of UTF-8 does not use surrogates; UTF-16 does) \\u0000 is encoded as \\x00\\x00 (whereas UTF-8 uses \\x00) Special byte \\x00 indicates string end (there is no EOS concept with UTF-X) Some 32-bit integers are encoded using the variable encoding scheme LEB128 and its variants Types use Strings: type definition= index into string pool Prototypes use Strings and Types Shorty definition= index into string pool Full prototype definition = list of indices into type pool The Dalvik bytecode is stored in Code items Call Sites and Method Handles were introduced in DEX 38 The DEX header remained unchanged and does not directly reference those pools; instead, they are referenced in the Map area (which largely remained unused until those items were introduced) Learn more about DEX 38 on our blog Dalvik # Dalvik is the name of the low-level bytecode stored in DEX files. Dalvik bytecode is interpreted by a Virtual Machine (DVM). Generation: Source language: smali (low-level), Java (high-level), Kotlin (very high-level) Java -> javac -> classfiles (Java bytecode) -> dx/d8 -> classes.dex (Dalvik bc) Characteristics: Register-based machine: 65,536 32-bit registers, numbered v0 to v65535 65,535 64-bit registers, \"emulated\" by using consecutive 32-bit registers [v0,v1], [v1,v2], ..., [vN,vN+1] No \"special\" register is accessible: no flag register, no PC register, no current-frame register, etc. Fixed frames (stack is N/A, no stack pointer), size declared in Code items Pointer= object reference ~= fits on a single register (32-bit) Regular instructions range from 2 to 10 bytes (=1 to 5 words) Instruction opcode encoded on a single byte; the second byte of the first word is generally used to encode register indices nop (1w), const-wide v1, 0x1122334455667788L (5w) The generally accepted convention is to represent Dalvik disassembly in smali or a variant of smali. By default, JEB uses a variant of Smali, slightly less verbose (more readable and better suited to be displayed and manipulated in an interactive UI). Method bodies live in isolation, the concept of \"jump far\" (unstructured dispatch) does not exist. Dispatching execution to other methods is done via invoke-xxx instructions only Jumps are always relative to the current PC Retrieving the returned value of a function is done via a move-result-xxx instruction, located right after the invoke-xxx instruction Arithmetic instructions have no side-effects / there is no flag register Data in bytecode is legal: Immediates: Some instructions store literals inline (i.e., within the instruction code), e.g. const-xxx N-way branching instruction: switch-xxx : the jump table is stored within the bytecode Small array initialization: fill-array-data : array data is stored within the bytecode. (Note that array data payload may be used by more than one fill-array-data instruction.) Calling convention # The DVM runs managed code and uses a \"no side effect, no cleaning\" calling convention: every function gets a clean register slate upon execution; the parameters are stored at the bottom of the declared frame. Registers are 32-bit wide and noted vX , 0-indexed. The alternate notation pX is used to address registers used to store input method parameters: its indexing start from frame_size - input_slot_counts . Example 1: Method: void foo(int a, char b, bool c, Object d) The CodeItem declares a frame of size 5 v0 v1 <- parameter 0: p0 (a) v2 <- parameter 1: p1 (b) v3 <- parameter 2: p2 (c) v4 <- parameter 3: p3 (d) ------- end of method frame v5 v6 ... v65535 Example 2: Method: void bar(double a, long b, float c) The CodeItem declares a frame of size 8 v0 v1 v2 v3 <- parameter 0: p0 (a) v4 <- parameter 1: p1 (b, lower part) v5 <- parameter 1: p2 (b, higher part) v6 <- parameter 2: p3 (c, lower part) v7 <- parameter 2: p4 (c, higher part) ------- end of method frame v8 v9 ... v65535 The default settings instruct JEB to use the pX notation when rendering parameter registers: It can be disabled (DEX plugin option, also controlled in the UI by right-clicking, Rendering Properties , untick 'Use p for parameters') Smali and variants # The JEB notation is made possible because of the interactivity layer (as opposed to deadcode listing). Two notable differences: For readability, the names are simple names, no longer fully-qualified Invoke opcodes place the arguments after the method: invoke-xxx callsite, args instead of invoke-xxx {args}, fully_qualified_callsite Below, the default assembly code representation used by JEB (smali variant): Official smali code can be generated (it is useful if code needs to be exported, and later on compiled using smali.jar): Application components # The application and its main components (activities, broadcast receivers, services, content providers) must be declared in the Manifest, even if they are not meant to be exported (i.e., the external attribute is set to false). Warning There is one exception: broadcast receivers can be registered dynamically, via one of the Context.registerReceiver() methods. The name attribute of a component is the name of the corresponding class that will be instantiated and whose methods are to be called back by the Android system (for exported components). Example: the Manifest below declares an Activity class com.xyz.appcheck.AppCheck , among other components. Entry points # The exported components of an APK can be equated to the entry-points of the application. Therefore, unlike types of executable programs, an Android application can have multiple entry-points. The true entry-point of a non-native application is the application's static initializer ( Application.<clinit> ). If the application being analyzed declares its own Application class in the manifest (instead of reusing android.app.Application), then that class's static initializer, if any, should be looked at first, followed by the constructors. Similarly, the static initializers and constructors of activities, receivers, services and providers are also entry-points. Finally, all API-defined callback methods of those five components can be called back by the system. Typically, the main activity's onCreate() method is the practical entry-point to an application, akin to a regular program's main() routine. Note JEB's disassembly view recaps the most important features of the APK at the top of the code listing. The important components, in particular any custom Application object, will be mentioned there: Activities # Activities are activated by Intent . Exported activities (by default, any unfiltered activity is exported) are first-class entry-points. The following methods should be carefully examined: constructor (although the object state is uncertain) well-known callbacks, e.g. attachBaseContext (used to set up a delegate Activity), onCreate , onResume , etc. Pseudo activities # Be mindful of activity aliases. They are not true components, however, they can and will override their target component's characteristics, such as intent filters. Services # Services are activated by Intent . Services are started by Activity code or Receiver code (after receiving a particular event). Most won't be easily started by the user, except for a few of them, such as Input services. Therefore, they should not be considered first-class entry-points from the point of view of code analysis. Broadcast Receivers # Broadcast receivers are activated by Intent . The intent handler for ACTION_BOOT_COMPLETED is a common entry-point, commonly used by malicious code as a way to automatically start after the phone has booted up. Many more exist though (e.g., battery plugged, message received, phone lifted, etc.) Caveats: API 21+ (Lollipop) - need a wake lock API 26+ (Oreo) - need a JobIntentService Content Providers # Content providers are activated by ContentResolver . Intents # Intents are the primary method for inter-process and inter-app communication. Other IPC means exist, e.g. sockets, files, etc. Intents are used to activate components, e.g. start an activity. Reference Dalvik and Disassembly # Plugins generate IUnit objects. Units can generate documents abiding to a standard interface, making them easy to render by clients implementing the JEB API. The primary document generated by an IDexUnit is a text document representing the disassembly of the input DEX files - or merged DEX files. Auto dex merging # Merging is done automatically, regardless of index limitations in place that may have required dex-splitting in the first place. In rare cases, you may want to disable merging. Upon loading an APK, several APK plugin options will be presented to you. Untick Merge multi-dex to disable auto-merging: DEX parsing options # DEX plugin options are accessible in the Engines options UI panel. Filter on \"dex.\" to list them. The user will also be presented a Processing Properties dialog box when opening a new file, giving the user a chance to adjust the default options stored in your jeb-engines.cfg files. Addressing # All addresses to types, methods and fields uses the canonical JVM notation, e.g.: type Blah in package com.abc: Lcom/abc/Blah; method foo(int):void in the type com.abc.Blah: Lcom/abc/Blah;->foo(I)V field name:String in the type com.abc.Blah: Lcom/abc/Blah;->name:Ljava/lang/String JEB extends the method notation to reference code locations via a suffix +OFFSET . Reference the instruction at offset 0x20 in the internal method foo(): Lcom/abc/Blah;->foo(I)V+20h Types Naming Conventions # Historically, addressing in Java can be quite confusing. There exists three types of notations: The JVM notation (canonical representation) is the one used by DEX's TypeDescriptors , e.g. Ljava/lang/Object; . JEB's DEX plugins use and provide JVM canonical names. Two JLS notations : binary form, uses dots to separate package names, e.g.: java.lang.Object internal binary (or just, 'internal') uses slashes, e.g.: java/lang/Object The java.lang.Class API uses inconsistent representations, mostly the binary form. Android plugins use the JVM notation internally and externally (public API). Example: to reference a method void foo(String) in package a.b.c , its JVM address should be provided: La/b/c;->foo(Ljava/lang/String;)V . API methods using DEX addresses expect canonical addresses. The graphical client is less strict: although it expects canonical addresses by default as well, fall-back mechanisms are implemented to determine which address the user may have intended to use, and attempt to see if it's a match. See our Reference Document. Disassembly # The default output uses modified smali (as explained in the previous section). TODO This section is a work-in-progress. Renaming and Refactoring # The DEX plugin provides smart renaming capabilities: renaming of items is done consistently throughout the code base. Most internal items can be renamed (internal items are those defined in the DEX, as opposed to external items, simply referenced in the DEX, but whose definition is located elsewhere). What can be renamed: class names (as well as interfaces and enums defined in the DEX) method names field names labels (addresses) package names variables (in decompiled units) In the UI client, Renaming can be done via the Action menu. Renaming Methods # Proper refactoring is especially important when renaming non-static methods (virtual methods, interface methods) which may be part of a hierarchy of other methods, overridden parents or overriding children. Example: renaming B:a() should also rename A.a() and C.a() A.a():Object | B.a():String | C.a():String Renaming must also take into account indirect references to methods, something common when invoking virtual methods located in other classes, but which can be used to obfuscate a program further. A.a() | B.a() - within B: invoke-virtual A.a() -> actually refers to B.a() Things can get relatively complicated when hierarchies involve multiple inheritance through one or more interfaces. Renaming Fields # To some degree, the same applies to fields. Unlike methods, fields cannot be overridden; they are always accessed in a direct way, i.e. resolution is entirely determined at compile-time. However, field masking adds complications. A.i:int public | B.i:int public - this field masks A.i Shall a rename action of A.i also rename B.i? Conversely, shall renaming B.i also rename A.i? Theoretically, no. Those two fields are not related. However, at the moment, the DEX plugin renames both fields to maintain some degree of visual consistency with the original binary, regardless of whether field masking was done voluntarily or not, with obfuscating intent or not. This is likely to change with the addition of an option to let users decide how they want to perform renaming. Reorganizing code # Packages can also be renamed. Users can also create additional packages and move packages and classes to other packages. This feature can come in handy when dealing with obfuscated code for which entire type hierarchies were flattened out into a handful (sometimes single) set of packages. Most obfuscators, including the ubiquitous Proguard and its now equivalent r8, can do that. If you want to explore refactoring further, in particular hierarchy reconstruction, have a look at our sample script DexCluster.py . Forcing inner classes # Classes can be moved inside other classes or methods. Whenever it is deemed possible, a class moved inside a method will be made anonymous. This process of anonymizing classes is an efficient way to defeat name-based obfuscation and annotation-scrapping-based obfuscation, that usually prevent the reconstruction of inner classes in general, and anonymous classes in particular. While drag&dropping in the GUI is an option for targeted refactoring, scripting is always preferable for bulk operations. Refer to IDexUnit.moveTo() in the API doc. Auto-rename # Auto-renaming is an optional standard Action also implemented by the DEX plugin. As its name implies, it can perform automatic blanket renaming of all items of a unit. In the case of DEX units, they include types, methods, fields, etc. The action is semi-customizable by each plugin, as can be seen in the API . In the case of the DEX plugin, three policies are implemented. Each policy defines a set of legal characters for items. The loosest policy permits all characters in the printable ascii range (something already relatively strict considering the actual legal character ranges for Java identifiers); the strictest considers all current names (except those that were already defined) invalid, and therefore, will rename everything. The obfuscation applied below is using right-to-left unicode characters to complicate rendering: After auto-renaming (standard policy): Cross-references in Dalvik # Refer to the generic xrefs section of the manual. Decompilation to Java # Note Make sure to read the generic Decompilation section of the manual. Decompiling classes # By default, the Decompile action in the UI menu triggers the decompilation of an entire class and its constituents (fields, methods, member classes, etc.). Fresh decompilation: With the current options set up in your Engines context: Use Action, Decompile or press the Tab key . With custom options: use Action, Decompile with Options or press the CMD1+Tab . Re-decompile (e.g., after changing options) Execute a \"Decompile with Options\" action as described above. The current decompilation of the class, if it existed, will be discarded, and a new decompilation will take place. To decompile a single item (e.g. a single method), perform a \"Decompile with options\" action and untick the \"Decompile top-level container class\". Generic decryption and deobfuscation # The decompiler attempts to automatically performs data decryption and code unreflection. This process is done automatically by several method optimizers managed by the decompiler, with the help of code emulation in a built-in sandbox. Sample malware code decompilation: light-blue methods have been unreflected; Purple strings are the result of generic decryptions While the emulator and sandbox are currently not available in the IR API offered by dexdec , a few key parameters of the emulator can be customized via the coreplugins/dexdec-emu.cfg file. Copy the file dexdec-emu.cfg.TEMPLATE to dexdec-emu.cfg Edit dexdec-emu.cfg The changes will take effect at the next decompilation Currently, the configuration file allows users to specify: maximum emulation times emulation policy for external methods (by groups, restricted lists, whitelists, and blacklists - e.g., a user can forbid the emulation of any time/date-related method) Note Data decryption combined with unreflection yields very effective results against most classes of Dalvik obfuscators. You will find examples of this on our blog . Java 18+ The dexdec sandbox relies Java's SecurityManager , a standard JDK component that is deprecated in Java 18, and will be removed in future releases of Java. If you must use JDK 18+, a temporary workaround is to pass -Djava.security.manager=allow on the command line when starting JEB (e.g. $ java -Djava.security.manager=allow -jar bin/app/jebc.jar ). Ideally, we recommend using JDK 11 or JDK 17, until we have a replacement in place for this component. CF Unflattening # Control-flow flattening is an advanced code protection technique used to \"de-structure\" a method. A flattened method consists of a dispatcher, reading a virtual program counter, tasked to dispatch the execution to a next group of instructions; those instructions will perform some of the original method's work, as well as update the virtual program counter and loop back to the dispatcher. In effect, protected methods appear like overly large switch statements. The original structures (loops, inner loops, conditionals, inner conditionals, etc.) are gone; the method appears to be flat. JEB attempts to detect and restructure such methods. CF unflattening relies on many heuristics and has limitations. It is not a bullet-proof optimizer. If you encounter problems, you may disable that obfuscator in the options, and/or report the problem. Unvirtualization # Code virtualization is one of the most advanced code protection technique currently available in protection software. JEB attempts to \"de-virtualize\" (regenerate and decompile) virtualized methods. Please refer to this blog post for additional details: Reversing DexGuard, Part 3 - Code Virtualization . Virtualized method (left), and the resulting unvirtualized output (right) Exceptional control flow # The decompilation of code protected in try blocks ( try/catch+/finally? ) is enabled by default. However, reconstruction of try-with-resources (also known as ARM , for Automatic Resource Management ) is more limited. This very-high level Java construct translates into complicated, lengthy, compiler-generated optimized code. Note Better support for try-with-resources reconstruction is a planned addition. Recovering enums # Enumerations in Java are high-level constructs that translate into multiple classes and synthetic methods. JEB attempts to discover and re-sugar those enumeration artifacts into the original enum. On failure, regular classes extending java.lang.Enum will be generated. Note Enum reconstruction can be disabled in the Options. Enums are great candidates for obfuscation, and most Android protectors do obfuscate them. That process destroys important synthetic fields and structures that would allow simple recovery heuristics to work. However, support should function reasonably well, even on enumeration data that was intentionally shuffled to generate decompilation errors. Note that enumerated fields can be renamed . Renaming is done consistently over the code base, including over reconstructed switches making use of such enums. Decompiled enums in android.arch.lifecycle . Renaming and cross-referencing enumerated constants is supported. Custom enumerated constants should also be properly reconstructed, including: Field annotations Custom initializers (see below) Additional methods and method overrides In this complex enumeration, the red block shows a custom initializer. Other interesting bits are the use of overrides and custom methods, annotations, as well as default and non-default constructors. Recovering switches # The detection and reconstruction of switch-on-enum and switch-on-string is supported. Reconstruction of switch-on-string can be very complicated depending on how the compiler has generated and optimized the code, and therefore, is limited to simple cases. This successfully reconstructed switch-on-string is implemented as a double-switch idiom by dx (a sparse switch on hashCode/equals to generate custom indices i, followed by a packed-switch on i). Not all switches are implemented like this. Regular if-conditional trees may be strategically generated by optimizing compilers. Note Better support for switch-on-string reconstruction is a planned addition. Member classes and arguments capturing # Properly rendering non-trivial member classes (particularly non-static named classes or anonymous classes) is made difficult by the fact that some of their arguments are captured from the outer class(es). Properly rendering anonymous constructors, with exact argument types and position, is also challenging. In the example below, an anonymous class initializer is used to hide string decryption code: The anonymous class extends Android\u2019s OnActivityResultListener, instantiates the object, and tosses it immediately. Decryption code takes place in the initializer. Note the captured arguments from the outer container method __m : i , _b . Access to other private class fields is made via synthetic accessor calls that were re-sugared into seemingly direct field access ( BA._b ). Pseudo-moot anonymous class with an instance initializer attempting to conceal string decryption code. Lambdas generation # By default, JEB will try to recover and reconstruct lambdas . Desugared Lambdas # Recovery and reconstruction does not rely on any type of metadata 1, such as special prefixes -$$Lambda$ for classes and methods implementing desugared lambdas in dex 37-. You may therefore see constructs like this: This DEX file contains desugared, non-obfuscated lambdas. This DEX file contained desugared, obfuscated lambdas API In the above cases, the underlying Java AST may be a IJavaNew or IJavaStaticField node. This is not the case for real (not desugared) lambdas. They will map to an IJavaCall node. Lambda reconstruction can be disabled in the options. Lambda rendering can also be disabled in the options, as well as on-demand by right-clicking a decompiled view, Rendering Options . Lambdas options Real Lambdas # Lambda reconstruction also takes place when the code has not been desugared (which is rare!), i.e. code relying on dex38\u2019s invoke-custom and invoke-polymorphic . This DEX file contains real lambdas implemented via invoke-custom API Such lambdas map to an IJavaCall node for which isLambdaCall() will return true. Dynamic invocation opcodes # The translation of invoke-custom whose bootstrap method is LambdaMetafactory.metafactory(...) allows the decompiler to generate proper Java code with lambda constructs. However, this is just one (albeit one of the most important) cases of dynamic dispatch. invoke-custom and related opcodes ( const-method-handle , const-method-type ) cannot be as \"easily\" translated into intermediate representations - and later on, AST. For that reason, those opcodes are translated to regular invocation to artificial methods. Artificial classes in jeb.synthetic # Classes in the jeb.synthetic package are generated automatically by the DEX decompiler: InvokeCustoms contains static methods representing dynamic dispatch to a method handle's callsite done via an invoke-custom opcode: jeb.synthetic.InvokeCustoms.CallSite<INDEX>_<DynamicName>(DynamicPrototype) PooledMethodHandles contains static getters of method handles stored in a DEX pool and retrieved via a const-method-handle opcode: jeb.synthetic.PooledMethodHandles.Entry<INDEX>_<MethodName|FieldName>() : java.lang.invoke.MethodHandle PooledMethodTypes contains static getters of method types stored in a DEX pool and retrieved via a const-method-type opcode: jeb.synthetic.PooledMethodTypes.Entry<INDEX>() : java.lang.invoke.MethodType Decompiling Java Bytecode # JEB supports JLS bytecode decompilation for *.class files and *.jar -like archives ( jar , war , ear , etc.). The Java bytecode is converted to Dalvik using Android's dx by default. It falls-back to using d8 if a problem occurred. Users may choose to use d8 first instead by selecting so in the Options. The resulting DEX file(s) are processed as usual. You may use this to decompile Android Library files ( *.aar files) in JEB. Examining the android-arch-core-runtime library Debugging Apps # Refer to the next section, Android Debugging . Miscellaneous # Bulk decompilation and Export # Bulk decompilation and export to *.java files on disk can be done in the UI client via the menu command File, Export, DEX Fast Decompilation . You may also provide a regular expression filter if you'd like to restrict decompilation to a package and its sub-packages, e.g. com\\.xyz\\..* will decompile all classes in com.xyz and its sub-packages. Refer to this note for generic details on exporting output. Callgraph fragment # The callgraph fragment is not specific to Android (most code analysis can ask to generate one). It is an experimental feature designed to represent trimmed callgraphs of the most important routines and most important invocations between those routines. The fragment is located in the lower right-hand corner of a standard workspace. The callgraph is not generated by default: Empty callgraph Click on the fragment to generate it. The navigation shortcuts are similar to those used in the CFG fragment ('\\' to center, '[' and ']' or zoom in and out, etc.). Click a node to set the focus on the associated routine and their connections. Double-click a node to jump to that routine in the disassembly listing. A generated callgraph Displaying synthetic items # How to always display synthetic fields and methods in decompiled views? In the vast majority of the cases, synthetic accessors used by inner classes need not be displayed as they are re-optimized into direct, seamless outer class field access or method invocation. However, if you wish to display them: In a decompiled view, right-click, \"Rendering Options\" and tick the boxes \"Generate synthetic fields\" and \"Generate synthetic methods\". You may also change this setting once and for all in the Engines option (Edit, Options, Engines). Example: forcing rendering of Synthetic Fields Third-party Frameworks # When analyzing applications using resources located in other frameworks that the Android Framework (e.g. the Samsung framework), follow those steps: Retrieve the custom framework archive using apt pull . It is normally stored somewhere in the device's /system/framework/ folder. Let's call it framework.zip. Run aapt2 dump framework.zip and retrieve the first line, which will be something like Package name=xxxxxxx id=N . Note the id, N . Navigate to the folder listed in your .parsers.apk.FrameworksDirectory engines property. Typically, it will be the HOME_FOLDER/.jeb-android-frameworks folder Copy framework.zip into this folder, and rename it to N.zip JEB should now be able to pick up that framework and use its resources when needed Note 1.zip in the FrameworksDirectory folder is the Android framework itself, which has id 1.","title":"Android Analysis"},{"location":"android.html#plugins","text":"The plugins used to analyze Android apps consist of: The APK plugin is responsible for processing APK files. Encoded resources (arsc) are decoded by this plugin. Other jobs, such as analyzing dex files, analyzing certificates, processing asset files, analyzing binary files, etc. are delegated to appropriate plugins. The DEX plugins: DEX analyzer (DEX parsing and merging, Dalvik disassembling, etc.), DEX decompiler, DEX debuggers. Native code analyzers: disassemblers, decompilers, etc. A handful of other plugins, such as Certificate parsers, XML/HTML/JSON/etc. parsers. This section mostly focuses on the APK plugin and the DEX analyzer. Other plugins are documented in separate sections of this manual.","title":"Plugins"},{"location":"android.html#technical-blogs","text":"Our blog is filled with technical posts that will help you make the most of JEB. It is the ideal companion to this manual. Link: All PNF Software blog posts tagged Android.","title":"Technical Blogs"},{"location":"android.html#api-levels","text":"API levels are regularly mentioned throughout this document. Here is a list of \"recent\" Android versions, their corresponding API levels, as well as notable changes regarding security. Codename Version API level Date New security features Tiramisu 13 32 2022 TBD S 12 31 2021 Privacy dashboard, Private Compute Core, approximate location, a/v indicators R 11 30 2020 Privacy updates, APK Signature Scheme v4 Q 10 29 2019 Permissions for privacy, BiometricPrompt Pie 9 28 2018 ART: Vdex with Cdex, AS-FBE, biometric API, lockdown mode, APK Signature Scheme v3 Oreo 8, 8.1 26, 27 2017 ART: OAT with Vdex (oat w/o dex, separate vdex with dex'es), Google Play Protect Nougat 7, 7.1 24, 25 2016 APK Signature Scheme v2, File Based Encryption (FBE - and consequently, DirectBoot), AS-FDE, Android Things Marshmallow 6 23 2015 Adoptable Storage (AS), granular permissions and permission levels (NORMAL, DANGEROUS), Doze & App Standby, Android Wear Lollipop 5, 5.1 21, 22 2014 ART: OAT with dex'es in .rodata, 64-bit support (x86_64, arm64-v8a), Android Auto KitKat 4.4, 4.4W 19, 20 2013 ART (optional), VerifiedBoot, Full Disk Encryption (FDE) Jelly Bean 4.1, 4.2, 4.3 16, 17, 18 2012 SELinux introduction, multi-users Android Versions Reference","title":"API Levels"},{"location":"android.html#apk-structure","text":"This section is a short primer on the Android Package file (APK). It is assumed that the reader is already familiar with the structure of an APK. Good introduction material can be found on the official Android developer portal . An Android app is a zip file containing application code, data, and metadata. Code: Dalvik (bytecode), Native (*.so libs) Data: resources (structured), assets (unstructured) Metadata= manifest (what), certificates (who) When JEB processes an APK, the resulting structure in the Project tree will differ from a raw ZIP tree view. The range of differences goes from slightly for regular apps, to significantly for obfuscated or complex apps. The picture below shows a side-by-side comparison of processing an app as a ZIP file vs processing it as an APK: Manifest: encoded VS decoded Certificates: v1 (visible, in file MANIFEST.MF), v2/v3 (in ZIP) VS parsed certificates Bytecode: split over classes.dex, classes1.dex, ..., classesN.dex VS virtual merged DEX unit Resources: encoded and scattered in resources.arsc, res/, elsewhere (anywhere) VS decoded and reorganized resources Native libs: 1-to-1 Assets: 1-to-1","title":"APK Structure"},{"location":"android.html#certificates","text":"As of Android 11, four types of signatures are in place to sign APKs, versions 1 through 4.","title":"Certificates"},{"location":"android.html#version-1","text":"Version 1 is the legacy scheme supported by all versions of Android: standard Jar signing (Oracle) signing data goes in META-INF/ each individual file in the archive is signed MANIFEST.MF: list of hashes of all files xxx.SF: hash of hash entries in MANIFEST.MF xxx.{RSA,DSA,...}: signature of xxx.SF + signer certificate (= what JEB displays) note that xxx='CERT', usually The apk/zip itself is not signed: this scheme is both inefficient and incomplete when the goal is to verify the APK as a whole","title":"Version 1"},{"location":"android.html#versions-23","text":"Versions 2 and 3 are specific to Android: What is signed is the APK as a whole Uses a twist in zip format specifications The global signing block is inserted just before the zip Central Directory (and can be located by looking for a magic number) V3 = V2 + support for key rotation What is displayed in the Certificate fragment is the signer's certificate, just like V1's review the reference documentation for additional details","title":"Versions 2/3"},{"location":"android.html#version-4","text":"The APK signature scheme version 4 scheme was introduced with Android 11 (R) to ease development of larger applications. The signature of the APK is done incrementally via a Merkle tree. The signing data is stored separately in an <APKNAME>.idsig file. Note Version 4 signatures do not seem to be designed for release purposes. At the moment, JEB does not parse idsig files. JEB parses v1/v2/v3 signing data. The certificate is displayed as a tree in the UI client: API To retrieve this data programmatically: refer to IApkUnit , methods getSignatureSchemeVersionFlags and getSignatureSchemeV{2,3}Block","title":"Version 4"},{"location":"android.html#manifest","text":"AndroidManifest.xml defines the Android application to whoever interacts with it, from building, to deployment, to execution. Important parts of the Manifest: Package name (fully qualified Java name) Requirements to run the app (API level, hardware configs) Permissions required by the app (not all may be granted by the system at t0) Components must be declared in apps - except for Broadcast receivers, which can be registered dynamically Activities (UI elements) Services (background execution) Broadcast Receivers (receive and process events from apps/system) Content Providers (offer data to other apps/system) Declares whether the app is debuggable on a production device <application android:debuggable=\"false|true\" ... For example, the simple manifest below... declares a app named (internal package name) com.xyz.appcheck requiring at least and ideally API 26 (Android P) wants read+write access to storage the App is debuggable it declares one main activity (visible on launcher) as well as one implicit broadcast receiver Note Manifests can be very complex and lengthy. For example, the primary Facebook app ( com.facebook.katana ) manifest is well over 2000 lines, mostly Activity descriptions.","title":"Manifest"},{"location":"android.html#about-permissions","text":"Permissions provide an indirect insight into what \"functions\" an app needs to perform. They are granted by the user at install and/or runtime: Before API 23, permissions were all granted at install time. A pop-up would display which dangerous permission groups are being requested. With API levels 23+, permissions are granular, and dangerous permissions are granted at run-time unless the Manifest declares targetSdk<23 ! the user will be shown a system pop-up permissions can also be revoked in settings Permissions - whether related code requiring them is used, whether they are granted explicitly or implicitly -, MUST all be declared in the Manifest , i.e. an app cannot programmatically request a permission that was not declared in the Manifest in the first place.","title":"About Permissions"},{"location":"android.html#structured-resources","text":"Structured resources of an app consist of XML files (e.g., app layouts, strings, etc.), image files, icons, etc. XML resources are encoded using a binary format called arsc . The manifest, an XML resource, is encoded as well. Common resources\u2019 information goes into the app resources.arsc file Resources references resources.arsc items by id They can also reference Android Framework and other vendor-installed framework resources by id (refer to the section 'Third-party Frameworks') JEB always ships with the latest official Android Framework Note For additional information on Resources: high-level information can be found in the official doc lower-level details of the arsc format can be found by going through the main implementation of the encoder and decoder, on the AOSP's platform/frameworks/base repository. The newest ResourceTypes.h is located here .","title":"Structured Resources"},{"location":"android.html#oddities-and-obfuscation","text":"Resources on Android can be mangled in several ways. JEB unmangles them to the best of its ability. Below, we briefly describe two commonly found obfuscation techniques.","title":"Oddities and Obfuscation"},{"location":"android.html#name-removal","text":"Resource items are normally identified by a name as well as an id. Several application protectors remove resource names from the compiled resources.arsc file when they reference well-known framework resources. E.g., the manifest below had resource names removed. Note that most XML attribute names are missing. <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" := \"1.1\" android:versionCode= \"2\" platformBuildVersionName= \"6.0-5078647\" platformBuildVersionCode= \"23\" package= \"com.virginoff.player\" > <uses-sdk := \"7\" := \"23\" /> <uses-permission := \"android.permission.ACCESS_NETWORK_STATE\" /> <uses-permission := \"android.permission.SEND_SMS\" /> <uses-permission := \"android.permission.INTERNET\" /> <uses-permission := \"android.permission.WRITE_EXTERNAL_STORAGE\" /> <uses-permission := \"android.permission.WAKE_LOCK\" /> <application := \"@style/Theme.NoTitleBar.Fullscreen\" := \"Anal Sex Video\" := \"@drawable/ic_launcher\" := \".Application\" := \"false\" > <activity := \".activity.WrapperActivity\" := \"true\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> <activity := \"o.\u03df\" := \"0\" := \"a0\" /> <activity := \"o.\u022d\" := \"0\" := \"a0\" /> <service := \"o.\u0182\" /> </application> </manifest> Dump the manifest using aapt to see the actual ids: $ aapt dump xmltree 1 .apk AndroidManifest.xml N: android = http://schemas.android.com/apk/res/android E: manifest ( line = 0 ) A: : ( 0x0101021c )= \"1.1\" ( Raw: \"1.1\" ) A: android:versionCode ( 0x0101021b )=( type 0x10 ) 0x2 A: platformBuildVersionName = \"6.0-5078647\" ( Raw: \"6.0-5078647\" ) A: platformBuildVersionCode =( type 0x10 ) 0x17 A: package = \"com.virginoff.player\" ( Raw: \"com.virginoff.player\" ) E: uses-sdk ( line = 0 ) A: : ( 0x0101020c )=( type 0x10 ) 0x7 A: : ( 0x01010270 )=( type 0x10 ) 0x17 E: uses-permission ( line = 0 ) A: : ( 0x01010003 )= \"android.permission.ACCESS_NETWORK_STATE\" ( Raw: \"android.permission.ACCESS_NETWORK_STATE\" ) ... Above, we can see that the uses-permission tag, for example, specifies the use of an attribute whose id is 0x01010003. Attributes of an Android Manifest are well-known resources and stored as such in the Android framework. You can use aapt on the Android framework file to see them: $ aapt dump --values resources ~/.jeb-android-frameworks/1.apk Package Groups (1) Package Group 0 id=0x01 packageCount=1 name=android Package 0 id=0x01 name=android type 0 configCount=1 entryCount=1543 spec resource 0x01010000 android:attr/theme: flags=0x40000000 spec resource 0x01010001 android:attr/label: flags=0x40000000 spec resource 0x01010002 android:attr/icon: flags=0x40000000 ---> spec resource 0x01010003 android:attr/name: flags=0x40000000 spec resource 0x01010004 android:attr/manageSpaceActivity: flags=0x40000000 spec resource 0x01010005 android:attr/allowClearUserData: flags=0x40000000 ... So, that tag could be restored to: <uses-permission name= \"android.permission.ACCESS_NETWORK_STATE\" /> Note The Android framework contains all base system resources for a given version of Android - it is located in the /system/framework/framework-res.apk (resources only) on a device, or the platforms/<APILEVEL>/android.jar in the Android SDK. JEB also drops the latest stable framework to your home folder's jeb-android-frameworks/1.apk The above process is automated by JEB to restore XML files to a human-readable states.","title":"Name removal"},{"location":"android.html#flattened-hierarchy","text":"Although most structured resources (with the notable exception of the Manifest) are typically stored hierarchically under the res folder, they do not have to be. Some application protectors take advantage of this fact to flatten the resources tree, and for example, store them in the APK's root folder. E.g., in the file below (a protected online banking app), most resource files were renamed to mangled names and stored alongside the Manifest; the res/ folder is present and contains only a handful of resources. JEB restores both the hierarchy and names of those resource files.","title":"Flattened hierarchy"},{"location":"android.html#decoding-problems","text":"Other oddities exist, they can be found in apps stretching the limits of the arsc format specifications to their boundaries. They can be used, voluntarily or not, to thwart and crash various open-source tools. We won't detail them here, but you can find additional information here and there on our blog as well as the Apktool's GitHub issue tracker , a prime source to find weird parsing cases. As an example, here is aapt2 (version around spring 2019) failing on version 153 of the Facebook app: $ aapt2 dump Facebook_v153.0.0.54.88.apk error: trying to add resource 'com.facebook.katana:id/(name removed)' with ID 0x7f090001 but resource already has ID 0x7f090000.","title":"Decoding problems"},{"location":"android.html#assets","text":"Assets are unstructured resources. They can be of any type and stored anywhere in the APK archive. However, the assets/ directory is standard, and used by the Android AssetManager object. Assets stored in the Resources folder res/raw are stored as-is (in particular, XML files are not encoded), and yet, are accessible in code by id, using the R class, just like any other standard resource. The asset file below, edd.bin , is holding encrypted data","title":"Assets"},{"location":"android.html#native-code","text":"Android applications often contain native code, compiled as ELF library .so files. They can be located anywhere in the app. SO files can be loaded from bytecode via System.loadLibrary(simpleName) and System.load(path) . A common location for SO files is the app's lib/ folder. Libraries stored in this folder and adhering to the JNI naming convention allow the Android system to unpack appropriate SO to the device folder /data/data/<app>/lib , and make it easier for high-level code to load them, i.e. there is no need to implement the logic of figuring out which underlying platform the device is running on. Location: [APK]/lib/<abi>/lib<name>.so Example: high-level request System.loadLibrary(\"native-lib\") on an aarch64 device => lib/arm64-v8a/libnative-lib.so on a Pixel phone with an Arm64 CPU Info For more information on native code analysis, debugging and decompilation, refer to the manual pages relative to native code .","title":"Native Code"},{"location":"android.html#bytecode","text":"Refer to the DEX sub-section below .","title":"Bytecode"},{"location":"android.html#dex-bytecode","text":"Dex (or DEX , throughout this section), short for Dalvik Executable , is an object container for Dalvik code. It is Android's equivalent of ELF, PE, COFF, etc. containers for native code. The primary dex file of an app is named classes.dex , located in the app's root folder. (This file is present in the vast majority of apps, although it is optional: apps can be purely native.)","title":"Dex Bytecode"},{"location":"android.html#dex-splitting","text":"Additional DEX files may be present: classes2.dex , classes3.dex , etc. The reason behind code splitting is a Dalvik VM legacy limitation called the \"64K reference limit\": many items present in a DEX file are referenced by an id stored on a 16-bit integer, e.g. it is the case for methods and fields references. To overcome the limitation, compilers such as d8 (or its predecessor dx ) split the code over additional DEX files classesN.dex , where N>=2. Additional references are created to reference definitions located in other DEX files. JEB merges all classesN.dex in a single, virtual DEX unit. Note that in practice, such DEX units could not be converted back to a single DEX file. Also keep in mind that apps may artificially split their code over multiple DEX files; the 64Krefs limit is not a hard requirement. This app was split over 7 dex files: Warning On pre-API 21 (Android 5) systems, it is the responsibility of the app to load additional files - i.e., the DEX splitting mechanism is not something baked into the Dalvik VM itself. Apps can extend the support class MultiDexApplication to avoid implementing their own DEX loader, as the vast majority of the apps do. However, keep in mind that this is in no way mandatory. Malware files or protected files can implement multi-dex loading facility however they see fit. On API 21 and above, with the advent of the new Android ART runtime, files named classesN.dex are scanned and pre-compiled along with classes.dex . However, this mechanism does not preclude apps to use additional DEX loading facility as well.","title":"DEX splitting"},{"location":"android.html#dex-execution","text":"There are two general types of dex files: regular dex files contain generic code, use standard Dalvik instructions, meant to run on all Android devices odex files, on the other hand - a generic term for \"optimized DEX\" - contain device specific instructions.","title":"DEX execution"},{"location":"android.html#optimized-dex-odex","text":"The DEX file(s) located in your app is not the code executed on device - except when debugging. DEX code is executed by a runtime: The legacy runtime (pre-API 21 Lollipop) uses a JIT (just-in-time) compiler and generate odex files on first run. The current runtime is named ART (short for Android Runtime ) and makes use of AOT (ahead-of-time) compilation of Dalvik to native (x86 or ARM) at install time Note The format of optimized DEX files has evolved over time (\"dey\" magic, OAT files with DEX or DEX-like entries, VDEX and CDEX, etc.). The process of reconstructing a DEX from an optimized-DEX is systematic and implemented in several tools, such as baksmali deodex or vdexExtractor . Refer to additional references, such as Lief's notes on OAT and ART , for more information on odex. Link: List of odex instructions .","title":"Optimized dex (odex)"},{"location":"android.html#dex-format","text":"This section quickly summarizes important facts about the DEX format. Refer to the official specifications for additional details: DEX format Bytecode format List of instructions . Structure of a DEX file The format can be linearly represented as: In Header: DEX magic, DEX version: dex\\n0NN\\0 where NN= 35: up to Android 7- 37: Android 7, invoke-virtual and invoke-super accept interface methods ids (support for Java 8's default methods) 38: Android 8, added invoke-polymorphic , invoke-custom , call sites and method handles entries ( details ) 39: Android 9, added const-method-handle , const-method-type ( details ) Tables are ordered alphabetically and do not allow duplicates Note that the map section was purely redundant until DEX 38 and the introduction of method handles and call sites. The three links above cannot be overlooked: any Android reverser should strive for Dex and Dalvik proficiency. That being said, below is a list of lesser-known or overlooked details about about Dalvik: Strings are encoded using a variant of CESU-8 called MUTF-8 (modified UTF-8) 1- 2- 3-byte encoding (whereas UTF-8 allows up to 4-byte) Surrogates: 2x3-byte for chars \\u010000 to \\u10FFFF (whereas canonical representations of UTF-8 does not use surrogates; UTF-16 does) \\u0000 is encoded as \\x00\\x00 (whereas UTF-8 uses \\x00) Special byte \\x00 indicates string end (there is no EOS concept with UTF-X) Some 32-bit integers are encoded using the variable encoding scheme LEB128 and its variants Types use Strings: type definition= index into string pool Prototypes use Strings and Types Shorty definition= index into string pool Full prototype definition = list of indices into type pool The Dalvik bytecode is stored in Code items Call Sites and Method Handles were introduced in DEX 38 The DEX header remained unchanged and does not directly reference those pools; instead, they are referenced in the Map area (which largely remained unused until those items were introduced) Learn more about DEX 38 on our blog","title":"DEX format"},{"location":"android.html#dalvik","text":"Dalvik is the name of the low-level bytecode stored in DEX files. Dalvik bytecode is interpreted by a Virtual Machine (DVM). Generation: Source language: smali (low-level), Java (high-level), Kotlin (very high-level) Java -> javac -> classfiles (Java bytecode) -> dx/d8 -> classes.dex (Dalvik bc) Characteristics: Register-based machine: 65,536 32-bit registers, numbered v0 to v65535 65,535 64-bit registers, \"emulated\" by using consecutive 32-bit registers [v0,v1], [v1,v2], ..., [vN,vN+1] No \"special\" register is accessible: no flag register, no PC register, no current-frame register, etc. Fixed frames (stack is N/A, no stack pointer), size declared in Code items Pointer= object reference ~= fits on a single register (32-bit) Regular instructions range from 2 to 10 bytes (=1 to 5 words) Instruction opcode encoded on a single byte; the second byte of the first word is generally used to encode register indices nop (1w), const-wide v1, 0x1122334455667788L (5w) The generally accepted convention is to represent Dalvik disassembly in smali or a variant of smali. By default, JEB uses a variant of Smali, slightly less verbose (more readable and better suited to be displayed and manipulated in an interactive UI). Method bodies live in isolation, the concept of \"jump far\" (unstructured dispatch) does not exist. Dispatching execution to other methods is done via invoke-xxx instructions only Jumps are always relative to the current PC Retrieving the returned value of a function is done via a move-result-xxx instruction, located right after the invoke-xxx instruction Arithmetic instructions have no side-effects / there is no flag register Data in bytecode is legal: Immediates: Some instructions store literals inline (i.e., within the instruction code), e.g. const-xxx N-way branching instruction: switch-xxx : the jump table is stored within the bytecode Small array initialization: fill-array-data : array data is stored within the bytecode. (Note that array data payload may be used by more than one fill-array-data instruction.)","title":"Dalvik"},{"location":"android.html#calling-convention","text":"The DVM runs managed code and uses a \"no side effect, no cleaning\" calling convention: every function gets a clean register slate upon execution; the parameters are stored at the bottom of the declared frame. Registers are 32-bit wide and noted vX , 0-indexed. The alternate notation pX is used to address registers used to store input method parameters: its indexing start from frame_size - input_slot_counts . Example 1: Method: void foo(int a, char b, bool c, Object d) The CodeItem declares a frame of size 5 v0 v1 <- parameter 0: p0 (a) v2 <- parameter 1: p1 (b) v3 <- parameter 2: p2 (c) v4 <- parameter 3: p3 (d) ------- end of method frame v5 v6 ... v65535 Example 2: Method: void bar(double a, long b, float c) The CodeItem declares a frame of size 8 v0 v1 v2 v3 <- parameter 0: p0 (a) v4 <- parameter 1: p1 (b, lower part) v5 <- parameter 1: p2 (b, higher part) v6 <- parameter 2: p3 (c, lower part) v7 <- parameter 2: p4 (c, higher part) ------- end of method frame v8 v9 ... v65535 The default settings instruct JEB to use the pX notation when rendering parameter registers: It can be disabled (DEX plugin option, also controlled in the UI by right-clicking, Rendering Properties , untick 'Use p for parameters')","title":"Calling convention"},{"location":"android.html#smali-and-variants","text":"The JEB notation is made possible because of the interactivity layer (as opposed to deadcode listing). Two notable differences: For readability, the names are simple names, no longer fully-qualified Invoke opcodes place the arguments after the method: invoke-xxx callsite, args instead of invoke-xxx {args}, fully_qualified_callsite Below, the default assembly code representation used by JEB (smali variant): Official smali code can be generated (it is useful if code needs to be exported, and later on compiled using smali.jar):","title":"Smali and variants"},{"location":"android.html#application-components","text":"The application and its main components (activities, broadcast receivers, services, content providers) must be declared in the Manifest, even if they are not meant to be exported (i.e., the external attribute is set to false). Warning There is one exception: broadcast receivers can be registered dynamically, via one of the Context.registerReceiver() methods. The name attribute of a component is the name of the corresponding class that will be instantiated and whose methods are to be called back by the Android system (for exported components). Example: the Manifest below declares an Activity class com.xyz.appcheck.AppCheck , among other components.","title":"Application components"},{"location":"android.html#entry-points","text":"The exported components of an APK can be equated to the entry-points of the application. Therefore, unlike types of executable programs, an Android application can have multiple entry-points. The true entry-point of a non-native application is the application's static initializer ( Application.<clinit> ). If the application being analyzed declares its own Application class in the manifest (instead of reusing android.app.Application), then that class's static initializer, if any, should be looked at first, followed by the constructors. Similarly, the static initializers and constructors of activities, receivers, services and providers are also entry-points. Finally, all API-defined callback methods of those five components can be called back by the system. Typically, the main activity's onCreate() method is the practical entry-point to an application, akin to a regular program's main() routine. Note JEB's disassembly view recaps the most important features of the APK at the top of the code listing. The important components, in particular any custom Application object, will be mentioned there:","title":"Entry points"},{"location":"android.html#activities","text":"Activities are activated by Intent . Exported activities (by default, any unfiltered activity is exported) are first-class entry-points. The following methods should be carefully examined: constructor (although the object state is uncertain) well-known callbacks, e.g. attachBaseContext (used to set up a delegate Activity), onCreate , onResume , etc.","title":"Activities"},{"location":"android.html#pseudo-activities","text":"Be mindful of activity aliases. They are not true components, however, they can and will override their target component's characteristics, such as intent filters.","title":"Pseudo activities"},{"location":"android.html#services","text":"Services are activated by Intent . Services are started by Activity code or Receiver code (after receiving a particular event). Most won't be easily started by the user, except for a few of them, such as Input services. Therefore, they should not be considered first-class entry-points from the point of view of code analysis.","title":"Services"},{"location":"android.html#broadcast-receivers","text":"Broadcast receivers are activated by Intent . The intent handler for ACTION_BOOT_COMPLETED is a common entry-point, commonly used by malicious code as a way to automatically start after the phone has booted up. Many more exist though (e.g., battery plugged, message received, phone lifted, etc.) Caveats: API 21+ (Lollipop) - need a wake lock API 26+ (Oreo) - need a JobIntentService","title":"Broadcast Receivers"},{"location":"android.html#content-providers","text":"Content providers are activated by ContentResolver .","title":"Content Providers"},{"location":"android.html#intents","text":"Intents are the primary method for inter-process and inter-app communication. Other IPC means exist, e.g. sockets, files, etc. Intents are used to activate components, e.g. start an activity. Reference","title":"Intents"},{"location":"android.html#dalvik-and-disassembly","text":"Plugins generate IUnit objects. Units can generate documents abiding to a standard interface, making them easy to render by clients implementing the JEB API. The primary document generated by an IDexUnit is a text document representing the disassembly of the input DEX files - or merged DEX files.","title":"Dalvik and Disassembly"},{"location":"android.html#auto-dex-merging","text":"Merging is done automatically, regardless of index limitations in place that may have required dex-splitting in the first place. In rare cases, you may want to disable merging. Upon loading an APK, several APK plugin options will be presented to you. Untick Merge multi-dex to disable auto-merging:","title":"Auto dex merging"},{"location":"android.html#dex-parsing-options","text":"DEX plugin options are accessible in the Engines options UI panel. Filter on \"dex.\" to list them. The user will also be presented a Processing Properties dialog box when opening a new file, giving the user a chance to adjust the default options stored in your jeb-engines.cfg files.","title":"DEX parsing options"},{"location":"android.html#addressing","text":"All addresses to types, methods and fields uses the canonical JVM notation, e.g.: type Blah in package com.abc: Lcom/abc/Blah; method foo(int):void in the type com.abc.Blah: Lcom/abc/Blah;->foo(I)V field name:String in the type com.abc.Blah: Lcom/abc/Blah;->name:Ljava/lang/String JEB extends the method notation to reference code locations via a suffix +OFFSET . Reference the instruction at offset 0x20 in the internal method foo(): Lcom/abc/Blah;->foo(I)V+20h","title":"Addressing"},{"location":"android.html#types-naming-conventions","text":"Historically, addressing in Java can be quite confusing. There exists three types of notations: The JVM notation (canonical representation) is the one used by DEX's TypeDescriptors , e.g. Ljava/lang/Object; . JEB's DEX plugins use and provide JVM canonical names. Two JLS notations : binary form, uses dots to separate package names, e.g.: java.lang.Object internal binary (or just, 'internal') uses slashes, e.g.: java/lang/Object The java.lang.Class API uses inconsistent representations, mostly the binary form. Android plugins use the JVM notation internally and externally (public API). Example: to reference a method void foo(String) in package a.b.c , its JVM address should be provided: La/b/c;->foo(Ljava/lang/String;)V . API methods using DEX addresses expect canonical addresses. The graphical client is less strict: although it expects canonical addresses by default as well, fall-back mechanisms are implemented to determine which address the user may have intended to use, and attempt to see if it's a match. See our Reference Document.","title":"Types Naming Conventions"},{"location":"android.html#disassembly","text":"The default output uses modified smali (as explained in the previous section). TODO This section is a work-in-progress.","title":"Disassembly"},{"location":"android.html#renaming-and-refactoring","text":"The DEX plugin provides smart renaming capabilities: renaming of items is done consistently throughout the code base. Most internal items can be renamed (internal items are those defined in the DEX, as opposed to external items, simply referenced in the DEX, but whose definition is located elsewhere). What can be renamed: class names (as well as interfaces and enums defined in the DEX) method names field names labels (addresses) package names variables (in decompiled units) In the UI client, Renaming can be done via the Action menu.","title":"Renaming and Refactoring"},{"location":"android.html#renaming-methods","text":"Proper refactoring is especially important when renaming non-static methods (virtual methods, interface methods) which may be part of a hierarchy of other methods, overridden parents or overriding children. Example: renaming B:a() should also rename A.a() and C.a() A.a():Object | B.a():String | C.a():String Renaming must also take into account indirect references to methods, something common when invoking virtual methods located in other classes, but which can be used to obfuscate a program further. A.a() | B.a() - within B: invoke-virtual A.a() -> actually refers to B.a() Things can get relatively complicated when hierarchies involve multiple inheritance through one or more interfaces.","title":"Renaming Methods"},{"location":"android.html#renaming-fields","text":"To some degree, the same applies to fields. Unlike methods, fields cannot be overridden; they are always accessed in a direct way, i.e. resolution is entirely determined at compile-time. However, field masking adds complications. A.i:int public | B.i:int public - this field masks A.i Shall a rename action of A.i also rename B.i? Conversely, shall renaming B.i also rename A.i? Theoretically, no. Those two fields are not related. However, at the moment, the DEX plugin renames both fields to maintain some degree of visual consistency with the original binary, regardless of whether field masking was done voluntarily or not, with obfuscating intent or not. This is likely to change with the addition of an option to let users decide how they want to perform renaming.","title":"Renaming Fields"},{"location":"android.html#reorganizing-code","text":"Packages can also be renamed. Users can also create additional packages and move packages and classes to other packages. This feature can come in handy when dealing with obfuscated code for which entire type hierarchies were flattened out into a handful (sometimes single) set of packages. Most obfuscators, including the ubiquitous Proguard and its now equivalent r8, can do that. If you want to explore refactoring further, in particular hierarchy reconstruction, have a look at our sample script DexCluster.py .","title":"Reorganizing code"},{"location":"android.html#forcing-inner-classes","text":"Classes can be moved inside other classes or methods. Whenever it is deemed possible, a class moved inside a method will be made anonymous. This process of anonymizing classes is an efficient way to defeat name-based obfuscation and annotation-scrapping-based obfuscation, that usually prevent the reconstruction of inner classes in general, and anonymous classes in particular. While drag&dropping in the GUI is an option for targeted refactoring, scripting is always preferable for bulk operations. Refer to IDexUnit.moveTo() in the API doc.","title":"Forcing inner classes"},{"location":"android.html#auto-rename","text":"Auto-renaming is an optional standard Action also implemented by the DEX plugin. As its name implies, it can perform automatic blanket renaming of all items of a unit. In the case of DEX units, they include types, methods, fields, etc. The action is semi-customizable by each plugin, as can be seen in the API . In the case of the DEX plugin, three policies are implemented. Each policy defines a set of legal characters for items. The loosest policy permits all characters in the printable ascii range (something already relatively strict considering the actual legal character ranges for Java identifiers); the strictest considers all current names (except those that were already defined) invalid, and therefore, will rename everything. The obfuscation applied below is using right-to-left unicode characters to complicate rendering: After auto-renaming (standard policy):","title":"Auto-rename"},{"location":"android.html#cross-references-in-dalvik","text":"Refer to the generic xrefs section of the manual.","title":"Cross-references in Dalvik"},{"location":"android.html#decompilation-to-java","text":"Note Make sure to read the generic Decompilation section of the manual.","title":"Decompilation to Java"},{"location":"android.html#decompiling-classes","text":"By default, the Decompile action in the UI menu triggers the decompilation of an entire class and its constituents (fields, methods, member classes, etc.). Fresh decompilation: With the current options set up in your Engines context: Use Action, Decompile or press the Tab key . With custom options: use Action, Decompile with Options or press the CMD1+Tab . Re-decompile (e.g., after changing options) Execute a \"Decompile with Options\" action as described above. The current decompilation of the class, if it existed, will be discarded, and a new decompilation will take place. To decompile a single item (e.g. a single method), perform a \"Decompile with options\" action and untick the \"Decompile top-level container class\".","title":"Decompiling classes"},{"location":"android.html#generic-decryption-and-deobfuscation","text":"The decompiler attempts to automatically performs data decryption and code unreflection. This process is done automatically by several method optimizers managed by the decompiler, with the help of code emulation in a built-in sandbox. Sample malware code decompilation: light-blue methods have been unreflected; Purple strings are the result of generic decryptions While the emulator and sandbox are currently not available in the IR API offered by dexdec , a few key parameters of the emulator can be customized via the coreplugins/dexdec-emu.cfg file. Copy the file dexdec-emu.cfg.TEMPLATE to dexdec-emu.cfg Edit dexdec-emu.cfg The changes will take effect at the next decompilation Currently, the configuration file allows users to specify: maximum emulation times emulation policy for external methods (by groups, restricted lists, whitelists, and blacklists - e.g., a user can forbid the emulation of any time/date-related method) Note Data decryption combined with unreflection yields very effective results against most classes of Dalvik obfuscators. You will find examples of this on our blog . Java 18+ The dexdec sandbox relies Java's SecurityManager , a standard JDK component that is deprecated in Java 18, and will be removed in future releases of Java. If you must use JDK 18+, a temporary workaround is to pass -Djava.security.manager=allow on the command line when starting JEB (e.g. $ java -Djava.security.manager=allow -jar bin/app/jebc.jar ). Ideally, we recommend using JDK 11 or JDK 17, until we have a replacement in place for this component.","title":"Generic decryption and deobfuscation"},{"location":"android.html#cf-unflattening","text":"Control-flow flattening is an advanced code protection technique used to \"de-structure\" a method. A flattened method consists of a dispatcher, reading a virtual program counter, tasked to dispatch the execution to a next group of instructions; those instructions will perform some of the original method's work, as well as update the virtual program counter and loop back to the dispatcher. In effect, protected methods appear like overly large switch statements. The original structures (loops, inner loops, conditionals, inner conditionals, etc.) are gone; the method appears to be flat. JEB attempts to detect and restructure such methods. CF unflattening relies on many heuristics and has limitations. It is not a bullet-proof optimizer. If you encounter problems, you may disable that obfuscator in the options, and/or report the problem.","title":"CF Unflattening"},{"location":"android.html#unvirtualization","text":"Code virtualization is one of the most advanced code protection technique currently available in protection software. JEB attempts to \"de-virtualize\" (regenerate and decompile) virtualized methods. Please refer to this blog post for additional details: Reversing DexGuard, Part 3 - Code Virtualization . Virtualized method (left), and the resulting unvirtualized output (right)","title":"Unvirtualization"},{"location":"android.html#exceptional-control-flow","text":"The decompilation of code protected in try blocks ( try/catch+/finally? ) is enabled by default. However, reconstruction of try-with-resources (also known as ARM , for Automatic Resource Management ) is more limited. This very-high level Java construct translates into complicated, lengthy, compiler-generated optimized code. Note Better support for try-with-resources reconstruction is a planned addition.","title":"Exceptional control flow"},{"location":"android.html#recovering-enums","text":"Enumerations in Java are high-level constructs that translate into multiple classes and synthetic methods. JEB attempts to discover and re-sugar those enumeration artifacts into the original enum. On failure, regular classes extending java.lang.Enum will be generated. Note Enum reconstruction can be disabled in the Options. Enums are great candidates for obfuscation, and most Android protectors do obfuscate them. That process destroys important synthetic fields and structures that would allow simple recovery heuristics to work. However, support should function reasonably well, even on enumeration data that was intentionally shuffled to generate decompilation errors. Note that enumerated fields can be renamed . Renaming is done consistently over the code base, including over reconstructed switches making use of such enums. Decompiled enums in android.arch.lifecycle . Renaming and cross-referencing enumerated constants is supported. Custom enumerated constants should also be properly reconstructed, including: Field annotations Custom initializers (see below) Additional methods and method overrides In this complex enumeration, the red block shows a custom initializer. Other interesting bits are the use of overrides and custom methods, annotations, as well as default and non-default constructors.","title":"Recovering enums"},{"location":"android.html#recovering-switches","text":"The detection and reconstruction of switch-on-enum and switch-on-string is supported. Reconstruction of switch-on-string can be very complicated depending on how the compiler has generated and optimized the code, and therefore, is limited to simple cases. This successfully reconstructed switch-on-string is implemented as a double-switch idiom by dx (a sparse switch on hashCode/equals to generate custom indices i, followed by a packed-switch on i). Not all switches are implemented like this. Regular if-conditional trees may be strategically generated by optimizing compilers. Note Better support for switch-on-string reconstruction is a planned addition.","title":"Recovering switches"},{"location":"android.html#member-classes-and-arguments-capturing","text":"Properly rendering non-trivial member classes (particularly non-static named classes or anonymous classes) is made difficult by the fact that some of their arguments are captured from the outer class(es). Properly rendering anonymous constructors, with exact argument types and position, is also challenging. In the example below, an anonymous class initializer is used to hide string decryption code: The anonymous class extends Android\u2019s OnActivityResultListener, instantiates the object, and tosses it immediately. Decryption code takes place in the initializer. Note the captured arguments from the outer container method __m : i , _b . Access to other private class fields is made via synthetic accessor calls that were re-sugared into seemingly direct field access ( BA._b ). Pseudo-moot anonymous class with an instance initializer attempting to conceal string decryption code.","title":"Member classes and arguments capturing"},{"location":"android.html#lambdas-generation","text":"By default, JEB will try to recover and reconstruct lambdas .","title":"Lambdas generation"},{"location":"android.html#desugared-lambdas","text":"Recovery and reconstruction does not rely on any type of metadata 1, such as special prefixes -$$Lambda$ for classes and methods implementing desugared lambdas in dex 37-. You may therefore see constructs like this: This DEX file contains desugared, non-obfuscated lambdas. This DEX file contained desugared, obfuscated lambdas API In the above cases, the underlying Java AST may be a IJavaNew or IJavaStaticField node. This is not the case for real (not desugared) lambdas. They will map to an IJavaCall node. Lambda reconstruction can be disabled in the options. Lambda rendering can also be disabled in the options, as well as on-demand by right-clicking a decompiled view, Rendering Options . Lambdas options","title":"Desugared Lambdas"},{"location":"android.html#real-lambdas","text":"Lambda reconstruction also takes place when the code has not been desugared (which is rare!), i.e. code relying on dex38\u2019s invoke-custom and invoke-polymorphic . This DEX file contains real lambdas implemented via invoke-custom API Such lambdas map to an IJavaCall node for which isLambdaCall() will return true.","title":"Real Lambdas"},{"location":"android.html#dynamic-invocation-opcodes","text":"The translation of invoke-custom whose bootstrap method is LambdaMetafactory.metafactory(...) allows the decompiler to generate proper Java code with lambda constructs. However, this is just one (albeit one of the most important) cases of dynamic dispatch. invoke-custom and related opcodes ( const-method-handle , const-method-type ) cannot be as \"easily\" translated into intermediate representations - and later on, AST. For that reason, those opcodes are translated to regular invocation to artificial methods.","title":"Dynamic invocation opcodes"},{"location":"android.html#artificial-classes-in-jebsynthetic","text":"Classes in the jeb.synthetic package are generated automatically by the DEX decompiler: InvokeCustoms contains static methods representing dynamic dispatch to a method handle's callsite done via an invoke-custom opcode: jeb.synthetic.InvokeCustoms.CallSite<INDEX>_<DynamicName>(DynamicPrototype) PooledMethodHandles contains static getters of method handles stored in a DEX pool and retrieved via a const-method-handle opcode: jeb.synthetic.PooledMethodHandles.Entry<INDEX>_<MethodName|FieldName>() : java.lang.invoke.MethodHandle PooledMethodTypes contains static getters of method types stored in a DEX pool and retrieved via a const-method-type opcode: jeb.synthetic.PooledMethodTypes.Entry<INDEX>() : java.lang.invoke.MethodType","title":"Artificial classes in jeb.synthetic"},{"location":"android.html#decompiling-java-bytecode","text":"JEB supports JLS bytecode decompilation for *.class files and *.jar -like archives ( jar , war , ear , etc.). The Java bytecode is converted to Dalvik using Android's dx by default. It falls-back to using d8 if a problem occurred. Users may choose to use d8 first instead by selecting so in the Options. The resulting DEX file(s) are processed as usual. You may use this to decompile Android Library files ( *.aar files) in JEB. Examining the android-arch-core-runtime library","title":"Decompiling Java Bytecode"},{"location":"android.html#debugging-apps","text":"Refer to the next section, Android Debugging .","title":"Debugging Apps"},{"location":"android.html#miscellaneous","text":"","title":"Miscellaneous"},{"location":"android.html#bulk-decompilation-and-export","text":"Bulk decompilation and export to *.java files on disk can be done in the UI client via the menu command File, Export, DEX Fast Decompilation . You may also provide a regular expression filter if you'd like to restrict decompilation to a package and its sub-packages, e.g. com\\.xyz\\..* will decompile all classes in com.xyz and its sub-packages. Refer to this note for generic details on exporting output.","title":"Bulk decompilation and Export"},{"location":"android.html#callgraph-fragment","text":"The callgraph fragment is not specific to Android (most code analysis can ask to generate one). It is an experimental feature designed to represent trimmed callgraphs of the most important routines and most important invocations between those routines. The fragment is located in the lower right-hand corner of a standard workspace. The callgraph is not generated by default: Empty callgraph Click on the fragment to generate it. The navigation shortcuts are similar to those used in the CFG fragment ('\\' to center, '[' and ']' or zoom in and out, etc.). Click a node to set the focus on the associated routine and their connections. Double-click a node to jump to that routine in the disassembly listing. A generated callgraph","title":"Callgraph fragment"},{"location":"android.html#displaying-synthetic-items","text":"How to always display synthetic fields and methods in decompiled views? In the vast majority of the cases, synthetic accessors used by inner classes need not be displayed as they are re-optimized into direct, seamless outer class field access or method invocation. However, if you wish to display them: In a decompiled view, right-click, \"Rendering Options\" and tick the boxes \"Generate synthetic fields\" and \"Generate synthetic methods\". You may also change this setting once and for all in the Engines option (Edit, Options, Engines). Example: forcing rendering of Synthetic Fields","title":"Displaying synthetic items"},{"location":"android.html#third-party-frameworks","text":"When analyzing applications using resources located in other frameworks that the Android Framework (e.g. the Samsung framework), follow those steps: Retrieve the custom framework archive using apt pull . It is normally stored somewhere in the device's /system/framework/ folder. Let's call it framework.zip. Run aapt2 dump framework.zip and retrieve the first line, which will be something like Package name=xxxxxxx id=N . Note the id, N . Navigate to the folder listed in your .parsers.apk.FrameworksDirectory engines property. Typically, it will be the HOME_FOLDER/.jeb-android-frameworks folder Copy framework.zip into this folder, and rename it to N.zip JEB should now be able to pick up that framework and use its resources when needed Note 1.zip in the FrameworksDirectory folder is the Android framework itself, which has id 1.","title":"Third-party Frameworks"},{"location":"client-configuration.html","text":"The UI client stores its client configuration , also known as the front-end configuration, in bin/jeb-client.cfg . The configuration file is a key-value store where keys are fully-qualified identifiers that start with a leading dot. The public keys can safely be changed by a user. They are accessible in the Options dialog, Advanced mode, panel Client . .CheckUpdates # Description : Let JEB automatically check for software updates (requires an Internet connection) Type and Default : Boolean(true) .DevelopmentMode # Description : Recommended when developing JEB extensions (scripts, plugins). Increase logger levels separately via the `LogLevel` property. Type and Default : Boolean(false) .LogLevel # Description : Set the global cutoff level for loggers, which will control what gets output in the 'Logger' view. If `DevelopmentMode` is enabled, this value is disregarded and assumed to be ALL (log everything). Type and Default : Selection(0){ALL(0), TRACE(10), DEBUG(20), INFO(30), WARN(40), ERROR(50), CATCHING(60)} .NetworkProxy # Description : Proxy settings for JEB front-end components. The format of this property is: 'type|hostname|port|user|pass|whitelist' type can be direct (no proxy), http, or socks hostname and port are mandatory for non-direct proxy types user and password are optional (needed only if your proxy requires authentication) whitelist is an optional list of domains/IPs (with support for the wildcard character *) for which no proxy connection should be used (always direct connect) Type and Default : String(\"\") .ScriptsFolder # Description : Folder containing JEB client scripts written in Python Type and Default : Path(\"$JEB_HOME/scripts\") .UpdateChannel # Description : Channel from which software updates are pulled from Type and Default : Selection(2){Release(0), Beta(1), Alpha(2)} .UploadErrorLogs # Description : Securely upload error logs to PNF Software error server Type and Default : Boolean(true) .ui.AlwaysLoadFragments # Description : Always load view fragments (leave to false to let lazy fragments load their data only they are visualized by the user) Type and Default : Boolean(false) .ui.AutoOpenDefaultUnit # Description : Upon processing a new file artifact, the default unit (internal rule set) will be opened - and the default fragment potentially opened as well Type and Default : Boolean(true) .ui.BrowseHistoryKeyboardShortcut # Description : Keyboard shortcut used to display input history in some widgets. Note that M1 means the Ctrl key on win/linux, Command key on macOS. Type and Default : String(\"M1+SPACE\") .ui.DoNotReplaceViews # Description : Create a new fragment when visualizing a type of document already opened in the workspace (instead of replacing it) Type and Default : Boolean(false) .ui.ExpandTreeNodesOnFiltering # Description : Expand matching tree nodes when applying a string filter Type and Default : Boolean(true) .ui.GloballyDisablePopupsOnMouseHover # Description : Disable the display of pop-ups providing contextual information when hovering the mouse cursor over elements (not recommended) Type and Default : Boolean(false) .ui.KeyboardShortcutsFile # Description : Location of the custom keyboard shortcuts file Type and Default : Path(\"jeb-shortcuts.cfg\") .ui.PreferRealAddressesInDialogs # Description : In dialogs displaying addresses (e.g., cross-references), always display real (internal) addresses over user-friendly addresses that may be provided by plugins Type and Default : Boolean(false) .ui.ProjectUnitSync # Description : Keep the unit that generated the currently visualized item visible in the Project tree Type and Default : Boolean(false) .ui.ShowParserPropertiesDialogOnNewFile # Description : Allow the customization of parsers properties before processing a new input artifact (highly recommended to keep on) Type and Default : Boolean(true) .ui.ShowWarningNotificationsInStatus # Description : Show important notifications by flashing a Warning sign in the status bar Type and Default : Boolean(true) .ui.graphs.AutoGenerate # Description : Auto-generate the global graph upon processing a binary file Type and Default : Boolean(false) .ui.graphs.KeepInMainDock # Description : Keep the global graph docked in the main shell instead of being in a floating modeless dialog Type and Default : Boolean(true) .ui.graphs.LockView # Description : Lock the global graph: prevent auto-moving/sync'ing with the currently active method or code item Type and Default : Boolean(false) .ui.logger.Colorize # Description : Colorize the logger output lines by their log levels (info, warning, error, etc.) Type and Default : Boolean(true) .ui.logger.LoggerMaxLength # Description : Maximum log buffer size in characters (older logger lines get discarded) Type and Default : Integer(524288){0+} .ui.native.DisableTypePreparsing # Description : Disable native type pre-parsing (syntax validation) in type edition dialogs Type and Default : Boolean(false) .ui.omnibox.Enabled # Description : Enable or disable the Omnibox (will require a restart) Type and Default : Boolean(true) .ui.omnibox.IncludeUnitTextDocuments # Description : If set, the Omnibox results will also include raw text search made on Unit text documents (excl. code units). Beware this will strain performance on large project files. Type and Default : Boolean(false) .ui.omnibox.MaxRecordCount # Description : Specify the maximum number of completion proposals provided by the Omnibox Type and Default : Integer(200){0-10000000} .ui.state.DecompInitialLocation # Description : Determine where the first panel holding a decompilation should be positioned Type and Default : Selection(-1){Auto(-1), Disabled(0), Split right(1), Split left(2), Split top(3), Split bottom(4)} .ui.state.MainShellBounds # Description : Bounds of the main shell. Leave blank for default; else: -1=maximized, or a set of \"x,y,w,h\" to remember position and size) Type and Default : String(\"\") .ui.text.AllowLineWrapping # Description : Wrap overly long lines Type and Default : Boolean(false) .ui.text.CharactersPerLineMax # Description : Maximum number of characters per line before forcing a line-wrap (whether or not line wrapping is enabled) Type and Default : Integer(1000000){0+} .ui.text.CharactersWrap # Description : Limit of a line before wrapping, if line wrap is enabled Type and Default : Integer(-1) .ui.text.DisplayEolAtEod # Description : Display an extra line at the end of a text document Type and Default : Boolean(true) .ui.text.ForceDisplayHorizontalScrollbar # Description : Always request the display of a horizontal scrollbar in text widgets Type and Default : Boolean(false) .ui.text.OverviewBarThickness # Description : Thickness in pixel of the overview bar (right-side of text docs); 0 to disable; -1 for auto-determination Type and Default : Integer(-1) .ui.text.ScrollLineSize # Description : Number of lines scrolled on a mouse-whell scroll action Type and Default : Integer(2) .ui.text.ViewportBarThickness # Description : Thickness in pixel of the viewport bar (left-side of text docs); 0 to disable; -1 for auto-determination Type and Default : Integer(-1) .ui.text.cfg.ShowAddresses # Description : Show addresses in control flow graph views Type and Default : Boolean(false) .ui.text.cfg.ShowBytesCount # Description : Show bytes in control flow graph views Type and Default : Integer(0) .ui.tree.BucketFlatMaxElements # Description : Maximum number of elements in a single artificial bucket Type and Default : Integer(500){0+} .ui.tree.BucketFlatThreshold # Description : Element count threshold that will trigger the creation of buckets in tree viewers with flat structures (e.g., native code hierarchies) Type and Default : Integer(5000){0+} .ui.tree.BucketTreeMaxElements # Description : Maximum number of elements in a single artificial bucket Type and Default : Integer(200){0+} .ui.tree.BucketTreeThreshold # Description : Element count threshold that will trigger the creation of buckets in tree viewers with hierarchical structures (e.g., Dalvik hierarchies) Type and Default : Integer(200){0+} .ui.tree.UseExplicitDefaultPackage # Description : Use a default package when artificial buckets in tree viewers are created Type and Default : Boolean(true) .ui.tree.code.AlwaysShowExtraColumns # Description : Always show additional columns in code hierarchies, to display sizes, addresses, etc. (if available) Type and Default : Boolean(false)","title":"Client Configuration"},{"location":"client-configuration.html#checkupdates","text":"Description : Let JEB automatically check for software updates (requires an Internet connection) Type and Default : Boolean(true)","title":".CheckUpdates"},{"location":"client-configuration.html#developmentmode","text":"Description : Recommended when developing JEB extensions (scripts, plugins). Increase logger levels separately via the `LogLevel` property. Type and Default : Boolean(false)","title":".DevelopmentMode"},{"location":"client-configuration.html#loglevel","text":"Description : Set the global cutoff level for loggers, which will control what gets output in the 'Logger' view. If `DevelopmentMode` is enabled, this value is disregarded and assumed to be ALL (log everything). Type and Default : Selection(0){ALL(0), TRACE(10), DEBUG(20), INFO(30), WARN(40), ERROR(50), CATCHING(60)}","title":".LogLevel"},{"location":"client-configuration.html#networkproxy","text":"Description : Proxy settings for JEB front-end components. The format of this property is: 'type|hostname|port|user|pass|whitelist' type can be direct (no proxy), http, or socks hostname and port are mandatory for non-direct proxy types user and password are optional (needed only if your proxy requires authentication) whitelist is an optional list of domains/IPs (with support for the wildcard character *) for which no proxy connection should be used (always direct connect) Type and Default : String(\"\")","title":".NetworkProxy"},{"location":"client-configuration.html#scriptsfolder","text":"Description : Folder containing JEB client scripts written in Python Type and Default : Path(\"$JEB_HOME/scripts\")","title":".ScriptsFolder"},{"location":"client-configuration.html#updatechannel","text":"Description : Channel from which software updates are pulled from Type and Default : Selection(2){Release(0), Beta(1), Alpha(2)}","title":".UpdateChannel"},{"location":"client-configuration.html#uploaderrorlogs","text":"Description : Securely upload error logs to PNF Software error server Type and Default : Boolean(true)","title":".UploadErrorLogs"},{"location":"client-configuration.html#uialwaysloadfragments","text":"Description : Always load view fragments (leave to false to let lazy fragments load their data only they are visualized by the user) Type and Default : Boolean(false)","title":".ui.AlwaysLoadFragments"},{"location":"client-configuration.html#uiautoopendefaultunit","text":"Description : Upon processing a new file artifact, the default unit (internal rule set) will be opened - and the default fragment potentially opened as well Type and Default : Boolean(true)","title":".ui.AutoOpenDefaultUnit"},{"location":"client-configuration.html#uibrowsehistorykeyboardshortcut","text":"Description : Keyboard shortcut used to display input history in some widgets. Note that M1 means the Ctrl key on win/linux, Command key on macOS. Type and Default : String(\"M1+SPACE\")","title":".ui.BrowseHistoryKeyboardShortcut"},{"location":"client-configuration.html#uidonotreplaceviews","text":"Description : Create a new fragment when visualizing a type of document already opened in the workspace (instead of replacing it) Type and Default : Boolean(false)","title":".ui.DoNotReplaceViews"},{"location":"client-configuration.html#uiexpandtreenodesonfiltering","text":"Description : Expand matching tree nodes when applying a string filter Type and Default : Boolean(true)","title":".ui.ExpandTreeNodesOnFiltering"},{"location":"client-configuration.html#uigloballydisablepopupsonmousehover","text":"Description : Disable the display of pop-ups providing contextual information when hovering the mouse cursor over elements (not recommended) Type and Default : Boolean(false)","title":".ui.GloballyDisablePopupsOnMouseHover"},{"location":"client-configuration.html#uikeyboardshortcutsfile","text":"Description : Location of the custom keyboard shortcuts file Type and Default : Path(\"jeb-shortcuts.cfg\")","title":".ui.KeyboardShortcutsFile"},{"location":"client-configuration.html#uipreferrealaddressesindialogs","text":"Description : In dialogs displaying addresses (e.g., cross-references), always display real (internal) addresses over user-friendly addresses that may be provided by plugins Type and Default : Boolean(false)","title":".ui.PreferRealAddressesInDialogs"},{"location":"client-configuration.html#uiprojectunitsync","text":"Description : Keep the unit that generated the currently visualized item visible in the Project tree Type and Default : Boolean(false)","title":".ui.ProjectUnitSync"},{"location":"client-configuration.html#uishowparserpropertiesdialogonnewfile","text":"Description : Allow the customization of parsers properties before processing a new input artifact (highly recommended to keep on) Type and Default : Boolean(true)","title":".ui.ShowParserPropertiesDialogOnNewFile"},{"location":"client-configuration.html#uishowwarningnotificationsinstatus","text":"Description : Show important notifications by flashing a Warning sign in the status bar Type and Default : Boolean(true)","title":".ui.ShowWarningNotificationsInStatus"},{"location":"client-configuration.html#uigraphsautogenerate","text":"Description : Auto-generate the global graph upon processing a binary file Type and Default : Boolean(false)","title":".ui.graphs.AutoGenerate"},{"location":"client-configuration.html#uigraphskeepinmaindock","text":"Description : Keep the global graph docked in the main shell instead of being in a floating modeless dialog Type and Default : Boolean(true)","title":".ui.graphs.KeepInMainDock"},{"location":"client-configuration.html#uigraphslockview","text":"Description : Lock the global graph: prevent auto-moving/sync'ing with the currently active method or code item Type and Default : Boolean(false)","title":".ui.graphs.LockView"},{"location":"client-configuration.html#uiloggercolorize","text":"Description : Colorize the logger output lines by their log levels (info, warning, error, etc.) Type and Default : Boolean(true)","title":".ui.logger.Colorize"},{"location":"client-configuration.html#uiloggerloggermaxlength","text":"Description : Maximum log buffer size in characters (older logger lines get discarded) Type and Default : Integer(524288){0+}","title":".ui.logger.LoggerMaxLength"},{"location":"client-configuration.html#uinativedisabletypepreparsing","text":"Description : Disable native type pre-parsing (syntax validation) in type edition dialogs Type and Default : Boolean(false)","title":".ui.native.DisableTypePreparsing"},{"location":"client-configuration.html#uiomniboxenabled","text":"Description : Enable or disable the Omnibox (will require a restart) Type and Default : Boolean(true)","title":".ui.omnibox.Enabled"},{"location":"client-configuration.html#uiomniboxincludeunittextdocuments","text":"Description : If set, the Omnibox results will also include raw text search made on Unit text documents (excl. code units). Beware this will strain performance on large project files. Type and Default : Boolean(false)","title":".ui.omnibox.IncludeUnitTextDocuments"},{"location":"client-configuration.html#uiomniboxmaxrecordcount","text":"Description : Specify the maximum number of completion proposals provided by the Omnibox Type and Default : Integer(200){0-10000000}","title":".ui.omnibox.MaxRecordCount"},{"location":"client-configuration.html#uistatedecompinitiallocation","text":"Description : Determine where the first panel holding a decompilation should be positioned Type and Default : Selection(-1){Auto(-1), Disabled(0), Split right(1), Split left(2), Split top(3), Split bottom(4)}","title":".ui.state.DecompInitialLocation"},{"location":"client-configuration.html#uistatemainshellbounds","text":"Description : Bounds of the main shell. Leave blank for default; else: -1=maximized, or a set of \"x,y,w,h\" to remember position and size) Type and Default : String(\"\")","title":".ui.state.MainShellBounds"},{"location":"client-configuration.html#uitextallowlinewrapping","text":"Description : Wrap overly long lines Type and Default : Boolean(false)","title":".ui.text.AllowLineWrapping"},{"location":"client-configuration.html#uitextcharactersperlinemax","text":"Description : Maximum number of characters per line before forcing a line-wrap (whether or not line wrapping is enabled) Type and Default : Integer(1000000){0+}","title":".ui.text.CharactersPerLineMax"},{"location":"client-configuration.html#uitextcharacterswrap","text":"Description : Limit of a line before wrapping, if line wrap is enabled Type and Default : Integer(-1)","title":".ui.text.CharactersWrap"},{"location":"client-configuration.html#uitextdisplayeolateod","text":"Description : Display an extra line at the end of a text document Type and Default : Boolean(true)","title":".ui.text.DisplayEolAtEod"},{"location":"client-configuration.html#uitextforcedisplayhorizontalscrollbar","text":"Description : Always request the display of a horizontal scrollbar in text widgets Type and Default : Boolean(false)","title":".ui.text.ForceDisplayHorizontalScrollbar"},{"location":"client-configuration.html#uitextoverviewbarthickness","text":"Description : Thickness in pixel of the overview bar (right-side of text docs); 0 to disable; -1 for auto-determination Type and Default : Integer(-1)","title":".ui.text.OverviewBarThickness"},{"location":"client-configuration.html#uitextscrolllinesize","text":"Description : Number of lines scrolled on a mouse-whell scroll action Type and Default : Integer(2)","title":".ui.text.ScrollLineSize"},{"location":"client-configuration.html#uitextviewportbarthickness","text":"Description : Thickness in pixel of the viewport bar (left-side of text docs); 0 to disable; -1 for auto-determination Type and Default : Integer(-1)","title":".ui.text.ViewportBarThickness"},{"location":"client-configuration.html#uitextcfgshowaddresses","text":"Description : Show addresses in control flow graph views Type and Default : Boolean(false)","title":".ui.text.cfg.ShowAddresses"},{"location":"client-configuration.html#uitextcfgshowbytescount","text":"Description : Show bytes in control flow graph views Type and Default : Integer(0)","title":".ui.text.cfg.ShowBytesCount"},{"location":"client-configuration.html#uitreebucketflatmaxelements","text":"Description : Maximum number of elements in a single artificial bucket Type and Default : Integer(500){0+}","title":".ui.tree.BucketFlatMaxElements"},{"location":"client-configuration.html#uitreebucketflatthreshold","text":"Description : Element count threshold that will trigger the creation of buckets in tree viewers with flat structures (e.g., native code hierarchies) Type and Default : Integer(5000){0+}","title":".ui.tree.BucketFlatThreshold"},{"location":"client-configuration.html#uitreebuckettreemaxelements","text":"Description : Maximum number of elements in a single artificial bucket Type and Default : Integer(200){0+}","title":".ui.tree.BucketTreeMaxElements"},{"location":"client-configuration.html#uitreebuckettreethreshold","text":"Description : Element count threshold that will trigger the creation of buckets in tree viewers with hierarchical structures (e.g., Dalvik hierarchies) Type and Default : Integer(200){0+}","title":".ui.tree.BucketTreeThreshold"},{"location":"client-configuration.html#uitreeuseexplicitdefaultpackage","text":"Description : Use a default package when artificial buckets in tree viewers are created Type and Default : Boolean(true)","title":".ui.tree.UseExplicitDefaultPackage"},{"location":"client-configuration.html#uitreecodealwaysshowextracolumns","text":"Description : Always show additional columns in code hierarchies, to display sizes, addresses, etc. (if available) Type and Default : Boolean(false)","title":".ui.tree.code.AlwaysShowExtraColumns"},{"location":"debugging.html","text":"Debugging Android apps Looking to dive head-first into Android application debugging? Read on and then head to the Android Debugging section. Debuggers are special modules that attach to existing code units. They do not produce additional units; instead, they provide specialized actions , accessible graphically via the Debugger menu in the UI client. An example of two debugger units (Dalvik and native) connected to an Android app Scripting Debugger modules offer a rich API. UI clients can only reflect those functionality partly. Visit the Resources sub-section for more information on how to use the debuggers API to perform advanced dynamic analysis of applications. Availability # JEB ships with debuggers for: Android DEX bytecode: the debugger implements JDWP Machine code (x86/x86-64, ARM/ARM64, MIPS, etc.): the debugger implements the gdb/lldb protocol Attaching to a Target # Open a code view representing the code unit to be debugged. Execute Debugger/Attach Select the target machine and target process Click Attach Attaching to a local target One or more debugger unit(s) will be created, depending on your target application. Views # The UI client will also open automatically open views that represent the debugger units. Those views are: Threads Breakpoints Local variables and registers Memory and live disassembly (if applicable) Current stack (if applicable) Log view An ongoing debugging session You may want to switch to a custom layout to better accommodate those additional views. The above pictures shows an on-going debugging session of an Android app. A custom layout is used: the bytecode debugger views are in the top-right hand quadrant the process code debugger views are in the bottom-right hand quadrant A breakpoint can also be seen, as well as the about-to-be-executed line of code. Basic Commands # The basic commands are accessible from the Debugger menu. Detach from or restart the debugging session Pause, resume, or terminate the target Suspend or resume threads Set breakpoints Step execution (into, over, or out of a routine) Add dynamic code units to a debugger (e.g. dex units to a dalvik debugger, native code units to a native debugger) , while a debugging session is active. This is useful when code objects are retrieved and need to be added to a project after an analysis was started. The live values of variables and registers can also be examined by hovering over an item representing them. Advanced Commands # Advanced debugging commands can be used via the Console view. This view is linked to command interpreters offered by the currently focused unit. Debuggers offer command interpreter to perform advanced tasks such as: Searching patterns in memory Examining objects Creating objects or invoking methods Custom tasks specific to a given debugger that cannot be generically represented by the UI client An expanded Console view with an interpreter connected to the Dalvik Bytecode debugger Learn more A detailed overview of the interpreters' features can be found on our blog . Android Debugging # Learn more about Android application debugging by going through this next manual page .","title":"Debugging"},{"location":"debugging.html#availability","text":"JEB ships with debuggers for: Android DEX bytecode: the debugger implements JDWP Machine code (x86/x86-64, ARM/ARM64, MIPS, etc.): the debugger implements the gdb/lldb protocol","title":"Availability"},{"location":"debugging.html#attaching-to-a-target","text":"Open a code view representing the code unit to be debugged. Execute Debugger/Attach Select the target machine and target process Click Attach Attaching to a local target One or more debugger unit(s) will be created, depending on your target application.","title":"Attaching to a Target"},{"location":"debugging.html#views","text":"The UI client will also open automatically open views that represent the debugger units. Those views are: Threads Breakpoints Local variables and registers Memory and live disassembly (if applicable) Current stack (if applicable) Log view An ongoing debugging session You may want to switch to a custom layout to better accommodate those additional views. The above pictures shows an on-going debugging session of an Android app. A custom layout is used: the bytecode debugger views are in the top-right hand quadrant the process code debugger views are in the bottom-right hand quadrant A breakpoint can also be seen, as well as the about-to-be-executed line of code.","title":"Views"},{"location":"debugging.html#basic-commands","text":"The basic commands are accessible from the Debugger menu. Detach from or restart the debugging session Pause, resume, or terminate the target Suspend or resume threads Set breakpoints Step execution (into, over, or out of a routine) Add dynamic code units to a debugger (e.g. dex units to a dalvik debugger, native code units to a native debugger) , while a debugging session is active. This is useful when code objects are retrieved and need to be added to a project after an analysis was started. The live values of variables and registers can also be examined by hovering over an item representing them.","title":"Basic Commands"},{"location":"debugging.html#advanced-commands","text":"Advanced debugging commands can be used via the Console view. This view is linked to command interpreters offered by the currently focused unit. Debuggers offer command interpreter to perform advanced tasks such as: Searching patterns in memory Examining objects Creating objects or invoking methods Custom tasks specific to a given debugger that cannot be generically represented by the UI client An expanded Console view with an interpreter connected to the Dalvik Bytecode debugger Learn more A detailed overview of the interpreters' features can be found on our blog .","title":"Advanced Commands"},{"location":"debugging.html#android-debugging","text":"Learn more about Android application debugging by going through this next manual page .","title":"Android Debugging"},{"location":"decompiling.html","text":"Decompilers are special modules that work on units as input instead of artifacts. They produce units as well, representing portions of decompiled source code. Decompilers # JEB Pro ships with decompilers for: Dalvik (Android Dex files) Intel x86: x86_32, x86_64, x87 (fpu), MMX, SSE, other ISA extensions (support is limited/WIP for sse2+ and avx) ARM: 32-bit, Thumb (16-bit), aarch64 (64-bit), most ISA extensions MIPS (32-bit, 64-bit) RISC-V (RV32, RV64) Simatic S7 PLC (MC7), for S7-300/S7-400 programs ( Manual ) WebAssembly modules (wasm) Ethereum contracts (EVM code) Java (classfile) The following picture shows a child decompiler unit, as well as a suite of decompiled classes units. Internals # Currently, JEB relies on two separate decompiler pipelines: DEXDEC ( dexdec ) is the Dex/Dalvik (as well as Java) decompiler. This decompiler works exclusively with Dalvik input. The primary interface to the reference implementation is IDexDecompilerUnit . GENDEC ( gendec ) is the Generic decompilation pipeline, which can handle all types of code, native code, managed code, or else. GENDEC is more modular and open than DEXDEC. All native (x86, arm, etc.) as well as no-native (Ethereum, WebAssembly) decompiler plugins are built on GENDEC. How to Decompile # In the assembly view, position your caret on the area of code you would like to decompile. Hit the Tab key to decompile code (you can customize this, see the Keyboard Shortcuts section in the Settings page ) If a decompiler unit can be created for the current code unit, a new decompiled code unit will be created The decompiled code unit will receive focus and the caret positioned on the area of code that most closely corresponds to the low-level bytecode or machine code Decompiling with Options # Decompiling with Options is also offered in the Action menu. The default keyboard shortcut is MOD1+Tab. (On most platforms, MOD1 is the Control key; on macOS, it is the Command key.) When the current settings of your decompiler plugin are not exactly how you want to decompile at a given location, use Decompile with Options to change your settings on the fly. This action also allows users to force the re-decompilation of an already decompiled code item. (A clunkier alternative would be to find the corresponding decompiled unit node in the Project Hierarchy, remove it, and then decompile again.) An example of a Dex Decompiler options widget that popped up when Decompiling with Options . Note that the widget does contain different options for a Native Decompiler. Back to the Assembly # Conversely, you can go back to the assembly from a decompiled view by using the Tab key. Managing Views # By default, a view representing a portion of decompiled code (e.g., a class) will be replaced by the next class being decompiled. This default behavior is to avoid cluttering the workspace with tens of views representing various decompiled artifacts. However, if you would like to open every piece of decompiled code in a separate view, you may do so by checking the Navigation, do not replace Views menu option. The 'Do not replace views' option can be enabled or disabled via the Navigation menu Actions and Interactivity # Generally, when it comes to interactivity, decompilation plugins proxy requests to their corresponding parent code unit. That means that the actions set offered is essentially the same. The consistency between views is maintained.","title":"Decompiling"},{"location":"decompiling.html#decompilers","text":"JEB Pro ships with decompilers for: Dalvik (Android Dex files) Intel x86: x86_32, x86_64, x87 (fpu), MMX, SSE, other ISA extensions (support is limited/WIP for sse2+ and avx) ARM: 32-bit, Thumb (16-bit), aarch64 (64-bit), most ISA extensions MIPS (32-bit, 64-bit) RISC-V (RV32, RV64) Simatic S7 PLC (MC7), for S7-300/S7-400 programs ( Manual ) WebAssembly modules (wasm) Ethereum contracts (EVM code) Java (classfile) The following picture shows a child decompiler unit, as well as a suite of decompiled classes units.","title":"Decompilers"},{"location":"decompiling.html#internals","text":"Currently, JEB relies on two separate decompiler pipelines: DEXDEC ( dexdec ) is the Dex/Dalvik (as well as Java) decompiler. This decompiler works exclusively with Dalvik input. The primary interface to the reference implementation is IDexDecompilerUnit . GENDEC ( gendec ) is the Generic decompilation pipeline, which can handle all types of code, native code, managed code, or else. GENDEC is more modular and open than DEXDEC. All native (x86, arm, etc.) as well as no-native (Ethereum, WebAssembly) decompiler plugins are built on GENDEC.","title":"Internals"},{"location":"decompiling.html#how-to-decompile","text":"In the assembly view, position your caret on the area of code you would like to decompile. Hit the Tab key to decompile code (you can customize this, see the Keyboard Shortcuts section in the Settings page ) If a decompiler unit can be created for the current code unit, a new decompiled code unit will be created The decompiled code unit will receive focus and the caret positioned on the area of code that most closely corresponds to the low-level bytecode or machine code","title":"How to Decompile"},{"location":"decompiling.html#decompiling-with-options","text":"Decompiling with Options is also offered in the Action menu. The default keyboard shortcut is MOD1+Tab. (On most platforms, MOD1 is the Control key; on macOS, it is the Command key.) When the current settings of your decompiler plugin are not exactly how you want to decompile at a given location, use Decompile with Options to change your settings on the fly. This action also allows users to force the re-decompilation of an already decompiled code item. (A clunkier alternative would be to find the corresponding decompiled unit node in the Project Hierarchy, remove it, and then decompile again.) An example of a Dex Decompiler options widget that popped up when Decompiling with Options . Note that the widget does contain different options for a Native Decompiler.","title":"Decompiling with Options"},{"location":"decompiling.html#back-to-the-assembly","text":"Conversely, you can go back to the assembly from a decompiled view by using the Tab key.","title":"Back to the Assembly"},{"location":"decompiling.html#managing-views","text":"By default, a view representing a portion of decompiled code (e.g., a class) will be replaced by the next class being decompiled. This default behavior is to avoid cluttering the workspace with tens of views representing various decompiled artifacts. However, if you would like to open every piece of decompiled code in a separate view, you may do so by checking the Navigation, do not replace Views menu option. The 'Do not replace views' option can be enabled or disabled via the Navigation menu","title":"Managing Views"},{"location":"decompiling.html#actions-and-interactivity","text":"Generally, when it comes to interactivity, decompilation plugins proxy requests to their corresponding parent code unit. That means that the actions set offered is essentially the same. The consistency between views is maintained.","title":"Actions and Interactivity"},{"location":"engines-configuration.html","text":"JEB clients store the JEB engines configuration , also known as the back-end configuration, in the bin/jeb-engines.cfg . The configuration file is a key-value store where keys are fully-qualified identifiers that start with a leading dot. This file contains general back-end settings as well as the settings of common plugins shipping with most distributions of JEB. Each plugin has its own sub-namespace ( .PluginType ) within the .parsers namespace. Keys pertaining to document rendering are stored in a sub-region named .text . The public keys can safely be changed by a user. They are accessible in the Options dialog, Advanced mode, panel Engines . The engines configuration acts as a template for your projects' settings. Once a project is loaded, an additional tab named Project-Specific allows the user to modify the back-end settings of the project only, without changing the global back-end settings. ) .CodelessSigsFolder # Description : Folder containing codeless signature libraries Type and Default : Path(\"$JEB_HOME/siglibs/codeless\") .CustomNotPrintableCharacterRanges # Description : Ranges of characters that should be escaped, i.e. not considered printable (customization of Formatter.isPrintableChar). Formatted as a CSL of UTF-16 ranges: xxxx-xxxx,xxxx-xxxx,... Type and Default : String(\"\") .CustomPrintableCharacterRanges # Description : Ranges of characters that should be considered printable, i.e. not be escaped (customization of Formatter.isPrintableChar). Formatted as a CSL of UTF-16 ranges: xxxx-xxxx,xxxx-xxxx,... Type and Default : String(\"\") .DatabaseBackupBeforeSave # Description : Before saving a project to a JDB2 database, the current database is copied to the %TEMP% folder and will be used as backup in case any problem happen during saving. Type and Default : Boolean(true) .DevPluginClassnames # Description : Classnames of your in-development plugin entry-point classes (they are not JARs) Type and Default : String(\"\") .DevPluginClasspath # Description : Classpath for your in-development plugins (they are not JARs) Type and Default : String(\"\") .FlattenStringsInCodeDocuments # Description : This global setting instructs code document generators (e.g., generating assembly or source code) to 'flatten' the strings before rendering. This means that all code tokens will be partially escaped as a means to ensure proper rendering of obfuscated names, regardless of the typeface or system in-use. Type and Default : Boolean(false) .LoadPythonPlugins # Description : Specify whether or not JEB back-end plugins written in Python are allowed and should be loaded. When this option is enabled, Python script plugins located in the plugins folder 'scripts' subdirectory (typically, coreplugins/scripts) can be loaded and instantiated by back-end components. Type and Default : Boolean(false) .NetworkProxy # Description : Proxy settings for JEB back-end components. The format of this property is: 'type|hostname|port|user|pass|whitelist' type can be direct (no proxy), http, or socks hostname and port are mandatory for non-direct proxy types user and password are optional (needed only if your proxy requires authentication) whitelist is an optional list of domains/IPs (with support for the wildcard character *) for which no proxy connection should be used (always direct connect) Type and Default : String(\"\") .PluginsFolder # Description : Location of the JEB back-end plugins folder Type and Default : String(\"$JEB_HOME/coreplugins\") .SiglibsFolder # Description : Folder containing native code signature libraries Type and Default : Path(\"$JEB_HOME/siglibs\") .TypelibsFolder # Description : Folder containing native type libraries Type and Default : Path(\"$JEB_HOME/typelibs\") .parsers.EnforceVersionChecks # Description : Verify and enforce plugins requirements. E.g. if enabled, a plugin requiring JEB version 2.3.10 to 3.0.7 will not be loaded if JEB is older than 2.3.10 or newer than 3.0.7 Type and Default : Boolean(true) .parsers.apk.AndroidJavadocRoot # Description : Location of Java and Android API documentation files. By default, local files stored in the Android SDK folder will be preferred over web-based API doc Type and Default : String(\"($ANDROID_HOME/docs|$ANDROID_SDK_HOME/docs|$ANDROID_SDK_ROOT/docs)/reference/;https://developer.android.com/reference/;($JAVA_HOME)/docs/api\") .parsers.apk.ArscRestructuringMode # Description : Restructuring mode for decoded resource files. This option permits the deobfuscation of obfuscated arsc entries. Type and Default : Selection(3){None(0), Basic(1), Move(2), Move and Rename(3)} .parsers.apk.DisableAssetsProcessingThreshold # Description : The plugin will suggest disabling the auto-processing of APK assets if the number of asset files exceed that threshold (0 to disable) Type and Default : Integer(300){0+} .parsers.apk.DisableResourcesProcessingThreshold # Description : The plugin will suggest disabling the auto-processing of APK resources if the number of resource files exceed that threshold (0 to disable) Type and Default : Integer(500){0+} .parsers.apk.FrameworksDirectory # Description : Directory containing additional frameworks. Leave empty to use the default, which is the \".jeb-android-frameworks\" directory in the Home folder Type and Default : Path(\"\") .parsers.apk.GenerateAapt2Output # Description : Generate an additional text fragment that will describe the APK resources similarly to AAPT2's output Type and Default : Boolean(false) .parsers.apk.MergeMultiDex # Description : Merge the DEX files of a multi-DEX APK into a single, unified DEX unit Type and Default : Boolean(true) .parsers.apk.ProcessAssets # Description : Process unstructured resources stored in the APK's assets/ directory Type and Default : Boolean(true) .parsers.apk.ProcessBytecode # Description : Process the Dalvik bytecode (classes[N].dex) Type and Default : Boolean(true) .parsers.apk.ProcessCertificates # Description : Process the APK's certificates data (legacy, v1, v2, v3) Type and Default : Boolean(true) .parsers.apk.ProcessLibraries # Description : Process native code (.so) libraries stored in the APK's lib/ directory Type and Default : Boolean(true) .parsers.apk.ProcessManifest # Description : Decode and process the APK Manifest Type and Default : Boolean(true) .parsers.apk.ProcessResources # Description : Decode and process the Resources (if this option is true, the Manifest is always processed) Type and Default : Boolean(true) .parsers.dbug_apk.AttachPortRangeSize # Description : Number of ports to try after the preferred port if the preferred port is in useby another program Type and Default : Integer(20){1-100} .parsers.dbug_apk.AttachPortRangeStart # Description : Preferred TCP port to use and listen to when attaching to the JDWP debugger Type and Default : Integer(8900){1024-65535} .parsers.dbug_apk.BlockingQueryTimeoutSeconds # Description : Maximum time in seconds to wait for a response from the debugger server Type and Default : Integer(15){0+} .parsers.dbug_apk.NativeAttachPortRangeSize # Description : Number of ports to try after the preferred port if the preferred port is in useby another program Type and Default : Integer(20){1-100} .parsers.dbug_apk.NativeAttachPortRangeStart # Description : Preferred TCP port to use and listen to when attaching to the native debugger Type and Default : Integer(8950){1024-65535} .parsers.dbug_apk.PreferLldbserver # Description : Prefer the use of LLDB server over GDB server for debugging native Android code. Type and Default : Boolean(true) .parsers.dbug_apk.PreferredGdbserverVersion # Description : Preferred GDB server version to use. JEB does not ship with all versions of GDB server for all platforms. See the core/assets/ folder in your jeb.jar software archive.It is recommended to use the default. Type and Default : String(\"\") .parsers.dbug_apk.PreferredLldbserverVersion # Description : Preferred LLDB server version to use. JEB does not ship with all versions of LLDB server for all platforms. See the core/assets/ folder in your jeb.jar software archive.It is recommended to use the default. Type and Default : String(\"\") .parsers.dbug_elf.BlockingQueryTimeoutSeconds # Description : Maximum time in seconds to wait for a response from the debugger server Type and Default : Integer(15){0+} .parsers.dcmp_dex.DecompileTopLevelContainerClass # Description : When requesting a decompilation at a particular location A, determine the top-level non-inner class at A, and decompile that class and all its constituents (methods, inners, etc.). If this option is disabled, precise decompilation will be performed: the requested address will not be reinterpreted, and only the target object will be decompiled. Example: decompiling while on a method F's bytecode will decompile F and F only (not its container class, not its inners, etc.). Type and Default : Boolean(true) .parsers.dcmp_dex.DisplayASTElementStackOnHover # Description : Display the parent and ancestors of a decompiled Java AST node when the mouse cursor hovers over it (useful to debug or troubleshoot a script) Type and Default : Boolean(true) .parsers.dcmp_dex.DisplayMethodInternalsAsComment # Description : When rendering source, prepend method internals as a comment block before rendering the method Type and Default : Selection(0){None(0), Signature(1), Signature, AST(2)} .parsers.dcmp_dex.DisplayPrivateMethodsLast # Description : Output private methods last (after public, default and protected methods) Type and Default : Boolean(false) .parsers.dcmp_dex.EmulationSupport # Description : Support for emulation, allowing optimizers to perform complex code cleaning such as decryption Type and Default : Selection(2){Disabled(0), Enabled with Confirmation(1), Enabled(2)} .parsers.dcmp_dex.EmulatorConfigPath # Description : Path to the emulator configuration file. If the path is relative, the configuration file will be searched in JEB's plugins directory (usually, coreplugins/). Type and Default : Path(\"dexdec-emu.cfg\") .parsers.dcmp_dex.EnableCFUnflattener # Description : Enable control-flow unflattening. The obfuscators must be enabled. Type and Default : Boolean(true) .parsers.dcmp_dex.EnableCacheForStringDecryption # Description : The emulation cache is used to store and reuse the results of select, previously emulated invocations. It works using heuristics, and is theoretically unsafe (a cached entry may be incorrect). In the general case, it is relatively safe to use and should speed up emulation results. If problems show up on a specific file/method, disable it and attempt a redecompilation. Type and Default : Boolean(true) .parsers.dcmp_dex.EnableDeobfuscators # Description : Enable unsafe deobfuscation optimizers. Those aggressive optimizers can generate code radically different than the underlying bytecode. Type and Default : Boolean(true) .parsers.dcmp_dex.EnableExternalPlugins # Description : Enable external plugins, such as customized IR optimizers. If this option is disabled, user-made java/python plugins will not be integrated to dexdec. Type and Default : Boolean(true) .parsers.dcmp_dex.EnableUnvirtualizer # Description : Enable unvirtualization of methods and classes protected by a VM. The obfuscators must be enabled, and your license must support this option. Type and Default : Boolean(true) .parsers.dcmp_dex.GenerateAnnotations # Description : Generate Java annotations Type and Default : Boolean(true) .parsers.dcmp_dex.GenerateLambdas # Description : Favor the generation of lambda functions (Java 8+) if possible. Lambdas must have been reconstructed (engines option) Type and Default : Boolean(true) .parsers.dcmp_dex.GenerateOverrideAnnotations # Description : Geneate additional @Override annotations for methods for which super implementations or definitions were found Type and Default : Boolean(true) .parsers.dcmp_dex.GenerateSyntheticFields # Description : Explicitly generate synthetic fields Type and Default : Boolean(false) .parsers.dcmp_dex.GenerateSyntheticMethods # Description : Explicitly generate synthetic methods Type and Default : Boolean(false) .parsers.dcmp_dex.IdentifierNamingStrategy # Description : Naming strategy for the identifiers Type and Default : Selection(0){Register-based(0), Type-based(1)} .parsers.dcmp_dex.InsertBlankLinesAfterCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_dex.ListOfDisabledExternalPlugins # Description : Comma-separated list of names of decompiler plugins that must be disabled (by default, a plugin is enabled) Type and Default : String(\"\") .parsers.dcmp_dex.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.dcmp_dex.OptimizeCreateConditionalAssignments # Description : AST optimization: allow condition assignments (using the ternary operator) Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateFinallyBlocks # Description : AST optimization: attempt to create try-(catch,multi-catch)-finally blocks. This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateForLoops # Description : AST optimization: Allow the creation of for-loops Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateMultiDimArrays # Description : AST optimization: allow the creation of multi-dimensional arrays Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateStringSwitches # Description : AST optimization: attempt to create switch-on-strings. This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateSynchronizedBlocks # Description : AST optimization: attempt to create synchronized blocks. This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateVarArgs # Description : AST optimization: support the creation of variable-argument methods Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeInlineSyntheticAccessCalls # Description : AST optimization: Inline calls to accessor (synthetic) methods Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeStringConcatenation # Description : AST optimization: Allow String concatenation Type and Default : Boolean(true) .parsers.dcmp_dex.ParseDebugInformation # Description : Process debug information. If enabled, debug names can be used to name identifiers. Proceed with caution! DEX metadata is not reliable, it can be forged and/or obfuscated to mislead analysis. Type and Default : Boolean(true) .parsers.dcmp_dex.ParseExceptionBlocks # Description : Parse exception blocks Type and Default : Boolean(true) .parsers.dcmp_dex.ReconstructEnums # Description : Discover and rebuild enumerations (and related artifacts such as enumeration-maps). This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.ReconstructLambdas # Description : Discover and rebuild lambdas (and related higher-order artifacts such as method handles). This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.ResolveFieldAccessTargets # Description : Resolve accesses to object and class fields Type and Default : Boolean(true) .parsers.dcmp_dex.ResolveMethodCallTargets # Description : Resolve calls to virtual and static methods, possibly offering a list of candidates methods to client code Type and Default : Boolean(true) .parsers.dcmp_dex.SortItemsForRendering # Description : Sort class, field and method source items before rendering them Type and Default : Selection(1){None(0), Alpha, Access(1)} .parsers.dcmp_dex.SplitCallArgThreshold # Description : Split a method invocation's arguments on single-lines, with parameter details, for methods with more than that number of parameters (does not apply to lambdas). Use 0 to disable splitting. Type and Default : Integer(10) .parsers.dcmp_dex.UseDebugInfoNames # Description : Use names located in DEX debug information (if available) Type and Default : Boolean(true) .parsers.dex.AndroidJavadocRoot # Description : Location of Java/Android API documentation files; by default, local files stored in your Android SDK folder will be preferred over web-based API doc Type and Default : String(\"($ANDROID_HOME/docs|$ANDROID_SDK_HOME/docs|$ANDROID_SDK_ROOT/docs)/reference/;https://developer.android.com/reference/;($JAVA_HOME)/docs/api\") .parsers.dex.ClassSeparatorLength # Description : Length of the class separator line in characters Type and Default : Integer(0){0+} .parsers.dex.DalvikParserMode # Description : The parser mode can be either legacy, art, dex38, dex39, or latest Type and Default : Selection(50){Legacy(0), ART(50), dex 38(100), dex 39(110), Latest(1000)} .parsers.dex.GenerateCatchDirectivesAtMethodEnd # Description : Generate .catch/.catchall directives at the EOM instead of after a try-block Type and Default : Boolean(false) .parsers.dex.JarLibraryClasspath # Description : A classpath containing Java classfiles to be used along with the dex-defined types. Refer to JarLibraryEnabled. If non-empty, this classpath takes precedence over JarLibraryFolder. Type and Default : String(\"\") .parsers.dex.JarLibraryEnabled # Description : Enable external Java library file parsing. This feature can be used for finer type resolution. To activate, enable this property and set either one of JarLibraryClasspath or JarLibraryFolder property. Type and Default : Boolean(true) .parsers.dex.JarLibraryFolder # Description : A folder containing Jar library files to be used along with the dex-defined types. Refer to JarLibraryEnabled. The default value (empty) means to use the folder ~/.jeb-android-libraries, which always contains a recent copy of the Android framework (android.jar). You may change the value to point to another folder, or drop additional jars in this folder.Note that JarLibraryClasspath takes precedence over this value. Type and Default : String(\"\") .parsers.dex.MethodSeparatorLength # Description : Length of the method separator line in characters Type and Default : Integer(0){0+} .parsers.dex.ParseExtendedOpcodes # Description : Support parsing for the extended opcodes Type and Default : Boolean(true) .parsers.dex.ParseOptimizedOpcodes # Description : Support parsing for the optimized opcodes Type and Default : Boolean(true) .parsers.dex.ProvideExtraInfoInCodeNodeLabels # Description : Provide additional information in code node items to client components. Currently, when this option is enabled, method labels for concrete non-native methods are appended with a ' /N' string where N is the instruction count of the method. Type and Default : Boolean(false) .parsers.dex.ProvideFriendlyCodeNodeLabels # Description : Provide user-friendly code node items (non-qualified, non-internal Java names) to client components. Methods and field signatures will be more readable, at the risk of potentially appearing conflicting, esp. on obfuscated samples that heavily reuse names across methods, fields, and types. Type and Default : Boolean(true) .parsers.dex.ShowActualCallsites # Description : Determine and display the actual callsite for method invocations. Automatic inline comments will be added when the determined callsite differ from the method reference. Type and Default : Boolean(true) .parsers.dex.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.dex.ShowAnnotations # Description : Show the DEX annotations Type and Default : Boolean(true) .parsers.dex.ShowBytecode # Description : Display the instruction bytecode Type and Default : Boolean(false) .parsers.dex.ShowDebugDirectives # Description : Show the debug directives (metadata) Type and Default : Boolean(false) .parsers.dex.ShowInstructionsInGaps # Description : Parse byte gaps (slack space or unused data bytes that can be present in a method body) and display those bytes as Dalvik instructions Type and Default : Boolean(false) .parsers.dex.ShowLineNumbers # Description : Show the source line numbers (metadata) Type and Default : Boolean(false) .parsers.dex.ShowOriginalNames # Description : Display the original descriptor names of classes/methods/fields as comments Type and Default : Boolean(false) .parsers.dex.ShowSpaceBetweenBlocks # Description : Insert a blank line between basic blocks Type and Default : Boolean(false) .parsers.dex.SmaliCompatibility # Description : Generate assembly code compatible with Smali Type and Default : Boolean(false) .parsers.dex.UsePForParameters # Description : Use p0,p1,... instead of v0,v1,... for variables Type and Default : Boolean(true) .parsers.dex.VerifyAccessFlags # Description : Fail parsing if the access flags of a class, method, or field appear to be illegal Type and Default : Boolean(false) .parsers.dex.VerifyHashes # Description : Fail parsing if the DEX Adler checksum is not the expected one Type and Default : Boolean(false) .parsers.dex.VerifyVersion # Description : Fail parsing if the DEX version number is not in the range [35, 39] Type and Default : Boolean(false) .parsers.dex.WellKnownLibraryPackages # Description : CSL of packages that will not originally be fully expanded in code hierarchy tree documents. Use * to prevent auto-expansion for all packages. The star wildcard can also be used as a suffix. In practice, the JEB UI client will not auto-expand those packages by default to avoid cluttering the code hierarchy fragment view. Type and Default : String(\"android, androidx, android_src, butterknife, com.airbnb.epoxy, com.airbnb.lottie, com.android, com.facebook, com.fasterxml, com.firebase, com.google, com.ibm, com.microsoft, dagger, io.reactivex, java, javax, kotlin, kotlinx, mono, net, okhttp3, okio, opentk_*, org, retrofit2, xamarin\") .parsers.ihex.BigEndian # Description : Set to true to specify big-endian. The default is little-endian, unless a specific processor setting overrides it. Type and Default : Boolean(false) .parsers.ihex.Processor # Description : Target processor/microcontroller code; refer to processor plugin type names. The default is x86 Type and Default : String(\"x86\") .parsers.ihex.WantedImageBase # Description : Base address hint. Leave empty to let the plugin decide. Type and Default : String(\"\") .parsers.ihex.WantedWordsize # Description : Desired wordsize in bits: 8, 16, 32, etc. Leave empty to let the plugin decide by heuristics Type and Default : String(\"\") .parsers.javaclass.EnableDesugaring # Description : If d8 is the selected converter, enable this option to desugar Java 8+ high-level constructs (such as lambdas) into pseudo-equivalent lower-level constructs. It is recommended to keep this option enabled for large Jar files, since d8 may have problems regenerating call sites and method handles. Type and Default : Boolean(true) .parsers.javaclass.UseD8ForDexConversion # Description : Prefer the d8/r8 compiler over the legacy dx compiler to perform Java bytecode to Dalvik bytecode transpilation Type and Default : Boolean(true) .parsers.native.decomp.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.native.decomp.dcmp_arm.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.dcmp_arm.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_arm.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_arm.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.dcmp_arm.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.dcmp_arm.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.dcmp_arm.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.dcmp_arm.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.dcmp_arm.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.dcmp_arm.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.dcmp_arm.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.dcmp_arm.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.dcmp_arm.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.dcmp_arm.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.native.decomp.dcmp_arm64.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.dcmp_arm64.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_arm64.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_arm64.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.dcmp_arm64.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.dcmp_arm64.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.dcmp_arm64.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.dcmp_arm64.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.dcmp_arm64.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.dcmp_arm64.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.dcmp_arm64.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.dcmp_arm64.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.dcmp_arm64.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.dcmp_arm64.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.native.decomp.dcmp_avr.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.dcmp_avr.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_avr.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_avr.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.dcmp_avr.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.dcmp_avr.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.dcmp_avr.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.dcmp_avr.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.dcmp_avr.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.dcmp_avr.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.dcmp_avr.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.dcmp_avr.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.dcmp_avr.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.dcmp_avr.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.native.decomp.dcmp_diemvm_bc.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.dcmp_diemvm_bc.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_diemvm_bc.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_diemvm_bc.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.dcmp_diemvm_bc.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.dcmp_diemvm_bc.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.dcmp_diemvm_bc.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.dcmp_diemvm_bc.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.dcmp_diemvm_bc.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.dcmp_diemvm_bc.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.dcmp_diemvm_bc.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.dcmp_diemvm_bc.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.dcmp_diemvm_bc.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.dcmp_diemvm_bc.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(false) .parsers.native.decomp.dcmp_evmbc.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.dcmp_evmbc.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_evmbc.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_evmbc.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.dcmp_evmbc.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.dcmp_evmbc.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.dcmp_evmbc.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.dcmp_evmbc.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.dcmp_evmbc.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.dcmp_evmbc.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.dcmp_evmbc.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.dcmp_evmbc.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.dcmp_evmbc.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.dcmp_evmbc.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(false) .parsers.native.decomp.dcmp_mips.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.dcmp_mips.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_mips.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_mips.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.dcmp_mips.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.dcmp_mips.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.dcmp_mips.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.dcmp_mips.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.dcmp_mips.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.dcmp_mips.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.dcmp_mips.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.dcmp_mips.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.dcmp_mips.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.dcmp_mips.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.native.decomp.dcmp_mips64.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.dcmp_mips64.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_mips64.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_mips64.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.dcmp_mips64.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.dcmp_mips64.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.dcmp_mips64.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.dcmp_mips64.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.dcmp_mips64.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.dcmp_mips64.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.dcmp_mips64.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.dcmp_mips64.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.dcmp_mips64.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.dcmp_mips64.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.native.decomp.dcmp_riscv.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.dcmp_riscv.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_riscv.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_riscv.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.dcmp_riscv.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.dcmp_riscv.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.dcmp_riscv.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.dcmp_riscv.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.dcmp_riscv.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.dcmp_riscv.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.dcmp_riscv.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.dcmp_riscv.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.dcmp_riscv.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.dcmp_riscv.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.native.decomp.dcmp_simatic_mc7.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.dcmp_simatic_mc7.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_simatic_mc7.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_simatic_mc7.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.dcmp_simatic_mc7.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.dcmp_simatic_mc7.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.dcmp_simatic_mc7.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.dcmp_simatic_mc7.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.dcmp_simatic_mc7.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.dcmp_simatic_mc7.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.dcmp_simatic_mc7.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.dcmp_simatic_mc7.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.dcmp_simatic_mc7.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.dcmp_simatic_mc7.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.native.decomp.dcmp_wasmbc.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.dcmp_wasmbc.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_wasmbc.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_wasmbc.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.dcmp_wasmbc.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.dcmp_wasmbc.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.dcmp_wasmbc.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.dcmp_wasmbc.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.dcmp_wasmbc.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.dcmp_wasmbc.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.dcmp_wasmbc.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.dcmp_wasmbc.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.dcmp_wasmbc.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.dcmp_wasmbc.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.native.decomp.dcmp_x86.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.dcmp_x86.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_x86.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_x86.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.dcmp_x86.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.dcmp_x86.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.dcmp_x86.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.dcmp_x86.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.dcmp_x86.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.dcmp_x86.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.dcmp_x86.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.dcmp_x86.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.dcmp_x86.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.dcmp_x86.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.native.decomp.dcmp_x86_64.ASTOptimizerMaxRunCount # Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.native.decomp.dcmp_x86_64.EnableDeobfuscators # Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_x86_64.EnableUnsafeOptimizers # Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true) .parsers.native.decomp.dcmp_x86_64.HideCasts # Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false) .parsers.native.decomp.dcmp_x86_64.HideTopLevelNamespaceElements # Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true) .parsers.native.decomp.dcmp_x86_64.IROptimizerMaxRunCount # Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10) .parsers.native.decomp.dcmp_x86_64.MemoryResolutionPolicy # Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3) .parsers.native.decomp.dcmp_x86_64.MergeAdjacentDefinitions # Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true) .parsers.native.decomp.dcmp_x86_64.MethodDecompilationTimeout # Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.native.decomp.dcmp_x86_64.NextDecompKeepIR # Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false) .parsers.native.decomp.dcmp_x86_64.ReconversionMaxCount # Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+} .parsers.native.decomp.dcmp_x86_64.SpaceOutCompounds # Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.native.decomp.dcmp_x86_64.StructurerUseVersion # Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3} .parsers.native.decomp.dcmp_x86_64.UseFriendlyVariableNames # Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.native.disas.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.native.disas.arm.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.arm.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.arm.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.arm.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.arm.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.arm.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.arm.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.arm.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.arm.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.arm.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.arm.DefaultMode # Description : Default plugin mode (ARM or Thumb) Type and Default : Selection(0){Default mode(0), ARM(32), Thumb(16)} .parsers.native.disas.arm.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.arm.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.arm.ForceWideFlag # Description : Wide Flag Display (T32 only) Type and Default : Selection(0){Display All(0), Distinguish 16-bit from 32-bit(1), Display when forced(2)} .parsers.native.disas.arm.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.arm.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.arm.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.arm.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.arm.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.arm.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.arm.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.arm.PerformFakeRoutineCallAnalysis # Description : Search for Branch and Link (BL) instructions that should be considered as simple branches rather than routine calls (Thumb code optimization) Type and Default : Boolean(true) .parsers.native.disas.arm.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.arm.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.arm.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.arm.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.arm.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.arm.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.arm.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.arm.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.arm.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.arm.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.arm.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.arm.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.native.disas.arm64.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.arm64.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.arm64.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.arm64.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.arm64.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.arm64.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.arm64.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.arm64.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.arm64.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.arm64.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.arm64.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.arm64.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.arm64.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.arm64.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.arm64.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.arm64.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.arm64.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.arm64.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.arm64.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.arm64.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.arm64.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.arm64.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.arm64.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.arm64.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.arm64.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.arm64.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.arm64.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.arm64.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.arm64.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.arm64.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.arm64.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.native.disas.avr.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.avr.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.avr.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.avr.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.avr.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.avr.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.avr.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.avr.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.avr.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.avr.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.avr.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.avr.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.avr.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.avr.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.avr.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.avr.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.avr.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.avr.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.avr.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.avr.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.avr.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.avr.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.avr.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.avr.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.avr.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.avr.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.avr.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.avr.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.avr.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.avr.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.avr.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.native.disas.diemvm_bc.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.diemvm_bc.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.diemvm_bc.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.diemvm_bc.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.diemvm_bc.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.diemvm_bc.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.diemvm_bc.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.diemvm_bc.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.diemvm_bc.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.diemvm_bc.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.diemvm_bc.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.diemvm_bc.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.diemvm_bc.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.diemvm_bc.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.diemvm_bc.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.diemvm_bc.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.diemvm_bc.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.diemvm_bc.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.diemvm_bc.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.diemvm_bc.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.diemvm_bc.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.diemvm_bc.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.diemvm_bc.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.diemvm_bc.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.diemvm_bc.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.diemvm_bc.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.diemvm_bc.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.diemvm_bc.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.diemvm_bc.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.diemvm_bc.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.diemvm_bc.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.native.disas.evmbc.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.evmbc.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.evmbc.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.evmbc.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.evmbc.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.evmbc.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.evmbc.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.evmbc.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.evmbc.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.evmbc.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.evmbc.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.evmbc.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.evmbc.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.evmbc.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.evmbc.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.evmbc.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.evmbc.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.evmbc.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.evmbc.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.evmbc.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.evmbc.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.evmbc.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.evmbc.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.evmbc.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.evmbc.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.evmbc.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.evmbc.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.evmbc.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.evmbc.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.evmbc.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.evmbc.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.native.disas.mips.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.mips.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.mips.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.mips.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.mips.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.mips.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.mips.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.mips.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.mips.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.mips.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.mips.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.mips.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.mips.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.mips.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.mips.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.mips.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.mips.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.mips.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.mips.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.mips.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.mips.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.mips.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.mips.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.mips.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.mips.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.mips.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.mips.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.mips.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.mips.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.mips.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.mips.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.native.disas.mips64.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.mips64.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.mips64.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.mips64.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.mips64.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.mips64.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.mips64.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.mips64.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.mips64.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.mips64.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.mips64.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.mips64.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.mips64.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.mips64.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.mips64.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.mips64.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.mips64.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.mips64.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.mips64.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.mips64.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.mips64.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.mips64.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.mips64.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.mips64.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.mips64.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.mips64.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.mips64.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.mips64.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.mips64.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.mips64.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.mips64.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.native.disas.riscv.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.riscv.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.riscv.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.riscv.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.riscv.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.riscv.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.riscv.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.riscv.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.riscv.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.riscv.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.riscv.DisplayAbiRegisterNames # Description : Use abi (standard calling convention) registers instead of xN/fN Type and Default : Boolean(true) .parsers.native.disas.riscv.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.riscv.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.riscv.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.riscv.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.riscv.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.riscv.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.riscv.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.riscv.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.riscv.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.riscv.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.riscv.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.riscv.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.riscv.RenderJRX1AsRet # Description : Render 'JR X1 / JR LR' as 'RET' pseudo-instructions Type and Default : Boolean(false) .parsers.native.disas.riscv.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.riscv.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.riscv.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.riscv.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.riscv.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.riscv.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.riscv.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.riscv.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.riscv.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.native.disas.simatic_mc7.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.simatic_mc7.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.simatic_mc7.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.simatic_mc7.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.simatic_mc7.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.simatic_mc7.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.simatic_mc7.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.simatic_mc7.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.simatic_mc7.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.simatic_mc7.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.simatic_mc7.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.simatic_mc7.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.simatic_mc7.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.simatic_mc7.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.simatic_mc7.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.simatic_mc7.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.simatic_mc7.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.simatic_mc7.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.simatic_mc7.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.simatic_mc7.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.simatic_mc7.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.simatic_mc7.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.simatic_mc7.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.simatic_mc7.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.simatic_mc7.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.simatic_mc7.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.simatic_mc7.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.simatic_mc7.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.simatic_mc7.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.simatic_mc7.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.simatic_mc7.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.native.disas.wasmbc.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.wasmbc.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.wasmbc.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.wasmbc.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.wasmbc.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.wasmbc.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.wasmbc.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.wasmbc.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.wasmbc.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.wasmbc.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.wasmbc.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.wasmbc.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.wasmbc.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.wasmbc.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.wasmbc.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.wasmbc.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.wasmbc.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.wasmbc.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.wasmbc.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.wasmbc.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.wasmbc.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.wasmbc.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.wasmbc.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.wasmbc.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.wasmbc.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.wasmbc.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.wasmbc.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.wasmbc.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.wasmbc.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.wasmbc.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.wasmbc.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.native.disas.x86.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.x86.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.x86.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.x86.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.x86.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.x86.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.x86.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.x86.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.x86.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.x86.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.x86.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.x86.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.x86.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.x86.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.x86.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.x86.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.x86.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.x86.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.x86.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.x86.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.x86.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.x86.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.x86.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.x86.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.x86.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.x86.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.x86.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.x86.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.x86.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.x86.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.x86.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.native.disas.x86_64.AdvancedAnalysis # Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)} .parsers.native.disas.x86_64.AnalysisStyle # Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)} .parsers.native.disas.x86_64.ApplyAndroidNativePrototypes # Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true) .parsers.native.disas.x86_64.BlockXrefsCount # Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.native.disas.x86_64.CallingConvention # Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)} .parsers.native.disas.x86_64.CharBreak64BitAddresses # Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.native.disas.x86_64.CompilerIdentification # Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)} .parsers.native.disas.x86_64.CreatePackagesFromRoutineNames # Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true) .parsers.native.disas.x86_64.DebugInformationRetrievalPolicy # Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)} .parsers.native.disas.x86_64.DebugInformationUsagePolicy # Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)} .parsers.native.disas.x86_64.Endianness # Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)} .parsers.native.disas.x86_64.ForceSynchronousAnalysis # Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)} .parsers.native.disas.x86_64.GapPreferRawFormatting # Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false) .parsers.native.disas.x86_64.GapRawBytesPerLine # Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.native.disas.x86_64.GapRawIntegerSize # Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.native.disas.x86_64.ImageBase # Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\") .parsers.native.disas.x86_64.InstructionAreaLength # Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.native.disas.x86_64.LabelAreaLength # Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.native.disas.x86_64.LoadTypeLibrariesCodelessSigs # Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true) .parsers.native.disas.x86_64.PerformGlobalAnalysis # Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.native.disas.x86_64.PerformRttiRecovery # Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true) .parsers.native.disas.x86_64.RelocationBaseForZeroBasedRelocatableObjects # Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\") .parsers.native.disas.x86_64.RoutineSeparatorLength # Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.native.disas.x86_64.ShowAddresses # Description : Display addresses of items Type and Default : Boolean(true) .parsers.native.disas.x86_64.ShowBytesCount # Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.native.disas.x86_64.ShowSegmentHeaders # Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.native.disas.x86_64.ShowSpaceBetweenBlocks # Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.native.disas.x86_64.SignaturePackagesLoading # Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)} .parsers.native.disas.x86_64.SwitchAnalysisStyle # Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.x86_64.TailCallAnalysisStyle # Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)} .parsers.native.disas.x86_64.UseTypeLibraries # Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true) .parsers.simatic_s7.AugmentDisassembly # Description : Augment the disassembly whenever possible, e.g. replace opaque parameter addressing with structure information. Type and Default : Boolean(true) .parsers.simatic_s7.DisassembleCode # Description : Disassemble the MC7 code contained in logic blocks (OB, FC, FB, SFC, SFB) Type and Default : Boolean(true) .parsers.simatic_s7.GenerateInterfaceDescriptionUnits # Description : Generate additional text units describing interfaces for logic blocks and data blocks Type and Default : Boolean(true) .parsers.simatic_s7.MapActualBytesForDataBlocks # Description : For data blocks, prefer mapping the actual (current values) bytes insteal of the default (initial values). Type and Default : Boolean(true) .parsers.simatic_s7.MapRawBlocksAtZero # Description : Map the raw bytes of S7 blocks at the beginning of the image (address 0) Type and Default : Boolean(false) .project.AlwaysProcessDuplicateInputs # Description : Process binary inputs even if such input was seen earlier and processed as another unit already Type and Default : Boolean(false) .project.ArtifactProcessingDepth # Description : Determine the maximum depth an input artifact (e.g., a file) will be explored to create units and sub-units representing analysis entities Type and Default : Integer(20){1+} .project.CompressPersistedProject # Description : Compress the JDB2 database (recommended) Type and Default : Boolean(true) .project.PersistArtifactFiles # Description : Persist the full artifact files in a JDB2 database. The resulting JDB2 file will be larger since the input files are embedded in it for extra safety. Type and Default : Boolean(true) .project.PersistenceStrategy # Description : Determine how a project will be saved to JDB2 Type and Default : Selection(0){Automatic(0), Full save(1), Quick save(2)}","title":"Engines Configuration"},{"location":"engines-configuration.html#codelesssigsfolder","text":"Description : Folder containing codeless signature libraries Type and Default : Path(\"$JEB_HOME/siglibs/codeless\")","title":".CodelessSigsFolder"},{"location":"engines-configuration.html#customnotprintablecharacterranges","text":"Description : Ranges of characters that should be escaped, i.e. not considered printable (customization of Formatter.isPrintableChar). Formatted as a CSL of UTF-16 ranges: xxxx-xxxx,xxxx-xxxx,... Type and Default : String(\"\")","title":".CustomNotPrintableCharacterRanges"},{"location":"engines-configuration.html#customprintablecharacterranges","text":"Description : Ranges of characters that should be considered printable, i.e. not be escaped (customization of Formatter.isPrintableChar). Formatted as a CSL of UTF-16 ranges: xxxx-xxxx,xxxx-xxxx,... Type and Default : String(\"\")","title":".CustomPrintableCharacterRanges"},{"location":"engines-configuration.html#databasebackupbeforesave","text":"Description : Before saving a project to a JDB2 database, the current database is copied to the %TEMP% folder and will be used as backup in case any problem happen during saving. Type and Default : Boolean(true)","title":".DatabaseBackupBeforeSave"},{"location":"engines-configuration.html#devpluginclassnames","text":"Description : Classnames of your in-development plugin entry-point classes (they are not JARs) Type and Default : String(\"\")","title":".DevPluginClassnames"},{"location":"engines-configuration.html#devpluginclasspath","text":"Description : Classpath for your in-development plugins (they are not JARs) Type and Default : String(\"\")","title":".DevPluginClasspath"},{"location":"engines-configuration.html#flattenstringsincodedocuments","text":"Description : This global setting instructs code document generators (e.g., generating assembly or source code) to 'flatten' the strings before rendering. This means that all code tokens will be partially escaped as a means to ensure proper rendering of obfuscated names, regardless of the typeface or system in-use. Type and Default : Boolean(false)","title":".FlattenStringsInCodeDocuments"},{"location":"engines-configuration.html#loadpythonplugins","text":"Description : Specify whether or not JEB back-end plugins written in Python are allowed and should be loaded. When this option is enabled, Python script plugins located in the plugins folder 'scripts' subdirectory (typically, coreplugins/scripts) can be loaded and instantiated by back-end components. Type and Default : Boolean(false)","title":".LoadPythonPlugins"},{"location":"engines-configuration.html#networkproxy","text":"Description : Proxy settings for JEB back-end components. The format of this property is: 'type|hostname|port|user|pass|whitelist' type can be direct (no proxy), http, or socks hostname and port are mandatory for non-direct proxy types user and password are optional (needed only if your proxy requires authentication) whitelist is an optional list of domains/IPs (with support for the wildcard character *) for which no proxy connection should be used (always direct connect) Type and Default : String(\"\")","title":".NetworkProxy"},{"location":"engines-configuration.html#pluginsfolder","text":"Description : Location of the JEB back-end plugins folder Type and Default : String(\"$JEB_HOME/coreplugins\")","title":".PluginsFolder"},{"location":"engines-configuration.html#siglibsfolder","text":"Description : Folder containing native code signature libraries Type and Default : Path(\"$JEB_HOME/siglibs\")","title":".SiglibsFolder"},{"location":"engines-configuration.html#typelibsfolder","text":"Description : Folder containing native type libraries Type and Default : Path(\"$JEB_HOME/typelibs\")","title":".TypelibsFolder"},{"location":"engines-configuration.html#parsersenforceversionchecks","text":"Description : Verify and enforce plugins requirements. E.g. if enabled, a plugin requiring JEB version 2.3.10 to 3.0.7 will not be loaded if JEB is older than 2.3.10 or newer than 3.0.7 Type and Default : Boolean(true)","title":".parsers.EnforceVersionChecks"},{"location":"engines-configuration.html#parsersapkandroidjavadocroot","text":"Description : Location of Java and Android API documentation files. By default, local files stored in the Android SDK folder will be preferred over web-based API doc Type and Default : String(\"($ANDROID_HOME/docs|$ANDROID_SDK_HOME/docs|$ANDROID_SDK_ROOT/docs)/reference/;https://developer.android.com/reference/;($JAVA_HOME)/docs/api\")","title":".parsers.apk.AndroidJavadocRoot"},{"location":"engines-configuration.html#parsersapkarscrestructuringmode","text":"Description : Restructuring mode for decoded resource files. This option permits the deobfuscation of obfuscated arsc entries. Type and Default : Selection(3){None(0), Basic(1), Move(2), Move and Rename(3)}","title":".parsers.apk.ArscRestructuringMode"},{"location":"engines-configuration.html#parsersapkdisableassetsprocessingthreshold","text":"Description : The plugin will suggest disabling the auto-processing of APK assets if the number of asset files exceed that threshold (0 to disable) Type and Default : Integer(300){0+}","title":".parsers.apk.DisableAssetsProcessingThreshold"},{"location":"engines-configuration.html#parsersapkdisableresourcesprocessingthreshold","text":"Description : The plugin will suggest disabling the auto-processing of APK resources if the number of resource files exceed that threshold (0 to disable) Type and Default : Integer(500){0+}","title":".parsers.apk.DisableResourcesProcessingThreshold"},{"location":"engines-configuration.html#parsersapkframeworksdirectory","text":"Description : Directory containing additional frameworks. Leave empty to use the default, which is the \".jeb-android-frameworks\" directory in the Home folder Type and Default : Path(\"\")","title":".parsers.apk.FrameworksDirectory"},{"location":"engines-configuration.html#parsersapkgenerateaapt2output","text":"Description : Generate an additional text fragment that will describe the APK resources similarly to AAPT2's output Type and Default : Boolean(false)","title":".parsers.apk.GenerateAapt2Output"},{"location":"engines-configuration.html#parsersapkmergemultidex","text":"Description : Merge the DEX files of a multi-DEX APK into a single, unified DEX unit Type and Default : Boolean(true)","title":".parsers.apk.MergeMultiDex"},{"location":"engines-configuration.html#parsersapkprocessassets","text":"Description : Process unstructured resources stored in the APK's assets/ directory Type and Default : Boolean(true)","title":".parsers.apk.ProcessAssets"},{"location":"engines-configuration.html#parsersapkprocessbytecode","text":"Description : Process the Dalvik bytecode (classes[N].dex) Type and Default : Boolean(true)","title":".parsers.apk.ProcessBytecode"},{"location":"engines-configuration.html#parsersapkprocesscertificates","text":"Description : Process the APK's certificates data (legacy, v1, v2, v3) Type and Default : Boolean(true)","title":".parsers.apk.ProcessCertificates"},{"location":"engines-configuration.html#parsersapkprocesslibraries","text":"Description : Process native code (.so) libraries stored in the APK's lib/ directory Type and Default : Boolean(true)","title":".parsers.apk.ProcessLibraries"},{"location":"engines-configuration.html#parsersapkprocessmanifest","text":"Description : Decode and process the APK Manifest Type and Default : Boolean(true)","title":".parsers.apk.ProcessManifest"},{"location":"engines-configuration.html#parsersapkprocessresources","text":"Description : Decode and process the Resources (if this option is true, the Manifest is always processed) Type and Default : Boolean(true)","title":".parsers.apk.ProcessResources"},{"location":"engines-configuration.html#parsersdbug_apkattachportrangesize","text":"Description : Number of ports to try after the preferred port if the preferred port is in useby another program Type and Default : Integer(20){1-100}","title":".parsers.dbug_apk.AttachPortRangeSize"},{"location":"engines-configuration.html#parsersdbug_apkattachportrangestart","text":"Description : Preferred TCP port to use and listen to when attaching to the JDWP debugger Type and Default : Integer(8900){1024-65535}","title":".parsers.dbug_apk.AttachPortRangeStart"},{"location":"engines-configuration.html#parsersdbug_apkblockingquerytimeoutseconds","text":"Description : Maximum time in seconds to wait for a response from the debugger server Type and Default : Integer(15){0+}","title":".parsers.dbug_apk.BlockingQueryTimeoutSeconds"},{"location":"engines-configuration.html#parsersdbug_apknativeattachportrangesize","text":"Description : Number of ports to try after the preferred port if the preferred port is in useby another program Type and Default : Integer(20){1-100}","title":".parsers.dbug_apk.NativeAttachPortRangeSize"},{"location":"engines-configuration.html#parsersdbug_apknativeattachportrangestart","text":"Description : Preferred TCP port to use and listen to when attaching to the native debugger Type and Default : Integer(8950){1024-65535}","title":".parsers.dbug_apk.NativeAttachPortRangeStart"},{"location":"engines-configuration.html#parsersdbug_apkpreferlldbserver","text":"Description : Prefer the use of LLDB server over GDB server for debugging native Android code. Type and Default : Boolean(true)","title":".parsers.dbug_apk.PreferLldbserver"},{"location":"engines-configuration.html#parsersdbug_apkpreferredgdbserverversion","text":"Description : Preferred GDB server version to use. JEB does not ship with all versions of GDB server for all platforms. See the core/assets/ folder in your jeb.jar software archive.It is recommended to use the default. Type and Default : String(\"\")","title":".parsers.dbug_apk.PreferredGdbserverVersion"},{"location":"engines-configuration.html#parsersdbug_apkpreferredlldbserverversion","text":"Description : Preferred LLDB server version to use. JEB does not ship with all versions of LLDB server for all platforms. See the core/assets/ folder in your jeb.jar software archive.It is recommended to use the default. Type and Default : String(\"\")","title":".parsers.dbug_apk.PreferredLldbserverVersion"},{"location":"engines-configuration.html#parsersdbug_elfblockingquerytimeoutseconds","text":"Description : Maximum time in seconds to wait for a response from the debugger server Type and Default : Integer(15){0+}","title":".parsers.dbug_elf.BlockingQueryTimeoutSeconds"},{"location":"engines-configuration.html#parsersdcmp_dexdecompiletoplevelcontainerclass","text":"Description : When requesting a decompilation at a particular location A, determine the top-level non-inner class at A, and decompile that class and all its constituents (methods, inners, etc.). If this option is disabled, precise decompilation will be performed: the requested address will not be reinterpreted, and only the target object will be decompiled. Example: decompiling while on a method F's bytecode will decompile F and F only (not its container class, not its inners, etc.). Type and Default : Boolean(true)","title":".parsers.dcmp_dex.DecompileTopLevelContainerClass"},{"location":"engines-configuration.html#parsersdcmp_dexdisplayastelementstackonhover","text":"Description : Display the parent and ancestors of a decompiled Java AST node when the mouse cursor hovers over it (useful to debug or troubleshoot a script) Type and Default : Boolean(true)","title":".parsers.dcmp_dex.DisplayASTElementStackOnHover"},{"location":"engines-configuration.html#parsersdcmp_dexdisplaymethodinternalsascomment","text":"Description : When rendering source, prepend method internals as a comment block before rendering the method Type and Default : Selection(0){None(0), Signature(1), Signature, AST(2)}","title":".parsers.dcmp_dex.DisplayMethodInternalsAsComment"},{"location":"engines-configuration.html#parsersdcmp_dexdisplayprivatemethodslast","text":"Description : Output private methods last (after public, default and protected methods) Type and Default : Boolean(false)","title":".parsers.dcmp_dex.DisplayPrivateMethodsLast"},{"location":"engines-configuration.html#parsersdcmp_dexemulationsupport","text":"Description : Support for emulation, allowing optimizers to perform complex code cleaning such as decryption Type and Default : Selection(2){Disabled(0), Enabled with Confirmation(1), Enabled(2)}","title":".parsers.dcmp_dex.EmulationSupport"},{"location":"engines-configuration.html#parsersdcmp_dexemulatorconfigpath","text":"Description : Path to the emulator configuration file. If the path is relative, the configuration file will be searched in JEB's plugins directory (usually, coreplugins/). Type and Default : Path(\"dexdec-emu.cfg\")","title":".parsers.dcmp_dex.EmulatorConfigPath"},{"location":"engines-configuration.html#parsersdcmp_dexenablecfunflattener","text":"Description : Enable control-flow unflattening. The obfuscators must be enabled. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.EnableCFUnflattener"},{"location":"engines-configuration.html#parsersdcmp_dexenablecacheforstringdecryption","text":"Description : The emulation cache is used to store and reuse the results of select, previously emulated invocations. It works using heuristics, and is theoretically unsafe (a cached entry may be incorrect). In the general case, it is relatively safe to use and should speed up emulation results. If problems show up on a specific file/method, disable it and attempt a redecompilation. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.EnableCacheForStringDecryption"},{"location":"engines-configuration.html#parsersdcmp_dexenabledeobfuscators","text":"Description : Enable unsafe deobfuscation optimizers. Those aggressive optimizers can generate code radically different than the underlying bytecode. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersdcmp_dexenableexternalplugins","text":"Description : Enable external plugins, such as customized IR optimizers. If this option is disabled, user-made java/python plugins will not be integrated to dexdec. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.EnableExternalPlugins"},{"location":"engines-configuration.html#parsersdcmp_dexenableunvirtualizer","text":"Description : Enable unvirtualization of methods and classes protected by a VM. The obfuscators must be enabled, and your license must support this option. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.EnableUnvirtualizer"},{"location":"engines-configuration.html#parsersdcmp_dexgenerateannotations","text":"Description : Generate Java annotations Type and Default : Boolean(true)","title":".parsers.dcmp_dex.GenerateAnnotations"},{"location":"engines-configuration.html#parsersdcmp_dexgeneratelambdas","text":"Description : Favor the generation of lambda functions (Java 8+) if possible. Lambdas must have been reconstructed (engines option) Type and Default : Boolean(true)","title":".parsers.dcmp_dex.GenerateLambdas"},{"location":"engines-configuration.html#parsersdcmp_dexgenerateoverrideannotations","text":"Description : Geneate additional @Override annotations for methods for which super implementations or definitions were found Type and Default : Boolean(true)","title":".parsers.dcmp_dex.GenerateOverrideAnnotations"},{"location":"engines-configuration.html#parsersdcmp_dexgeneratesyntheticfields","text":"Description : Explicitly generate synthetic fields Type and Default : Boolean(false)","title":".parsers.dcmp_dex.GenerateSyntheticFields"},{"location":"engines-configuration.html#parsersdcmp_dexgeneratesyntheticmethods","text":"Description : Explicitly generate synthetic methods Type and Default : Boolean(false)","title":".parsers.dcmp_dex.GenerateSyntheticMethods"},{"location":"engines-configuration.html#parsersdcmp_dexidentifiernamingstrategy","text":"Description : Naming strategy for the identifiers Type and Default : Selection(0){Register-based(0), Type-based(1)}","title":".parsers.dcmp_dex.IdentifierNamingStrategy"},{"location":"engines-configuration.html#parsersdcmp_dexinsertblanklinesaftercompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_dex.InsertBlankLinesAfterCompounds"},{"location":"engines-configuration.html#parsersdcmp_dexlistofdisabledexternalplugins","text":"Description : Comma-separated list of names of decompiler plugins that must be disabled (by default, a plugin is enabled) Type and Default : String(\"\")","title":".parsers.dcmp_dex.ListOfDisabledExternalPlugins"},{"location":"engines-configuration.html#parsersdcmp_dexmethoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.dcmp_dex.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreateconditionalassignments","text":"Description : AST optimization: allow condition assignments (using the ternary operator) Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateConditionalAssignments"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatefinallyblocks","text":"Description : AST optimization: attempt to create try-(catch,multi-catch)-finally blocks. This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateFinallyBlocks"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreateforloops","text":"Description : AST optimization: Allow the creation of for-loops Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateForLoops"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatemultidimarrays","text":"Description : AST optimization: allow the creation of multi-dimensional arrays Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateMultiDimArrays"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatestringswitches","text":"Description : AST optimization: attempt to create switch-on-strings. This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateStringSwitches"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatesynchronizedblocks","text":"Description : AST optimization: attempt to create synchronized blocks. This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateSynchronizedBlocks"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatevarargs","text":"Description : AST optimization: support the creation of variable-argument methods Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateVarArgs"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizeinlinesyntheticaccesscalls","text":"Description : AST optimization: Inline calls to accessor (synthetic) methods Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeInlineSyntheticAccessCalls"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizestringconcatenation","text":"Description : AST optimization: Allow String concatenation Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeStringConcatenation"},{"location":"engines-configuration.html#parsersdcmp_dexparsedebuginformation","text":"Description : Process debug information. If enabled, debug names can be used to name identifiers. Proceed with caution! DEX metadata is not reliable, it can be forged and/or obfuscated to mislead analysis. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.ParseDebugInformation"},{"location":"engines-configuration.html#parsersdcmp_dexparseexceptionblocks","text":"Description : Parse exception blocks Type and Default : Boolean(true)","title":".parsers.dcmp_dex.ParseExceptionBlocks"},{"location":"engines-configuration.html#parsersdcmp_dexreconstructenums","text":"Description : Discover and rebuild enumerations (and related artifacts such as enumeration-maps). This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.ReconstructEnums"},{"location":"engines-configuration.html#parsersdcmp_dexreconstructlambdas","text":"Description : Discover and rebuild lambdas (and related higher-order artifacts such as method handles). This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.ReconstructLambdas"},{"location":"engines-configuration.html#parsersdcmp_dexresolvefieldaccesstargets","text":"Description : Resolve accesses to object and class fields Type and Default : Boolean(true)","title":".parsers.dcmp_dex.ResolveFieldAccessTargets"},{"location":"engines-configuration.html#parsersdcmp_dexresolvemethodcalltargets","text":"Description : Resolve calls to virtual and static methods, possibly offering a list of candidates methods to client code Type and Default : Boolean(true)","title":".parsers.dcmp_dex.ResolveMethodCallTargets"},{"location":"engines-configuration.html#parsersdcmp_dexsortitemsforrendering","text":"Description : Sort class, field and method source items before rendering them Type and Default : Selection(1){None(0), Alpha, Access(1)}","title":".parsers.dcmp_dex.SortItemsForRendering"},{"location":"engines-configuration.html#parsersdcmp_dexsplitcallargthreshold","text":"Description : Split a method invocation's arguments on single-lines, with parameter details, for methods with more than that number of parameters (does not apply to lambdas). Use 0 to disable splitting. Type and Default : Integer(10)","title":".parsers.dcmp_dex.SplitCallArgThreshold"},{"location":"engines-configuration.html#parsersdcmp_dexusedebuginfonames","text":"Description : Use names located in DEX debug information (if available) Type and Default : Boolean(true)","title":".parsers.dcmp_dex.UseDebugInfoNames"},{"location":"engines-configuration.html#parsersdexandroidjavadocroot","text":"Description : Location of Java/Android API documentation files; by default, local files stored in your Android SDK folder will be preferred over web-based API doc Type and Default : String(\"($ANDROID_HOME/docs|$ANDROID_SDK_HOME/docs|$ANDROID_SDK_ROOT/docs)/reference/;https://developer.android.com/reference/;($JAVA_HOME)/docs/api\")","title":".parsers.dex.AndroidJavadocRoot"},{"location":"engines-configuration.html#parsersdexclassseparatorlength","text":"Description : Length of the class separator line in characters Type and Default : Integer(0){0+}","title":".parsers.dex.ClassSeparatorLength"},{"location":"engines-configuration.html#parsersdexdalvikparsermode","text":"Description : The parser mode can be either legacy, art, dex38, dex39, or latest Type and Default : Selection(50){Legacy(0), ART(50), dex 38(100), dex 39(110), Latest(1000)}","title":".parsers.dex.DalvikParserMode"},{"location":"engines-configuration.html#parsersdexgeneratecatchdirectivesatmethodend","text":"Description : Generate .catch/.catchall directives at the EOM instead of after a try-block Type and Default : Boolean(false)","title":".parsers.dex.GenerateCatchDirectivesAtMethodEnd"},{"location":"engines-configuration.html#parsersdexjarlibraryclasspath","text":"Description : A classpath containing Java classfiles to be used along with the dex-defined types. Refer to JarLibraryEnabled. If non-empty, this classpath takes precedence over JarLibraryFolder. Type and Default : String(\"\")","title":".parsers.dex.JarLibraryClasspath"},{"location":"engines-configuration.html#parsersdexjarlibraryenabled","text":"Description : Enable external Java library file parsing. This feature can be used for finer type resolution. To activate, enable this property and set either one of JarLibraryClasspath or JarLibraryFolder property. Type and Default : Boolean(true)","title":".parsers.dex.JarLibraryEnabled"},{"location":"engines-configuration.html#parsersdexjarlibraryfolder","text":"Description : A folder containing Jar library files to be used along with the dex-defined types. Refer to JarLibraryEnabled. The default value (empty) means to use the folder ~/.jeb-android-libraries, which always contains a recent copy of the Android framework (android.jar). You may change the value to point to another folder, or drop additional jars in this folder.Note that JarLibraryClasspath takes precedence over this value. Type and Default : String(\"\")","title":".parsers.dex.JarLibraryFolder"},{"location":"engines-configuration.html#parsersdexmethodseparatorlength","text":"Description : Length of the method separator line in characters Type and Default : Integer(0){0+}","title":".parsers.dex.MethodSeparatorLength"},{"location":"engines-configuration.html#parsersdexparseextendedopcodes","text":"Description : Support parsing for the extended opcodes Type and Default : Boolean(true)","title":".parsers.dex.ParseExtendedOpcodes"},{"location":"engines-configuration.html#parsersdexparseoptimizedopcodes","text":"Description : Support parsing for the optimized opcodes Type and Default : Boolean(true)","title":".parsers.dex.ParseOptimizedOpcodes"},{"location":"engines-configuration.html#parsersdexprovideextrainfoincodenodelabels","text":"Description : Provide additional information in code node items to client components. Currently, when this option is enabled, method labels for concrete non-native methods are appended with a ' /N' string where N is the instruction count of the method. Type and Default : Boolean(false)","title":".parsers.dex.ProvideExtraInfoInCodeNodeLabels"},{"location":"engines-configuration.html#parsersdexprovidefriendlycodenodelabels","text":"Description : Provide user-friendly code node items (non-qualified, non-internal Java names) to client components. Methods and field signatures will be more readable, at the risk of potentially appearing conflicting, esp. on obfuscated samples that heavily reuse names across methods, fields, and types. Type and Default : Boolean(true)","title":".parsers.dex.ProvideFriendlyCodeNodeLabels"},{"location":"engines-configuration.html#parsersdexshowactualcallsites","text":"Description : Determine and display the actual callsite for method invocations. Automatic inline comments will be added when the determined callsite differ from the method reference. Type and Default : Boolean(true)","title":".parsers.dex.ShowActualCallsites"},{"location":"engines-configuration.html#parsersdexshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.dex.ShowAddresses"},{"location":"engines-configuration.html#parsersdexshowannotations","text":"Description : Show the DEX annotations Type and Default : Boolean(true)","title":".parsers.dex.ShowAnnotations"},{"location":"engines-configuration.html#parsersdexshowbytecode","text":"Description : Display the instruction bytecode Type and Default : Boolean(false)","title":".parsers.dex.ShowBytecode"},{"location":"engines-configuration.html#parsersdexshowdebugdirectives","text":"Description : Show the debug directives (metadata) Type and Default : Boolean(false)","title":".parsers.dex.ShowDebugDirectives"},{"location":"engines-configuration.html#parsersdexshowinstructionsingaps","text":"Description : Parse byte gaps (slack space or unused data bytes that can be present in a method body) and display those bytes as Dalvik instructions Type and Default : Boolean(false)","title":".parsers.dex.ShowInstructionsInGaps"},{"location":"engines-configuration.html#parsersdexshowlinenumbers","text":"Description : Show the source line numbers (metadata) Type and Default : Boolean(false)","title":".parsers.dex.ShowLineNumbers"},{"location":"engines-configuration.html#parsersdexshoworiginalnames","text":"Description : Display the original descriptor names of classes/methods/fields as comments Type and Default : Boolean(false)","title":".parsers.dex.ShowOriginalNames"},{"location":"engines-configuration.html#parsersdexshowspacebetweenblocks","text":"Description : Insert a blank line between basic blocks Type and Default : Boolean(false)","title":".parsers.dex.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersdexsmalicompatibility","text":"Description : Generate assembly code compatible with Smali Type and Default : Boolean(false)","title":".parsers.dex.SmaliCompatibility"},{"location":"engines-configuration.html#parsersdexusepforparameters","text":"Description : Use p0,p1,... instead of v0,v1,... for variables Type and Default : Boolean(true)","title":".parsers.dex.UsePForParameters"},{"location":"engines-configuration.html#parsersdexverifyaccessflags","text":"Description : Fail parsing if the access flags of a class, method, or field appear to be illegal Type and Default : Boolean(false)","title":".parsers.dex.VerifyAccessFlags"},{"location":"engines-configuration.html#parsersdexverifyhashes","text":"Description : Fail parsing if the DEX Adler checksum is not the expected one Type and Default : Boolean(false)","title":".parsers.dex.VerifyHashes"},{"location":"engines-configuration.html#parsersdexverifyversion","text":"Description : Fail parsing if the DEX version number is not in the range [35, 39] Type and Default : Boolean(false)","title":".parsers.dex.VerifyVersion"},{"location":"engines-configuration.html#parsersdexwellknownlibrarypackages","text":"Description : CSL of packages that will not originally be fully expanded in code hierarchy tree documents. Use * to prevent auto-expansion for all packages. The star wildcard can also be used as a suffix. In practice, the JEB UI client will not auto-expand those packages by default to avoid cluttering the code hierarchy fragment view. Type and Default : String(\"android, androidx, android_src, butterknife, com.airbnb.epoxy, com.airbnb.lottie, com.android, com.facebook, com.fasterxml, com.firebase, com.google, com.ibm, com.microsoft, dagger, io.reactivex, java, javax, kotlin, kotlinx, mono, net, okhttp3, okio, opentk_*, org, retrofit2, xamarin\")","title":".parsers.dex.WellKnownLibraryPackages"},{"location":"engines-configuration.html#parsersihexbigendian","text":"Description : Set to true to specify big-endian. The default is little-endian, unless a specific processor setting overrides it. Type and Default : Boolean(false)","title":".parsers.ihex.BigEndian"},{"location":"engines-configuration.html#parsersihexprocessor","text":"Description : Target processor/microcontroller code; refer to processor plugin type names. The default is x86 Type and Default : String(\"x86\")","title":".parsers.ihex.Processor"},{"location":"engines-configuration.html#parsersihexwantedimagebase","text":"Description : Base address hint. Leave empty to let the plugin decide. Type and Default : String(\"\")","title":".parsers.ihex.WantedImageBase"},{"location":"engines-configuration.html#parsersihexwantedwordsize","text":"Description : Desired wordsize in bits: 8, 16, 32, etc. Leave empty to let the plugin decide by heuristics Type and Default : String(\"\")","title":".parsers.ihex.WantedWordsize"},{"location":"engines-configuration.html#parsersjavaclassenabledesugaring","text":"Description : If d8 is the selected converter, enable this option to desugar Java 8+ high-level constructs (such as lambdas) into pseudo-equivalent lower-level constructs. It is recommended to keep this option enabled for large Jar files, since d8 may have problems regenerating call sites and method handles. Type and Default : Boolean(true)","title":".parsers.javaclass.EnableDesugaring"},{"location":"engines-configuration.html#parsersjavaclassused8fordexconversion","text":"Description : Prefer the d8/r8 compiler over the legacy dx compiler to perform Java bytecode to Dalvik bytecode transpilation Type and Default : Boolean(true)","title":".parsers.javaclass.UseD8ForDexConversion"},{"location":"engines-configuration.html#parsersnativedecompastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompenabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompenableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecomphidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.HideCasts"},{"location":"engines-configuration.html#parsersnativedecomphidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompiroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompmethoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompnextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.native.decomp.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.dcmp_arm.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armenabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_arm.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armenableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_arm.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armhidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_arm.HideCasts"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armhidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_arm.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armiroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.dcmp_arm.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.dcmp_arm.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_arm.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armmethoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.dcmp_arm.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armnextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_arm.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.dcmp_arm.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_arm.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.dcmp_arm.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompdcmp_armusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_arm.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.dcmp_arm64.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64enabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_arm64.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64enableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_arm64.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64hidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_arm64.HideCasts"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64hidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_arm64.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.dcmp_arm64.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.dcmp_arm64.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64mergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_arm64.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64methoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.dcmp_arm64.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64nextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_arm64.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.dcmp_arm64.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64spaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_arm64.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.dcmp_arm64.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompdcmp_arm64usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_arm64.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.dcmp_avr.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrenabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_avr.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrenableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_avr.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrhidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_avr.HideCasts"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrhidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_avr.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avriroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.dcmp_avr.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.dcmp_avr.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_avr.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrmethoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.dcmp_avr.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrnextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_avr.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.dcmp_avr.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_avr.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.dcmp_avr.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompdcmp_avrusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_avr.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bcastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.dcmp_diemvm_bc.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bcenabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_diemvm_bc.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bcenableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_diemvm_bc.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bchidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_diemvm_bc.HideCasts"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bchidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_diemvm_bc.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bciroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.dcmp_diemvm_bc.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bcmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.dcmp_diemvm_bc.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bcmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_diemvm_bc.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bcmethoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.dcmp_diemvm_bc.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bcnextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_diemvm_bc.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bcreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.dcmp_diemvm_bc.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bcspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_diemvm_bc.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bcstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.dcmp_diemvm_bc.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompdcmp_diemvm_bcusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_diemvm_bc.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbcastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.dcmp_evmbc.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbcenabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_evmbc.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbcenableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_evmbc.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbchidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_evmbc.HideCasts"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbchidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_evmbc.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbciroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.dcmp_evmbc.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbcmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.dcmp_evmbc.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbcmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_evmbc.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbcmethoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.dcmp_evmbc.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbcnextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_evmbc.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbcreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.dcmp_evmbc.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbcspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_evmbc.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbcstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.dcmp_evmbc.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompdcmp_evmbcusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_evmbc.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipsastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.dcmp_mips.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipsenabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_mips.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipsenableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_mips.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipshidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_mips.HideCasts"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipshidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_mips.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipsiroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.dcmp_mips.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipsmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.dcmp_mips.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipsmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_mips.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipsmethoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.dcmp_mips.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipsnextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_mips.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipsreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.dcmp_mips.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipsspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_mips.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipsstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.dcmp_mips.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mipsusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_mips.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.dcmp_mips64.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64enabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_mips64.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64enableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_mips64.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64hidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_mips64.HideCasts"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64hidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_mips64.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.dcmp_mips64.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.dcmp_mips64.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64mergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_mips64.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64methoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.dcmp_mips64.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64nextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_mips64.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.dcmp_mips64.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64spaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_mips64.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.dcmp_mips64.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompdcmp_mips64usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_mips64.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.dcmp_riscv.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvenabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_riscv.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvenableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_riscv.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvhidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_riscv.HideCasts"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvhidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_riscv.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscviroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.dcmp_riscv.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.dcmp_riscv.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_riscv.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvmethoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.dcmp_riscv.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvnextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_riscv.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.dcmp_riscv.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_riscv.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.dcmp_riscv.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompdcmp_riscvusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_riscv.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.dcmp_simatic_mc7.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7enabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_simatic_mc7.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7enableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_simatic_mc7.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7hidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_simatic_mc7.HideCasts"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7hidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_simatic_mc7.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.dcmp_simatic_mc7.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.dcmp_simatic_mc7.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7mergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_simatic_mc7.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7methoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.dcmp_simatic_mc7.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7nextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_simatic_mc7.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.dcmp_simatic_mc7.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7spaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_simatic_mc7.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.dcmp_simatic_mc7.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompdcmp_simatic_mc7usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_simatic_mc7.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbcastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.dcmp_wasmbc.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbcenabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_wasmbc.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbcenableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_wasmbc.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbchidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_wasmbc.HideCasts"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbchidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_wasmbc.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbciroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.dcmp_wasmbc.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbcmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.dcmp_wasmbc.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbcmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_wasmbc.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbcmethoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.dcmp_wasmbc.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbcnextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_wasmbc.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbcreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.dcmp_wasmbc.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbcspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_wasmbc.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbcstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.dcmp_wasmbc.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompdcmp_wasmbcusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_wasmbc.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.dcmp_x86.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86enabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_x86.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86enableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_x86.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86hidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_x86.HideCasts"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86hidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_x86.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.dcmp_x86.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.dcmp_x86.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86mergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_x86.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86methoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.dcmp_x86.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86nextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_x86.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.dcmp_x86.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86spaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_x86.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.dcmp_x86.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_x86.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.native.decomp.dcmp_x86_64.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64enabledeobfuscators","text":"Description : Allow deobfuscators to run. A deobfuscator is an optimizer whose primary purpose is to simplify code that was intentionally complicated by an obfuscating tool. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_x86_64.EnableDeobfuscators"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64enableunsafeoptimizers","text":"Description : Allow unsafe optimizers to run. Unsafe optimizers may make assumptions about the program state (memory and registers) and modify that state. Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_x86_64.EnableUnsafeOptimizers"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64hidecasts","text":"Description : Hide casts (the output will be incorrect) Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_x86_64.HideCasts"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64hidetoplevelnamespaceelements","text":"Description : Hide top-level namespace elements in raw method names (C++) Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_x86_64.HideTopLevelNamespaceElements"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(10)","title":".parsers.native.decomp.dcmp_x86_64.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Type and Default : Integer(3)","title":".parsers.native.decomp.dcmp_x86_64.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64mergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line, e.g.: int i = 0, j = 1; Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_x86_64.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64methoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.native.decomp.dcmp_x86_64.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64nextdecompkeepir","text":"Description : Special non-sticky property used to specify that the IR context must be kept for the next decompilation Type and Default : Boolean(false)","title":".parsers.native.decomp.dcmp_x86_64.NextDecompKeepIR"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(5){0+}","title":".parsers.native.decomp.dcmp_x86_64.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64spaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_x86_64.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(3){0-3}","title":".parsers.native.decomp.dcmp_x86_64.StructurerUseVersion"},{"location":"engines-configuration.html#parsersnativedecompdcmp_x86_64usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.native.decomp.dcmp_x86_64.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersnativedisasadvancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisasanalysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasapplyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisasblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisascallingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisascharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisascompileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisascreatepackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisasdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisasdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisasendianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.Endianness"},{"location":"engines-configuration.html#parsersnativedisasforcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisasgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisasgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisasgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisasimagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.ImageBase"},{"location":"engines-configuration.html#parsersnativedisasinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisaslabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisasloadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisasperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisasperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisasrelocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisasroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisasshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisasshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisasshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisasshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisassignaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisasswitchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisastailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasusetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.UseTypeLibraries"},{"location":"engines-configuration.html#parsersnativedisasarmadvancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.arm.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisasarmanalysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.arm.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasarmapplyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.arm.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisasarmblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.arm.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisasarmcallingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.arm.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisasarmcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.arm.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisasarmcompileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.arm.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisasarmcreatepackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.arm.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisasarmdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.arm.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisasarmdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.arm.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisasarmdefaultmode","text":"Description : Default plugin mode (ARM or Thumb) Type and Default : Selection(0){Default mode(0), ARM(32), Thumb(16)}","title":".parsers.native.disas.arm.DefaultMode"},{"location":"engines-configuration.html#parsersnativedisasarmendianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.arm.Endianness"},{"location":"engines-configuration.html#parsersnativedisasarmforcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.arm.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisasarmforcewideflag","text":"Description : Wide Flag Display (T32 only) Type and Default : Selection(0){Display All(0), Distinguish 16-bit from 32-bit(1), Display when forced(2)}","title":".parsers.native.disas.arm.ForceWideFlag"},{"location":"engines-configuration.html#parsersnativedisasarmgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.arm.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisasarmgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.arm.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisasarmgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.arm.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisasarmimagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.arm.ImageBase"},{"location":"engines-configuration.html#parsersnativedisasarminstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.arm.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisasarmlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.arm.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisasarmloadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.arm.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisasarmperformfakeroutinecallanalysis","text":"Description : Search for Branch and Link (BL) instructions that should be considered as simple branches rather than routine calls (Thumb code optimization) Type and Default : Boolean(true)","title":".parsers.native.disas.arm.PerformFakeRoutineCallAnalysis"},{"location":"engines-configuration.html#parsersnativedisasarmperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.arm.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisasarmperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.arm.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisasarmrelocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.arm.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisasarmroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.arm.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisasarmshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.arm.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisasarmshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.arm.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisasarmshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.arm.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisasarmshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.arm.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisasarmsignaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.arm.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisasarmswitchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.arm.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasarmtailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.arm.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasarmusetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.arm.UseTypeLibraries"},{"location":"engines-configuration.html#parsersnativedisasarm64advancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.arm64.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisasarm64analysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.arm64.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasarm64applyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.arm64.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisasarm64blockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.arm64.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisasarm64callingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.arm64.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisasarm64charbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.arm64.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisasarm64compileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.arm64.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisasarm64createpackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.arm64.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisasarm64debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.arm64.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisasarm64debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.arm64.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisasarm64endianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.arm64.Endianness"},{"location":"engines-configuration.html#parsersnativedisasarm64forcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.arm64.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisasarm64gappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.arm64.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisasarm64gaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.arm64.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisasarm64gaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.arm64.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisasarm64imagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.arm64.ImageBase"},{"location":"engines-configuration.html#parsersnativedisasarm64instructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.arm64.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisasarm64labelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.arm64.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisasarm64loadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.arm64.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisasarm64performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.arm64.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisasarm64performrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.arm64.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisasarm64relocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.arm64.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisasarm64routineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.arm64.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisasarm64showaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.arm64.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisasarm64showbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.arm64.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisasarm64showsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.arm64.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisasarm64showspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.arm64.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisasarm64signaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.arm64.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisasarm64switchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.arm64.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasarm64tailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.arm64.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasarm64usetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.arm64.UseTypeLibraries"},{"location":"engines-configuration.html#parsersnativedisasavradvancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.avr.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisasavranalysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.avr.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasavrapplyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.avr.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisasavrblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.avr.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisasavrcallingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.avr.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisasavrcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.avr.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisasavrcompileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.avr.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisasavrcreatepackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.avr.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisasavrdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.avr.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisasavrdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.avr.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisasavrendianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.avr.Endianness"},{"location":"engines-configuration.html#parsersnativedisasavrforcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.avr.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisasavrgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.avr.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisasavrgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.avr.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisasavrgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.avr.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisasavrimagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.avr.ImageBase"},{"location":"engines-configuration.html#parsersnativedisasavrinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.avr.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisasavrlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.avr.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisasavrloadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.avr.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisasavrperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.avr.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisasavrperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.avr.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisasavrrelocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.avr.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisasavrroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.avr.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisasavrshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.avr.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisasavrshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.avr.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisasavrshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.avr.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisasavrshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.avr.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisasavrsignaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.avr.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisasavrswitchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.avr.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasavrtailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.avr.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasavrusetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.avr.UseTypeLibraries"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcadvancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.diemvm_bc.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcanalysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.diemvm_bc.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcapplyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.diemvm_bc.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.diemvm_bc.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bccallingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.diemvm_bc.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bccharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.diemvm_bc.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bccompileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.diemvm_bc.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bccreatepackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.diemvm_bc.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.diemvm_bc.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.diemvm_bc.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcendianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.diemvm_bc.Endianness"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcforcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.diemvm_bc.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.diemvm_bc.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.diemvm_bc.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.diemvm_bc.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcimagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.diemvm_bc.ImageBase"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.diemvm_bc.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bclabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.diemvm_bc.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcloadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.diemvm_bc.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.diemvm_bc.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.diemvm_bc.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcrelocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.diemvm_bc.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.diemvm_bc.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.diemvm_bc.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.diemvm_bc.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.diemvm_bc.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.diemvm_bc.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcsignaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.diemvm_bc.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcswitchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.diemvm_bc.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bctailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.diemvm_bc.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasdiemvm_bcusetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.diemvm_bc.UseTypeLibraries"},{"location":"engines-configuration.html#parsersnativedisasevmbcadvancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.evmbc.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisasevmbcanalysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.evmbc.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasevmbcapplyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.evmbc.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisasevmbcblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.evmbc.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisasevmbccallingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.evmbc.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisasevmbccharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.evmbc.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisasevmbccompileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.evmbc.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisasevmbccreatepackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.evmbc.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisasevmbcdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.evmbc.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisasevmbcdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.evmbc.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisasevmbcendianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.evmbc.Endianness"},{"location":"engines-configuration.html#parsersnativedisasevmbcforcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.evmbc.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisasevmbcgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.evmbc.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisasevmbcgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.evmbc.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisasevmbcgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.evmbc.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisasevmbcimagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.evmbc.ImageBase"},{"location":"engines-configuration.html#parsersnativedisasevmbcinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.evmbc.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisasevmbclabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.evmbc.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisasevmbcloadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.evmbc.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisasevmbcperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.evmbc.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisasevmbcperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.evmbc.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisasevmbcrelocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.evmbc.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisasevmbcroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.evmbc.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisasevmbcshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.evmbc.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisasevmbcshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.evmbc.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisasevmbcshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.evmbc.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisasevmbcshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.evmbc.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisasevmbcsignaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.evmbc.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisasevmbcswitchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.evmbc.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasevmbctailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.evmbc.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasevmbcusetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.evmbc.UseTypeLibraries"},{"location":"engines-configuration.html#parsersnativedisasmipsadvancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.mips.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisasmipsanalysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.mips.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasmipsapplyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.mips.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisasmipsblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.mips.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisasmipscallingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.mips.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisasmipscharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.mips.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisasmipscompileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.mips.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisasmipscreatepackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.mips.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisasmipsdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.mips.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisasmipsdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.mips.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisasmipsendianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.mips.Endianness"},{"location":"engines-configuration.html#parsersnativedisasmipsforcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.mips.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisasmipsgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.mips.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisasmipsgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.mips.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisasmipsgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.mips.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisasmipsimagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.mips.ImageBase"},{"location":"engines-configuration.html#parsersnativedisasmipsinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.mips.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisasmipslabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.mips.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisasmipsloadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.mips.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisasmipsperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.mips.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisasmipsperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.mips.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisasmipsrelocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.mips.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisasmipsroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.mips.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisasmipsshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.mips.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisasmipsshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.mips.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisasmipsshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.mips.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisasmipsshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.mips.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisasmipssignaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.mips.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisasmipsswitchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.mips.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasmipstailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.mips.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasmipsusetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.mips.UseTypeLibraries"},{"location":"engines-configuration.html#parsersnativedisasmips64advancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.mips64.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisasmips64analysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.mips64.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasmips64applyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.mips64.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisasmips64blockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.mips64.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisasmips64callingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.mips64.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisasmips64charbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.mips64.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisasmips64compileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.mips64.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisasmips64createpackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.mips64.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisasmips64debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.mips64.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisasmips64debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.mips64.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisasmips64endianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.mips64.Endianness"},{"location":"engines-configuration.html#parsersnativedisasmips64forcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.mips64.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisasmips64gappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.mips64.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisasmips64gaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.mips64.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisasmips64gaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.mips64.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisasmips64imagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.mips64.ImageBase"},{"location":"engines-configuration.html#parsersnativedisasmips64instructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.mips64.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisasmips64labelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.mips64.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisasmips64loadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.mips64.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisasmips64performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.mips64.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisasmips64performrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.mips64.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisasmips64relocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.mips64.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisasmips64routineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.mips64.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisasmips64showaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.mips64.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisasmips64showbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.mips64.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisasmips64showsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.mips64.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisasmips64showspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.mips64.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisasmips64signaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.mips64.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisasmips64switchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.mips64.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasmips64tailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.mips64.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasmips64usetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.mips64.UseTypeLibraries"},{"location":"engines-configuration.html#parsersnativedisasriscvadvancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.riscv.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisasriscvanalysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.riscv.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasriscvapplyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.riscv.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisasriscvblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.riscv.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisasriscvcallingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.riscv.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisasriscvcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.riscv.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisasriscvcompileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.riscv.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisasriscvcreatepackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.riscv.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisasriscvdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.riscv.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisasriscvdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.riscv.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisasriscvdisplayabiregisternames","text":"Description : Use abi (standard calling convention) registers instead of xN/fN Type and Default : Boolean(true)","title":".parsers.native.disas.riscv.DisplayAbiRegisterNames"},{"location":"engines-configuration.html#parsersnativedisasriscvendianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.riscv.Endianness"},{"location":"engines-configuration.html#parsersnativedisasriscvforcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.riscv.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisasriscvgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.riscv.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisasriscvgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.riscv.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisasriscvgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.riscv.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisasriscvimagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.riscv.ImageBase"},{"location":"engines-configuration.html#parsersnativedisasriscvinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.riscv.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisasriscvlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.riscv.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisasriscvloadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.riscv.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisasriscvperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.riscv.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisasriscvperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.riscv.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisasriscvrelocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.riscv.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisasriscvrenderjrx1asret","text":"Description : Render 'JR X1 / JR LR' as 'RET' pseudo-instructions Type and Default : Boolean(false)","title":".parsers.native.disas.riscv.RenderJRX1AsRet"},{"location":"engines-configuration.html#parsersnativedisasriscvroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.riscv.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisasriscvshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.riscv.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisasriscvshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.riscv.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisasriscvshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.riscv.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisasriscvshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.riscv.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisasriscvsignaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.riscv.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisasriscvswitchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.riscv.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasriscvtailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.riscv.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasriscvusetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.riscv.UseTypeLibraries"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7advancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.simatic_mc7.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7analysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.simatic_mc7.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7applyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.simatic_mc7.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7blockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.simatic_mc7.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7callingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.simatic_mc7.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7charbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.simatic_mc7.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7compileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.simatic_mc7.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7createpackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.simatic_mc7.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.simatic_mc7.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.simatic_mc7.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7endianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.simatic_mc7.Endianness"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7forcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.simatic_mc7.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7gappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.simatic_mc7.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7gaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.simatic_mc7.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7gaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.simatic_mc7.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7imagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.simatic_mc7.ImageBase"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7instructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.simatic_mc7.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7labelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.simatic_mc7.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7loadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.simatic_mc7.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.simatic_mc7.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7performrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.simatic_mc7.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7relocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.simatic_mc7.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7routineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.simatic_mc7.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7showaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.simatic_mc7.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7showbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.simatic_mc7.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7showsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.simatic_mc7.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7showspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.simatic_mc7.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7signaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.simatic_mc7.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7switchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.simatic_mc7.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7tailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.simatic_mc7.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisassimatic_mc7usetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.simatic_mc7.UseTypeLibraries"},{"location":"engines-configuration.html#parsersnativedisaswasmbcadvancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.wasmbc.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisaswasmbcanalysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.wasmbc.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisaswasmbcapplyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.wasmbc.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisaswasmbcblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.wasmbc.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisaswasmbccallingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.wasmbc.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisaswasmbccharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.wasmbc.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisaswasmbccompileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.wasmbc.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisaswasmbccreatepackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.wasmbc.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisaswasmbcdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.wasmbc.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisaswasmbcdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.wasmbc.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisaswasmbcendianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.wasmbc.Endianness"},{"location":"engines-configuration.html#parsersnativedisaswasmbcforcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.wasmbc.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisaswasmbcgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.wasmbc.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisaswasmbcgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.wasmbc.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisaswasmbcgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.wasmbc.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisaswasmbcimagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.wasmbc.ImageBase"},{"location":"engines-configuration.html#parsersnativedisaswasmbcinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.wasmbc.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisaswasmbclabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.wasmbc.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisaswasmbcloadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.wasmbc.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisaswasmbcperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.wasmbc.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisaswasmbcperformrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.wasmbc.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisaswasmbcrelocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.wasmbc.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisaswasmbcroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.wasmbc.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisaswasmbcshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.wasmbc.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisaswasmbcshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.wasmbc.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisaswasmbcshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.wasmbc.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisaswasmbcshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.wasmbc.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisaswasmbcsignaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.wasmbc.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisaswasmbcswitchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.wasmbc.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisaswasmbctailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.wasmbc.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisaswasmbcusetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.wasmbc.UseTypeLibraries"},{"location":"engines-configuration.html#parsersnativedisasx86advancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.x86.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisasx86analysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.x86.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasx86applyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.x86.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisasx86blockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.x86.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisasx86callingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.x86.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisasx86charbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.x86.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisasx86compileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.x86.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisasx86createpackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.x86.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisasx86debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.x86.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisasx86debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.x86.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisasx86endianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.x86.Endianness"},{"location":"engines-configuration.html#parsersnativedisasx86forcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.x86.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisasx86gappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.x86.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisasx86gaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.x86.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisasx86gaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.x86.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisasx86imagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.x86.ImageBase"},{"location":"engines-configuration.html#parsersnativedisasx86instructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.x86.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisasx86labelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.x86.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisasx86loadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.x86.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisasx86performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.x86.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisasx86performrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.x86.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisasx86relocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.x86.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisasx86routineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.x86.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisasx86showaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.x86.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisasx86showbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.x86.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisasx86showsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.x86.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisasx86showspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.x86.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisasx86signaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.x86.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisasx86switchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.x86.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasx86tailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.x86.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasx86usetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.x86.UseTypeLibraries"},{"location":"engines-configuration.html#parsersnativedisasx86_64advancedanalysis","text":"Description : The advanced analysis is an optional pass that comes after the initial (standard) analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Selection(1){Disabled(0), Only For Small Binaries(1), Always(2)}","title":".parsers.native.disas.x86_64.AdvancedAnalysis"},{"location":"engines-configuration.html#parsersnativedisasx86_64analysisstyle","text":"Description : N/A Type and Default : Selection(1){Conservative(0), Automatic(1), Aggressive(2), Lazy(3), Lazy no data(4)}","title":".parsers.native.disas.x86_64.AnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasx86_64applyandroidnativeprototypes","text":"Description : Generate and apply prototypes for native methods which are the implementations of Java Native abstract methods. Type and Default : Boolean(true)","title":".parsers.native.disas.x86_64.ApplyAndroidNativePrototypes"},{"location":"engines-configuration.html#parsersnativedisasx86_64blockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.native.disas.x86_64.BlockXrefsCount"},{"location":"engines-configuration.html#parsersnativedisasx86_64callingconvention","text":"Description : Default calling convention to use. Leave unknown for automatic detection Type and Default : Selection(0){__unknown(0), __cdecl(1), __stdcall(2), __fastcall(3), __thiscall(4), __vectorcall(5), __a32(6), aapcs64(7), __o32(8), __n32(9), __n64(10), __sysv_abi(11), __a32_hf(12)}","title":".parsers.native.disas.x86_64.CallingConvention"},{"location":"engines-configuration.html#parsersnativedisasx86_64charbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.native.disas.x86_64.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersnativedisasx86_64compileridentification","text":"Description : N/A Type and Default : Selection(0){Automatic(0), Unknown compiler(1), Generic Linux compiler(2), Android ART(3), Android NDK(4), Generic Windows compiler(5), Microsoft Visual C++(6)}","title":".parsers.native.disas.x86_64.CompilerIdentification"},{"location":"engines-configuration.html#parsersnativedisasx86_64createpackagesfromroutinenames","text":"Description : Automatically create packages from native method names; for example 'std::foo::bar' method will be moved to package 'std::foo' and renamed 'bar'. Type and Default : Boolean(true)","title":".parsers.native.disas.x86_64.CreatePackagesFromRoutineNames"},{"location":"engines-configuration.html#parsersnativedisasx86_64debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects. Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Selection(2){Never(0), Local only(1), Local and Network(2)}","title":".parsers.native.disas.x86_64.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersnativedisasx86_64debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis) Type and Default : Selection(1){None(0), Internal(1), All available(2)}","title":".parsers.native.disas.x86_64.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersnativedisasx86_64endianness","text":"Description : Reserved for raw binaries: Wanted endianness (may be overridden by the code parser). Type and Default : Selection(0){Automatic(0), Little-endian(1), Big-endian(2)}","title":".parsers.native.disas.x86_64.Endianness"},{"location":"engines-configuration.html#parsersnativedisasx86_64forcesynchronousanalysis","text":"Description : Block all or permit read-only operations during a code analysis. This option is recommended for large binaries as the initial analysis will terminate faster. Type and Default : Selection(-1){Default(-1), Non-blocking(0), Blocking(1)}","title":".parsers.native.disas.x86_64.ForceSynchronousAnalysis"},{"location":"engines-configuration.html#parsersnativedisasx86_64gappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (e.g., db ??) Type and Default : Boolean(false)","title":".parsers.native.disas.x86_64.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersnativedisasx86_64gaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.native.disas.x86_64.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersnativedisasx86_64gaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.native.disas.x86_64.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersnativedisasx86_64imagebase","text":"Description : If unspecified, the base address from the code object (ELF, PE, MachO...) is used. If none can be found (eg, raw binaries) default address is 0. Also see the related property RelocationBaseForZeroBasedRelocatableObjects Type and Default : String(\"\")","title":".parsers.native.disas.x86_64.ImageBase"},{"location":"engines-configuration.html#parsersnativedisasx86_64instructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.native.disas.x86_64.InstructionAreaLength"},{"location":"engines-configuration.html#parsersnativedisasx86_64labelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.native.disas.x86_64.LabelAreaLength"},{"location":"engines-configuration.html#parsersnativedisasx86_64loadtypelibrariescodelesssigs","text":"Description : When applying codeless signatures, automatically load corresponding type libraries. Type and Default : Boolean(true)","title":".parsers.native.disas.x86_64.LoadTypeLibrariesCodelessSigs"},{"location":"engines-configuration.html#parsersnativedisasx86_64performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.native.disas.x86_64.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersnativedisasx86_64performrttirecovery","text":"Description : Attempt C++ Run-Time Type Information (RTTI) discovery and rebuilding (MSVC and Itanium (GCC/CLANG/NDK) are supported) Type and Default : Boolean(true)","title":".parsers.native.disas.x86_64.PerformRttiRecovery"},{"location":"engines-configuration.html#parsersnativedisasx86_64relocationbaseforzerobasedrelocatableobjects","text":"Description : An object specifying no base (typically, a relocatable library file, such as an .so/.dll file) will be relocated and mapped to this address Type and Default : String(\"10000h\")","title":".parsers.native.disas.x86_64.RelocationBaseForZeroBasedRelocatableObjects"},{"location":"engines-configuration.html#parsersnativedisasx86_64routineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.native.disas.x86_64.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersnativedisasx86_64showaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.native.disas.x86_64.ShowAddresses"},{"location":"engines-configuration.html#parsersnativedisasx86_64showbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.native.disas.x86_64.ShowBytesCount"},{"location":"engines-configuration.html#parsersnativedisasx86_64showsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.native.disas.x86_64.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersnativedisasx86_64showspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.native.disas.x86_64.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersnativedisasx86_64signaturepackagesloading","text":"Description : Select how signature packages are loaded. Two types of packages exist: JEB default packages for common libraries, and user-made packages (refer to manual for additional information). Type and Default : Selection(2){Disabled(0), Manual(1), Automatic(2)}","title":".parsers.native.disas.x86_64.SignaturePackagesLoading"},{"location":"engines-configuration.html#parsersnativedisasx86_64switchanalysisstyle","text":"Description : Search for possible switch statements at assembly level. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.x86_64.SwitchAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasx86_64tailcallanalysisstyle","text":"Description : Search for possible tail calls optimized as branches, and build proper routines. Type and Default : Selection(-1){Automatic(-1), Disabled(0), Safe heuristics only(1), Aggressive heuristics(2)}","title":".parsers.native.disas.x86_64.TailCallAnalysisStyle"},{"location":"engines-configuration.html#parsersnativedisasx86_64usetypelibraries","text":"Description : Use native type libraries (e.g. win32, libc, etc.) Type and Default : Boolean(true)","title":".parsers.native.disas.x86_64.UseTypeLibraries"},{"location":"engines-configuration.html#parserssimatic_s7augmentdisassembly","text":"Description : Augment the disassembly whenever possible, e.g. replace opaque parameter addressing with structure information. Type and Default : Boolean(true)","title":".parsers.simatic_s7.AugmentDisassembly"},{"location":"engines-configuration.html#parserssimatic_s7disassemblecode","text":"Description : Disassemble the MC7 code contained in logic blocks (OB, FC, FB, SFC, SFB) Type and Default : Boolean(true)","title":".parsers.simatic_s7.DisassembleCode"},{"location":"engines-configuration.html#parserssimatic_s7generateinterfacedescriptionunits","text":"Description : Generate additional text units describing interfaces for logic blocks and data blocks Type and Default : Boolean(true)","title":".parsers.simatic_s7.GenerateInterfaceDescriptionUnits"},{"location":"engines-configuration.html#parserssimatic_s7mapactualbytesfordatablocks","text":"Description : For data blocks, prefer mapping the actual (current values) bytes insteal of the default (initial values). Type and Default : Boolean(true)","title":".parsers.simatic_s7.MapActualBytesForDataBlocks"},{"location":"engines-configuration.html#parserssimatic_s7maprawblocksatzero","text":"Description : Map the raw bytes of S7 blocks at the beginning of the image (address 0) Type and Default : Boolean(false)","title":".parsers.simatic_s7.MapRawBlocksAtZero"},{"location":"engines-configuration.html#projectalwaysprocessduplicateinputs","text":"Description : Process binary inputs even if such input was seen earlier and processed as another unit already Type and Default : Boolean(false)","title":".project.AlwaysProcessDuplicateInputs"},{"location":"engines-configuration.html#projectartifactprocessingdepth","text":"Description : Determine the maximum depth an input artifact (e.g., a file) will be explored to create units and sub-units representing analysis entities Type and Default : Integer(20){1+}","title":".project.ArtifactProcessingDepth"},{"location":"engines-configuration.html#projectcompresspersistedproject","text":"Description : Compress the JDB2 database (recommended) Type and Default : Boolean(true)","title":".project.CompressPersistedProject"},{"location":"engines-configuration.html#projectpersistartifactfiles","text":"Description : Persist the full artifact files in a JDB2 database. The resulting JDB2 file will be larger since the input files are embedded in it for extra safety. Type and Default : Boolean(true)","title":".project.PersistArtifactFiles"},{"location":"engines-configuration.html#projectpersistencestrategy","text":"Description : Determine how a project will be saved to JDB2 Type and Default : Selection(0){Automatic(0), Full save(1), Quick save(2)}","title":".project.PersistenceStrategy"},{"location":"ethereum.html","text":"Info This manual page assumes familiarity with common JEB actions and views . We also assume a minimal amount of knowledge of the Ethereum Virtual Machine bytecode and framework of operations. This was adapted from contents originally published on our blog . Capabilities # The Ethereum plugin provides the following specific capabilities: The EVM code analyzer determines a contract public and private methods, including implementations of public methods synthetically generated by compilers. This analysis attempts to determine method and event names and prototypes, without access to an ABI. The EVM decompiler decompiles analyzed EVM code to Solidity-like source code. The decompiler attempts to recover various high-level constructs, including: Implementations of well-known interfaces, such as ERC20 for standard tokens, ERC721 for non-fungible tokens, MultiSigWallet contracts, etc. Storage variables and types High-level Solidity artifacts and idioms, including: Function mutability attributes Function payability state Event emission, including event name Invocations of address.send() or address.transfer() Precompiled contracts invocations Basic usage # Open a contract via the File, Open smart contract... menu entry. You will be offered two options: Open a binary file already stored on disk Or download and open a contract from one of the principal Ethereum or Ethereum-compatible mainnets and testnets: Select the network Provide the contract 20-byte address Click Download and select a file destination Open a contract via the File, Open smart contract menu entry Note To be recognized as EVM code, a file must: have a \".evm-bytecode\" extension: in this case, the file may contain binary or hex-encoded code; or have a \".runtime\" or \".bin-runtime\" extension (as generated by the solc Solidity compiler) and contain hex-encoded Solidity generated code. If you are opening raw files, we recommend you append the \".evm-extension\" to them in order to guarantee that they will be processed as EVM contract code. Contract Processing # JEB will process your contract file and generate a class item to represent it: The Assembly view on the right panel shows the processed code. To switch to the decompiled view, select the \"Decompiled Contract\" node in the Code Hierarchy view, and press Tab (or right-click, Decompile). Right-click on items to bring up context menus showing the principal commands and shortcuts. The decompiled view of a contract. A decompiled contract is rendered in Solidity-like code: it is mostly Solidity code, but not entirely. Constructs that are illegal in Solidity are used throughout the code to represent instructions that the decompiler could not represent otherwise. Examples include: statements representing some low-level EVM instructions, memory accesses, or very rarely, goto statements. Do not expect a DecompiledContract to be easily recompiled. Code views # You may adjust the View panels to have side-by-side views if you wish to navigate the assembly and high-level code at the same time. In the assembly view, within a routine, press Space to visualize its control flow graph. To navigate from assembly to source, and back, press the Tab key. The caret will be positioned on the closest matching instruction. Side by side views: assembly and source Contract information # In the Project Explorer panel, double click the contract node (the node with the official Ethereum Foundation logo), and then select the Description tab in the opened view to see interesting information about the processed contract, such as: The file metadata, if some were found and successfully parsed (Solidity-generated metadata is recovered) The detected compiler and/or its version (currently supported are variants of Solidity and Vyper compilers). The list of detected routines (private and public, with their hashes). The contract was identified as being compiled with Solidity >= 0.4.22, specifically solc 0.6.12. Exposed metadata: IPDS hash, Solidity compiler version. Keep in mind that metadata is indicative and should not be trusted. Commands # The usual commands can be used to refactor and annotate the assembly or decompiled code. You will find the exhaustive list in the Action and Native menus. Here are basic commands: Rename items (methods, variables, globals, ...) using the N key Navigate the code by examining cross-references using the X key (e.g., find all callers of a method and jump to one of them) Comment using the Slash key As said earlier, the Tab key is useful to navigate back and forth from low-level EVM code to high-level decompiled code Rename an item (e.g., a variable) by pressing the N key Immediate number bases and rendering can be changed by using the B key. In the example below, you can see a couple of strings present in the bad Fomo3D contract, initially rendered in Hex: All immediates are rendered as hex-strings by default. Use the B key to cycle through base (10, 16, etc.) and rendering (number, ascii) Understanding decompiled contracts # This section highlights idioms you will encounter throughout decompiled pseudo-Solidity code. The examples below show the UI client set up to display EVM disassembly on the left side, and high-level decompiled code on the right side. The contracts used as examples are live contracts active on mainnet . Dispatcher and public functions # The entry-point function of a contract, at address 0, is generally its dispatcher. It is named start() by JEB, and in most cases will consist in an if-statement comparing the input CALLDATA hash (the first 4 bytes) to pre-calculated hashes, to determine which routine is to be executed. JEB attempts to determine public method names by using a hash dictionary (currently containing more than 340,000 entries). Contracts compiled by Solidity generally use synthetic (compiler generated) methods as bridges between public routines, that use the public Ethereum ABI, and internal routines, using a compiler-specific ABI. Those routines are identified as well and, if their corresponding public method was named, will be assigned a similar name __impl_{PUBLIC_NAME} . Limitation Currently, JEB does not attempt to process input data of public routines and massage it back into an explicit prototype with regular variables. Therefore, you will see low-level access to CALLDATA bytes within public methods. A dispatcher. Below, see the public method collectToken() , which is retrieving its first parameter \u2013 a 20 byte address \u2013 from the calldata . A public method reading its arguments from CALLDATA bytes. Interface discovery # At the time of writing, implementation of the following interfaces can be detected: ERC20, ERC165, ERC721, ERC721TokenReceiver, ERC721Metadata, ERC721Enumerable, ERC820, ERC223, ERC777, TokenFallback used by ERC223/ERC777 interfaces, as well as the common MultiSigWallet interface. E.g., the contract below was identified as an ERC20 token implementation: This contract implements all methods specified by the ERC20 interface. Function attributes # JEB does its best to retrieve: low-level state mutability attributes (pure, read-only, read-write) the high-level Solidity \u2018payable\u2019 attribute, reserved for public methods Explicitly non-payable functions have lower-level synthetic stubs that verify that no Ether is being received. They REVERT if it is is the case. If JEB decides to remove this stub, the function will always have an inline comment /* non payable */ to avoid any ambiguity. The contract below shows two public methods, one has a default mutability state (non-payable); the other one is payable. Note that the hash 0xFF03AD56 was not resolved, therefore the name of the method is unknown and was set to sub_AF ; you may also see a call to collect() \u2019s bridge function __impl_collect() , as was mentioned in the previous section. Two public methods, one is payable, the other is not and will revert if it receives Ether. Storage variables # The current decompiler has a rather limited storage reconstructor module. Accesses to primitives (int8 to int256, uint8 to uint256) is reconstructed in most cases Packed small primitives in storage words are extracted (e.g., a 256-bit storage word containing 2x uint8 and 1x int32, and accessed as such throughout the code, will yield 3 contract variables, as one would expect to see in a Solidity contract Four primitive storage variables were reconstructed. Limitation Currently, accesses to complex storage variables, such as mappings, mappings of mappings, mappings of structures, etc. are not simplified. This limitation will be addressed in a future update. When a storage variable is not resolved, you will see simple storage[...] assignments, such as: Unresolved storage assignment, here, to a mapping. Due to how storage on Ethereum is designed (a key-value store of uint256 to uint256), Solidity internally uses a two-or-more indirection level for computing actual storage keys. Those low-level storage keys depend on the position of the high level storage variables. The KECCAK256 opcode can be used to calculate intermediate and final keys. We will detail this mechanism in detail in a future blog post. Precompiled contracts # Ethereum defines at least four pre-compiled contracts at addresses 1 through 8. JEB identifies CALLs that will eventually lead to pre-compiled code execution, and marks them as such in decompiled code: call_{specific}. The example below shows the __impl_Receive (named recovered) method of the 34C3 CTF contract, which calls into address #2, a pre-compiled contract providing a fast implementation of SHA-256. This contract calls address 2 to calculate the SHA-256 of a binary blob. Ether send() # Solidity's send can be translated into a lower-level call with a standard gas stipend and zero parameters. It is essentially used to send Ether to a contract through the target contract fall-back function. Currently, JEB renders them as send(address, amount) instead of address.send(amount) . The contract below is live on mainnet . It is a simple forwarder, that does not store ether: it forwards the received amount to another contract. This contract makes use of address.send(...) to send Ether Ether transfer() # Solidity\u2019s transfer is an even higher-level variant of send that checks and REVERTs with data if CALL failed. JEB identifies those calls as well. Currently, JEB renders them as transfer(address, amount) instead of address.transfer(amount) . This contract makes use of address.transfer(...) to send Ether Event emission # JEB attempts to partially reconstruct LOGx (x in 1..4) opcodes back into high-level Solidity emit Event(...) . The event name is resolved by reversing the Event method prototype hash. If JEB cannot reverse a LOGx instruction, or if LOG0 is used, then a lower-level log(...) call will be used. Currently, the event parameters are not processed; therefore, the emit construct used in the decompiled code has the following form: emit Event(memory, size[, topic2[, topic3[, topic4]]]) . topic1 is always used to store the event prototype hash. An Invocation of LOG4 reversed to an emit Deposit(...) event emission API # The EVM analysis modules are built onto the native code analysis pipeline of JEB. Therefore, standard APIs can be used to automate analysis tasks. In particular, the decompiler API gives access to: the intermediate representation (IR) the final Solidity-like representation (AST) Example This sample script demonstrates how to retrieve the decompiled EVM code of an Ethereum contract and print out AST nodes: code Refer to \"Extending JEB\" to get started with developing scripts or plugins for JEB.","title":"Ethereum Analysis"},{"location":"ethereum.html#capabilities","text":"The Ethereum plugin provides the following specific capabilities: The EVM code analyzer determines a contract public and private methods, including implementations of public methods synthetically generated by compilers. This analysis attempts to determine method and event names and prototypes, without access to an ABI. The EVM decompiler decompiles analyzed EVM code to Solidity-like source code. The decompiler attempts to recover various high-level constructs, including: Implementations of well-known interfaces, such as ERC20 for standard tokens, ERC721 for non-fungible tokens, MultiSigWallet contracts, etc. Storage variables and types High-level Solidity artifacts and idioms, including: Function mutability attributes Function payability state Event emission, including event name Invocations of address.send() or address.transfer() Precompiled contracts invocations","title":"Capabilities"},{"location":"ethereum.html#basic-usage","text":"Open a contract via the File, Open smart contract... menu entry. You will be offered two options: Open a binary file already stored on disk Or download and open a contract from one of the principal Ethereum or Ethereum-compatible mainnets and testnets: Select the network Provide the contract 20-byte address Click Download and select a file destination Open a contract via the File, Open smart contract menu entry Note To be recognized as EVM code, a file must: have a \".evm-bytecode\" extension: in this case, the file may contain binary or hex-encoded code; or have a \".runtime\" or \".bin-runtime\" extension (as generated by the solc Solidity compiler) and contain hex-encoded Solidity generated code. If you are opening raw files, we recommend you append the \".evm-extension\" to them in order to guarantee that they will be processed as EVM contract code.","title":"Basic usage"},{"location":"ethereum.html#contract-processing","text":"JEB will process your contract file and generate a class item to represent it: The Assembly view on the right panel shows the processed code. To switch to the decompiled view, select the \"Decompiled Contract\" node in the Code Hierarchy view, and press Tab (or right-click, Decompile). Right-click on items to bring up context menus showing the principal commands and shortcuts. The decompiled view of a contract. A decompiled contract is rendered in Solidity-like code: it is mostly Solidity code, but not entirely. Constructs that are illegal in Solidity are used throughout the code to represent instructions that the decompiler could not represent otherwise. Examples include: statements representing some low-level EVM instructions, memory accesses, or very rarely, goto statements. Do not expect a DecompiledContract to be easily recompiled.","title":"Contract Processing"},{"location":"ethereum.html#code-views","text":"You may adjust the View panels to have side-by-side views if you wish to navigate the assembly and high-level code at the same time. In the assembly view, within a routine, press Space to visualize its control flow graph. To navigate from assembly to source, and back, press the Tab key. The caret will be positioned on the closest matching instruction. Side by side views: assembly and source","title":"Code views"},{"location":"ethereum.html#contract-information","text":"In the Project Explorer panel, double click the contract node (the node with the official Ethereum Foundation logo), and then select the Description tab in the opened view to see interesting information about the processed contract, such as: The file metadata, if some were found and successfully parsed (Solidity-generated metadata is recovered) The detected compiler and/or its version (currently supported are variants of Solidity and Vyper compilers). The list of detected routines (private and public, with their hashes). The contract was identified as being compiled with Solidity >= 0.4.22, specifically solc 0.6.12. Exposed metadata: IPDS hash, Solidity compiler version. Keep in mind that metadata is indicative and should not be trusted.","title":"Contract information"},{"location":"ethereum.html#commands","text":"The usual commands can be used to refactor and annotate the assembly or decompiled code. You will find the exhaustive list in the Action and Native menus. Here are basic commands: Rename items (methods, variables, globals, ...) using the N key Navigate the code by examining cross-references using the X key (e.g., find all callers of a method and jump to one of them) Comment using the Slash key As said earlier, the Tab key is useful to navigate back and forth from low-level EVM code to high-level decompiled code Rename an item (e.g., a variable) by pressing the N key Immediate number bases and rendering can be changed by using the B key. In the example below, you can see a couple of strings present in the bad Fomo3D contract, initially rendered in Hex: All immediates are rendered as hex-strings by default. Use the B key to cycle through base (10, 16, etc.) and rendering (number, ascii)","title":"Commands"},{"location":"ethereum.html#understanding-decompiled-contracts","text":"This section highlights idioms you will encounter throughout decompiled pseudo-Solidity code. The examples below show the UI client set up to display EVM disassembly on the left side, and high-level decompiled code on the right side. The contracts used as examples are live contracts active on mainnet .","title":"Understanding decompiled contracts"},{"location":"ethereum.html#dispatcher-and-public-functions","text":"The entry-point function of a contract, at address 0, is generally its dispatcher. It is named start() by JEB, and in most cases will consist in an if-statement comparing the input CALLDATA hash (the first 4 bytes) to pre-calculated hashes, to determine which routine is to be executed. JEB attempts to determine public method names by using a hash dictionary (currently containing more than 340,000 entries). Contracts compiled by Solidity generally use synthetic (compiler generated) methods as bridges between public routines, that use the public Ethereum ABI, and internal routines, using a compiler-specific ABI. Those routines are identified as well and, if their corresponding public method was named, will be assigned a similar name __impl_{PUBLIC_NAME} . Limitation Currently, JEB does not attempt to process input data of public routines and massage it back into an explicit prototype with regular variables. Therefore, you will see low-level access to CALLDATA bytes within public methods. A dispatcher. Below, see the public method collectToken() , which is retrieving its first parameter \u2013 a 20 byte address \u2013 from the calldata . A public method reading its arguments from CALLDATA bytes.","title":"Dispatcher and public functions"},{"location":"ethereum.html#interface-discovery","text":"At the time of writing, implementation of the following interfaces can be detected: ERC20, ERC165, ERC721, ERC721TokenReceiver, ERC721Metadata, ERC721Enumerable, ERC820, ERC223, ERC777, TokenFallback used by ERC223/ERC777 interfaces, as well as the common MultiSigWallet interface. E.g., the contract below was identified as an ERC20 token implementation: This contract implements all methods specified by the ERC20 interface.","title":"Interface discovery"},{"location":"ethereum.html#function-attributes","text":"JEB does its best to retrieve: low-level state mutability attributes (pure, read-only, read-write) the high-level Solidity \u2018payable\u2019 attribute, reserved for public methods Explicitly non-payable functions have lower-level synthetic stubs that verify that no Ether is being received. They REVERT if it is is the case. If JEB decides to remove this stub, the function will always have an inline comment /* non payable */ to avoid any ambiguity. The contract below shows two public methods, one has a default mutability state (non-payable); the other one is payable. Note that the hash 0xFF03AD56 was not resolved, therefore the name of the method is unknown and was set to sub_AF ; you may also see a call to collect() \u2019s bridge function __impl_collect() , as was mentioned in the previous section. Two public methods, one is payable, the other is not and will revert if it receives Ether.","title":"Function attributes"},{"location":"ethereum.html#storage-variables","text":"The current decompiler has a rather limited storage reconstructor module. Accesses to primitives (int8 to int256, uint8 to uint256) is reconstructed in most cases Packed small primitives in storage words are extracted (e.g., a 256-bit storage word containing 2x uint8 and 1x int32, and accessed as such throughout the code, will yield 3 contract variables, as one would expect to see in a Solidity contract Four primitive storage variables were reconstructed. Limitation Currently, accesses to complex storage variables, such as mappings, mappings of mappings, mappings of structures, etc. are not simplified. This limitation will be addressed in a future update. When a storage variable is not resolved, you will see simple storage[...] assignments, such as: Unresolved storage assignment, here, to a mapping. Due to how storage on Ethereum is designed (a key-value store of uint256 to uint256), Solidity internally uses a two-or-more indirection level for computing actual storage keys. Those low-level storage keys depend on the position of the high level storage variables. The KECCAK256 opcode can be used to calculate intermediate and final keys. We will detail this mechanism in detail in a future blog post.","title":"Storage variables"},{"location":"ethereum.html#precompiled-contracts","text":"Ethereum defines at least four pre-compiled contracts at addresses 1 through 8. JEB identifies CALLs that will eventually lead to pre-compiled code execution, and marks them as such in decompiled code: call_{specific}. The example below shows the __impl_Receive (named recovered) method of the 34C3 CTF contract, which calls into address #2, a pre-compiled contract providing a fast implementation of SHA-256. This contract calls address 2 to calculate the SHA-256 of a binary blob.","title":"Precompiled contracts"},{"location":"ethereum.html#ether-send","text":"Solidity's send can be translated into a lower-level call with a standard gas stipend and zero parameters. It is essentially used to send Ether to a contract through the target contract fall-back function. Currently, JEB renders them as send(address, amount) instead of address.send(amount) . The contract below is live on mainnet . It is a simple forwarder, that does not store ether: it forwards the received amount to another contract. This contract makes use of address.send(...) to send Ether","title":"Ether send()"},{"location":"ethereum.html#ether-transfer","text":"Solidity\u2019s transfer is an even higher-level variant of send that checks and REVERTs with data if CALL failed. JEB identifies those calls as well. Currently, JEB renders them as transfer(address, amount) instead of address.transfer(amount) . This contract makes use of address.transfer(...) to send Ether","title":"Ether transfer()"},{"location":"ethereum.html#event-emission","text":"JEB attempts to partially reconstruct LOGx (x in 1..4) opcodes back into high-level Solidity emit Event(...) . The event name is resolved by reversing the Event method prototype hash. If JEB cannot reverse a LOGx instruction, or if LOG0 is used, then a lower-level log(...) call will be used. Currently, the event parameters are not processed; therefore, the emit construct used in the decompiled code has the following form: emit Event(memory, size[, topic2[, topic3[, topic4]]]) . topic1 is always used to store the event prototype hash. An Invocation of LOG4 reversed to an emit Deposit(...) event emission","title":"Event emission"},{"location":"ethereum.html#api","text":"The EVM analysis modules are built onto the native code analysis pipeline of JEB. Therefore, standard APIs can be used to automate analysis tasks. In particular, the decompiler API gives access to: the intermediate representation (IR) the final Solidity-like representation (AST) Example This sample script demonstrates how to retrieve the decompiled EVM code of an Ethereum contract and print out AST nodes: code Refer to \"Extending JEB\" to get started with developing scripts or plugins for JEB.","title":"API"},{"location":"faq.html","text":"Frequently asked answers to common questions and issues regarding JEB 3 and JEB 4. The last section is for questions regarding JEB 2, and is kept for reference only. All users are encouraged to migrate to the latest version of JEB. Licensing # Where is the end-user license agreement? # The up-to-date end-user license agreement for JEB can be found here . Can I generate license keys for additional machines? # Yes, as long as the additional machines are operated by the licensee, they may install JEB on them. Contact licensing to request the ability to generate additional keys. We handle those requests promptly. Can I revoke license keys? # Yes, JEB license keys can be deprecated. Contact licensing to request key revocation. We handle those requests promptly. I need to reinstall JEB on a different machine. Should I generate a new license key? # Yes. Keys are specific to a user account. If you need to (re)install a non-floating build or the Controller for a floating build on a new system, make sure to generate a key on that system. If you are planning to copy configuration files over, remove the .LicenseKey entry of jeb-client.cfg and generate a new key upon first run. Why did JEB prompt me to generate a new key even though I have not changed my computer? # A key is derived from multiple machine identifiers, such as the operating system serial number. Those identifiers are supposedly stable, but may change on some occasions or situations, e.g. after a major OS upgrade, or when a security product or low-level software tool modifies or provides different values for those ids. In such instances, JEB will not be able to match the current license key with its expected value, and therefore, will ask for the user to generate a new key. How do I check my license type, license identifier, or license key? # From the command-line: execute JEB with the -c --license switches, eg: $ jeb_wincon.bat -c --license From the UI client: open the menu entry Help, About . How do floating licenses work? # Floating licenses work on a per-seat basis, as opposed to other license types that work on a per-user basis. Example: A floating build valid for 3 seats allow any 3 users within your organization concurrently. A non-floating build valid for 3 users allow 3 fixed, determined users to use JEB. No other user can use it. Therefore, floating builds provide great flexibility for organizations where many users are planning to use JEB irregularly and/or at different times (e.g., teams split across various regions). Please refer to this Manual entry to learn about setting up floating Controller and Clients. What happens when my license subscription expires? # JEB works on subscription. Past the expiration date, your software will continue to work and allow you to open and work on existing JDB2 projects, but you will not be able to create new projects. Do subscriptions renew automatically? # No. We do not perform auto-payments or auto-renewals. Please email sales when you need to renew a subscription. Do you offer subscriptions valid for more than one year? # Yes, we do offer custom subscriptions for up to 3 years. Email us at sales for details. Do you offer perpetual licenses? # No, we do not offer perpetual licenses at this point. However, we recommend you email sales and let us know your specific needs: we always strive to accommodate customers' needs. Do you provide professional support? # We do offer an additional support plan for JEB Pro and JEB Pro Floating licenses. Refer to the Buy page for details. Do you offer large volume subscriptions? # Yes, we do have plans for large enterprise and government. Those plans include the possibility to generate large amount of license keys. Reach out to sales for additional details. We developed internal tools built around JEB. Can other users in my organization use them without breaking the EULA? # Yes. As long as your JEB subscription is valid, users in your organization may access and use data produced by JEB. Java # Which version of Java shall I use to run JEB UI client? # We recommend users to run the JEB client with a JDK 11 or above. With Java 9 and above, the native launcher ( jeb.exe on Windows, jeb on Linux, jeb.app/ on macOS) may not run smoothly. If that happens, you can bypass the native launcher by using the -j flag with your start-up script. Example, on Linux: jeb_linux.sh -j . If you have installed multiple versions of Java, make sure to set the JAVA_HOME environment variable to the JDK of your choice. The JEB client can always be started directly by executing jebc.jar on the command line: java -jar bin/app/jebc.jar Which version of Java shall I use to run non-UI clients? # The back-end components of JEB, jeb.jar , works with with any version of Java 8.191 or above. Which build of the JDK should I use? # Oracle builds or OpenJDK builds are preferred. It seems some UI problems with GTK/Linux were caused by custom builds, such as JetBrains's JDK. Other problems, including slowdowns and crashes during intensive processing, were reported by users using AdoptOpenJDK. For this reason, we strongly recommend to use Oracle/OpenJDK. I am encountering strange problems on Windows, what can I do? # The native launcher ( jeb.exe ) is called by jeb_wincon.bat by default on Windows. It does not play well with third-party JDKs, such as AdoptOpenJDK. To avoid problems, use -j to avoid using the native launcher: jeb_wincon.bat -j . Alternatively, you may use an Oracle JDK. JEB complains that it \"requires a Java runtime environment\", although I have one installed. # Your java binary should be accessible from the PATH environment variable. It is also recommended to set a JAVA_HOME environment variable pointing to your Java installation folder (bin/). Make sure to install a 64-bit Java environment A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH or JAVA_HOME . You may have different versions of Java installed, but always make sure that paths refer to one that matches your system specifications. How can I increase the maximum amount of memory usable by JEB? # Create or edit the jvmopt.txt file at the root of your JEB folder. To specify an absolute maximum amount of memory, use -Xmx<Value><SizeUnit> . Example: -Xmx8G : allow JEB to use up to 8 Gb of memory. To specify a relative maximum amount of memory, use -XX:MaxRAMPercentage=<Ratio> . Example: -XX:MaxRAMPercentage=75.0 : allow JEB to use at most 75% of your RAM. The settings in jvmopt.txt must be on a single line. After modifying this file, restart JEB with your usual start-up script. On start-up, a message in the logger output will reflect the updated capability: Warning Do not edit the configuration files buried in bin/app/... or bin/jeb.app/... folders. The memory settings in those files are automatically pulled from jvmopt.txt. Program # On which platforms can I run JEB? # The UI desktop client runs on Windows (x64), Linux (x64, arm64), and macOS (x64, arm64). The JEB back-end components, which can be used separately to build other clients or analysis pipelines, run on all systems for which a JDK 8 (or above) is available. What do I need to run JEB? # The only external dependency is Java: JDK 11 (or above) recommended; JDK 8 is also accepted but its support will be deprecated in 2022. How can I run multiple instances of JEB? # Multiple instances of JEB can run natively without configuration changes. How can I redirect JEB logs to files on disk? # Command-line runners, such as the floating license Controller or a script runner, can easily write log output to files. (Note that other clients, such as the UI desktop client, can do that via scripting - refer to GlobalLog .) Use the --logfile=... flag. Consult the Usage info for additional details on that switch ( \"--help\" ) Example: Start a JEB Controller on Windows and log all INFO-level (or above) output to \"controller.log.N\" files (max. 5 rotating files, max. 2 Mb of log per file): jeb_wincon.bat -c --controller --logfiles=controller.log,INFO,5,2 I access Internet via a proxy. Can I still use JEB? # Proxy settings can be stored at those two locations: The UI client's settings, stored in jeb-client.cfg . If you are using the UI desktop client, they can be modified via the Options panel. In headless mode, set the proxy settings in jeb-engines.cfg instead. In each aforementioned configuration file, the network proxy data is stored as a key-value pair having the following format: .NetworkProxy = type|hostname|port|<username>|<password>|<whitelist> Allowed types: http , socks . 'username'/'password' can be left blank if your proxy does not require authentication 'whitelist' is an optional, comma-separated list of wildcard hostnames/IPs to which JEB should always attempt to direct-connect (no proxy) A few examples of valid proxy strings: - http|10.0.0.123|8080 - http|10.0.0.123|8080|| - http|10.0.0.123|8080||| - http|10.0.0.123|8080|||*.pnfsoftware.com - socks|proxy0.intranet.com|8088|user|pass|*.pnfsoftware.com Warning Do not forget the leading dot in .NetworkProxy! Does JEB run natively on Apple Silicon? Is Rosetta 2 needed to run JEB on Apple Silicon machines? # JEB (>=4.0-beta.4) can run natively on arm64-powered macOS systems. The Rosetta conversion system is not needed. JEB clients can no longer connect to a JEB floating controller using SSL. It used to be the case. What happened? # Warning This problem only manifests itself 1) with JEB <= 4.2 and 2) for which the controller uses a JDK >= April 2021 and 3) for which the controller is set up to use SSL/HTTPS (the .ControllerProtocol has the value 1) to communicate with floating clients. On April 20 2021, Oracle shipped JDKs deprecating the TLS v1/v1.1 protocols (e.g. JDK 8u291 onward, JDK 11.0.11 onward, etc.), which JEB floating clients <=4.2 require when connecting to a JEB controller. With default Java settings, the floating controller will simply reject such clients. You have 3 options: The solution is to upgrade JEB to 4.2.1/4.3 or above (recommended). A workaround is to tweak the Java settings on the controller: edit your java.security file (located in your JDK folder). You will see that \"TLSv1\" is located in the jdk.tls.disabledAlgorithms entry. Remove it from this entry and add it to the jdk.tls.legacyAlgorithms one. This will allow your JEB controller to accept incoming client requests. Another workaround is to use a slightly older Java build on the controller, for which TLSv1 is not deprecated. UI # JEB messages and strings are in my current (non-English) locale. How do I switch to English? # By default, JEB does its best to display messages in the current user's language settings. You may change the locale to English (or another one of the 10 supported languages ) via the Edit, Language menu. See the Settings for details. I am trying to debug an Android application, but my device cannot be found. # JEB relies on the Android Debug Bridge ( adb ) to debug Android applications. Make sure to: install the Android SDK (or at least have a stand-alone, working adb binary accessible from your PATH - some Linux distributions ship adb and other SDK platform tools in separate, leaner packages) have the SDK path referenced in one of the following environment variables: ANDROID_SDK_ROOT (preferred) or ANDROID_HOME (legacy). To troubleshoot your system, you may enable Developer Mode in your JEB options and examine the logger output. You will see lines like the following indicating how and where JEB is attempting to find adb : [adb] ANDROID_HOME: Environment variable added to list of candidate Android SDK locations [adb] ANDROID_SDK_ROOT: Environment variable NOT found [adb] PATH: added to list of searched folders: (redacted) [adb] Searching for 'adb.exe' in folders, by order: (redacted) [adb] Found and using: C:\\Users\\nicol\\AppData\\Local\\Android\\sdk\\platform-tools\\adb.exe Inside \"Find text\" widgets or filter fields, why are my regular expressions invalid or not working? # JEB uses Java-style regular expressions, not PCRE, Boost, or other type of regex. Although the differences are minimal and subtle, complex regular expressions need to be carefully crafted and abide by the Java Pattern standard (refer to the \"Comparison to Perl 5\" section specifically). I am using Ubuntu 16.04 LTS; the GUI behaves strangely and JEB closes unexpectedly. # If you are using Ubuntu 16 with a recent version of JEB, the following error message may be reported in the console: WARNING: GTK+ version too old (micro mismatch) WARNING: SWT requires GTK 3.20.0 WARNING: Detected: 3.18.9 When trying to use menus and widgets, unexpected errors will likely happen, including program termination. The reason is JEB 3.20+ UI framework (SWT) does not work properly with GTK 3.18-, used by Ubuntu 16: recent SWT builds require GTK 3.20+. In order to upgrade GTK without upgrading your entire distro to Ubuntu 18 or Ubuntu 20, you may use the following commands: sudo add-apt-repository ppa:gnome3-team/gnome3-staging sudo add-apt-repository ppa:gnome3-team/gnome3 sudo apt update sudo apt upgrade On Linux, I am seeing GTK error messages in the console. # Most of those messages are harmless. If you are suspecting issues, please email support. However, you may see the following message: \"HoverWidget can not be loaded due to xxxxxxx because there is no underlying browser available. Please ensure that WebKit with its GTK 3.x bindings is installed (WebKit2 API level is preferred). Additionally, please note that GTK4 does not currently have Browser support. Is libwebkitgtk-1.0-0 package installed?\" . It indicates that some pop-up overlays will not work until you install libwebkit2gtk : # find what version is available on your distro apt-cache search libwebkit2gtk # install the package (e.g. here, version 4.0.37) sudo apt install libwebkit2gtk-4.0.37 I am using an old version of Ubuntu (18, 16), and JEB crashes or behaves strangely. # A workaround is to start JEB with that environment variable set to avoid strange problems: GTK_DEBUG=no-pixel-cache The easiest way to set this up once and for all is to export GTK_DEBUG=no-pixel-cache and then run jeb_linux.sh . Updating # I work in a limited-connectivity environment, how can I update the software manually? # The procedure i: Check your registered email address for a JEB update email ( \"JEB xxx is available...\" ) Download the software archive Copy the archive to the root of your JEB folder and rename the file to update.zip Create a text file named update.pwd Store the email-provided password inside this file Start JEB as normal; the update will be installed automatically How do I update from JEB n to JEB n+1? # At the time of writing, you must install JEB n+1 (e.g. JEB 4) in a separate location. The auto-updater will only notify you that a JEB n+1 build is available for you to install. Check your email to download and install that new version. Can I update from the command-line? # Yes, you can run: $ <jeb_startup_script> -c --check-update After the update is downloaded, execute JEB normally. How can I update my license without updating the whole program? # You may update your licensing details without performing a full update. The steps are: Download your latest software archive (link in the JEB software update email). Copy the archive file bin/app/jeb-license.txt to your JEB's bin/app/ folder (overwrite the existing file). JEB just auto-updated and I am now experiencing strange runtime issues. What can I do? # If the issues you are experiencing are showing up after a software update, at seemingly random times during program execution, and involve error messages like \"Error invoking method\" or \"Failed to launch JVM\" , it is likely that your last JEB update did not fully complete. Try to execute your start-up script (eg, on Windows, jeb_wincon.bat ) instead of any native launcher you may have been previously using (such as an OS desktop task bar shortcut). If the issue is recurring, please email Support . Scripting # Can I execute a JEB Python script from the command line? # Yes. Here's how to use the built-in script runner. You will need a Pro license. Make sure your JEB scripts/ folder contains the jython-xxx.jar . Execute your JEB startup script with --srv2 and --script parameters, as well as optional script arguments after -- Example on Windows: $ jeb_wincon.bat -c --srv2 --script = SampleScript.py -- foo bar Use -c --help to learn about other options. API Command-line arguments (in the example above: foo , bar ) can be retrieved via IClientContext . Extensions Alternate ways exist to run scripts or plugins in headless contexts. Read through this guide and associated sample code if you want to know more about writing your own front-end clients. Can I write back-end extensions (plugins, contributions, etc.) in Python? # Not at the moment. Back-end extensions should be written in Java (or any other language compiling to Java classfile, e.g. Kotlin). Other # Is there a public bug/feature tracker? # Not at the moment. We are pretty responsive when it comes to answering users' queries though. Here's how to reach out: Join us on Slack and ask your question or make suggestions on #general For private inquiries, email us at Support You may also message us on the JEB Google Groups (although we don't use it much these days as it was superseded by the Slack channel) And of course, you can also reach out to us on Tweeter @jebdec","title":"FAQ"},{"location":"faq.html#licensing","text":"","title":"Licensing"},{"location":"faq.html#where-is-the-end-user-license-agreement","text":"The up-to-date end-user license agreement for JEB can be found here .","title":"Where is the end-user license agreement?"},{"location":"faq.html#can-i-generate-license-keys-for-additional-machines","text":"Yes, as long as the additional machines are operated by the licensee, they may install JEB on them. Contact licensing to request the ability to generate additional keys. We handle those requests promptly.","title":"Can I generate license keys for additional machines?"},{"location":"faq.html#can-i-revoke-license-keys","text":"Yes, JEB license keys can be deprecated. Contact licensing to request key revocation. We handle those requests promptly.","title":"Can I revoke license keys?"},{"location":"faq.html#i-need-to-reinstall-jeb-on-a-different-machine-should-i-generate-a-new-license-key","text":"Yes. Keys are specific to a user account. If you need to (re)install a non-floating build or the Controller for a floating build on a new system, make sure to generate a key on that system. If you are planning to copy configuration files over, remove the .LicenseKey entry of jeb-client.cfg and generate a new key upon first run.","title":"I need to reinstall JEB on a different machine. Should I generate a new license key?"},{"location":"faq.html#why-did-jeb-prompt-me-to-generate-a-new-key-even-though-i-have-not-changed-my-computer","text":"A key is derived from multiple machine identifiers, such as the operating system serial number. Those identifiers are supposedly stable, but may change on some occasions or situations, e.g. after a major OS upgrade, or when a security product or low-level software tool modifies or provides different values for those ids. In such instances, JEB will not be able to match the current license key with its expected value, and therefore, will ask for the user to generate a new key.","title":"Why did JEB prompt me to generate a new key even though I have not changed my computer?"},{"location":"faq.html#how-do-i-check-my-license-type-license-identifier-or-license-key","text":"From the command-line: execute JEB with the -c --license switches, eg: $ jeb_wincon.bat -c --license From the UI client: open the menu entry Help, About .","title":"How do I check my license type, license identifier, or license key?"},{"location":"faq.html#how-do-floating-licenses-work","text":"Floating licenses work on a per-seat basis, as opposed to other license types that work on a per-user basis. Example: A floating build valid for 3 seats allow any 3 users within your organization concurrently. A non-floating build valid for 3 users allow 3 fixed, determined users to use JEB. No other user can use it. Therefore, floating builds provide great flexibility for organizations where many users are planning to use JEB irregularly and/or at different times (e.g., teams split across various regions). Please refer to this Manual entry to learn about setting up floating Controller and Clients.","title":"How do floating licenses work?"},{"location":"faq.html#what-happens-when-my-license-subscription-expires","text":"JEB works on subscription. Past the expiration date, your software will continue to work and allow you to open and work on existing JDB2 projects, but you will not be able to create new projects.","title":"What happens when my license subscription expires?"},{"location":"faq.html#do-subscriptions-renew-automatically","text":"No. We do not perform auto-payments or auto-renewals. Please email sales when you need to renew a subscription.","title":"Do subscriptions renew automatically?"},{"location":"faq.html#do-you-offer-subscriptions-valid-for-more-than-one-year","text":"Yes, we do offer custom subscriptions for up to 3 years. Email us at sales for details.","title":"Do you offer subscriptions valid for more than one year?"},{"location":"faq.html#do-you-offer-perpetual-licenses","text":"No, we do not offer perpetual licenses at this point. However, we recommend you email sales and let us know your specific needs: we always strive to accommodate customers' needs.","title":"Do you offer perpetual licenses?"},{"location":"faq.html#do-you-provide-professional-support","text":"We do offer an additional support plan for JEB Pro and JEB Pro Floating licenses. Refer to the Buy page for details.","title":"Do you provide professional support?"},{"location":"faq.html#do-you-offer-large-volume-subscriptions","text":"Yes, we do have plans for large enterprise and government. Those plans include the possibility to generate large amount of license keys. Reach out to sales for additional details.","title":"Do you offer large volume subscriptions?"},{"location":"faq.html#we-developed-internal-tools-built-around-jeb-can-other-users-in-my-organization-use-them-without-breaking-the-eula","text":"Yes. As long as your JEB subscription is valid, users in your organization may access and use data produced by JEB.","title":"We developed internal tools built around JEB. Can other users in my organization use them without breaking the EULA?"},{"location":"faq.html#java","text":"","title":"Java"},{"location":"faq.html#which-version-of-java-shall-i-use-to-run-jeb-ui-client","text":"We recommend users to run the JEB client with a JDK 11 or above. With Java 9 and above, the native launcher ( jeb.exe on Windows, jeb on Linux, jeb.app/ on macOS) may not run smoothly. If that happens, you can bypass the native launcher by using the -j flag with your start-up script. Example, on Linux: jeb_linux.sh -j . If you have installed multiple versions of Java, make sure to set the JAVA_HOME environment variable to the JDK of your choice. The JEB client can always be started directly by executing jebc.jar on the command line: java -jar bin/app/jebc.jar","title":"Which version of Java shall I use to run JEB UI client?"},{"location":"faq.html#which-version-of-java-shall-i-use-to-run-non-ui-clients","text":"The back-end components of JEB, jeb.jar , works with with any version of Java 8.191 or above.","title":"Which version of Java shall I use to run non-UI clients?"},{"location":"faq.html#which-build-of-the-jdk-should-i-use","text":"Oracle builds or OpenJDK builds are preferred. It seems some UI problems with GTK/Linux were caused by custom builds, such as JetBrains's JDK. Other problems, including slowdowns and crashes during intensive processing, were reported by users using AdoptOpenJDK. For this reason, we strongly recommend to use Oracle/OpenJDK.","title":"Which build of the JDK should I use?"},{"location":"faq.html#i-am-encountering-strange-problems-on-windows-what-can-i-do","text":"The native launcher ( jeb.exe ) is called by jeb_wincon.bat by default on Windows. It does not play well with third-party JDKs, such as AdoptOpenJDK. To avoid problems, use -j to avoid using the native launcher: jeb_wincon.bat -j . Alternatively, you may use an Oracle JDK.","title":"I am encountering strange problems on Windows, what can I do?"},{"location":"faq.html#jeb-complains-that-it-requires-a-java-runtime-environment-although-i-have-one-installed","text":"Your java binary should be accessible from the PATH environment variable. It is also recommended to set a JAVA_HOME environment variable pointing to your Java installation folder (bin/). Make sure to install a 64-bit Java environment A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH or JAVA_HOME . You may have different versions of Java installed, but always make sure that paths refer to one that matches your system specifications.","title":"JEB complains that it \"requires a Java runtime environment\", although I have one installed."},{"location":"faq.html#how-can-i-increase-the-maximum-amount-of-memory-usable-by-jeb","text":"Create or edit the jvmopt.txt file at the root of your JEB folder. To specify an absolute maximum amount of memory, use -Xmx<Value><SizeUnit> . Example: -Xmx8G : allow JEB to use up to 8 Gb of memory. To specify a relative maximum amount of memory, use -XX:MaxRAMPercentage=<Ratio> . Example: -XX:MaxRAMPercentage=75.0 : allow JEB to use at most 75% of your RAM. The settings in jvmopt.txt must be on a single line. After modifying this file, restart JEB with your usual start-up script. On start-up, a message in the logger output will reflect the updated capability: Warning Do not edit the configuration files buried in bin/app/... or bin/jeb.app/... folders. The memory settings in those files are automatically pulled from jvmopt.txt.","title":"How can I increase the maximum amount of memory usable by JEB?"},{"location":"faq.html#program","text":"","title":"Program"},{"location":"faq.html#on-which-platforms-can-i-run-jeb","text":"The UI desktop client runs on Windows (x64), Linux (x64, arm64), and macOS (x64, arm64). The JEB back-end components, which can be used separately to build other clients or analysis pipelines, run on all systems for which a JDK 8 (or above) is available.","title":"On which platforms can I run JEB?"},{"location":"faq.html#what-do-i-need-to-run-jeb","text":"The only external dependency is Java: JDK 11 (or above) recommended; JDK 8 is also accepted but its support will be deprecated in 2022.","title":"What do I need to run JEB?"},{"location":"faq.html#how-can-i-run-multiple-instances-of-jeb","text":"Multiple instances of JEB can run natively without configuration changes.","title":"How can I run multiple instances of JEB?"},{"location":"faq.html#how-can-i-redirect-jeb-logs-to-files-on-disk","text":"Command-line runners, such as the floating license Controller or a script runner, can easily write log output to files. (Note that other clients, such as the UI desktop client, can do that via scripting - refer to GlobalLog .) Use the --logfile=... flag. Consult the Usage info for additional details on that switch ( \"--help\" ) Example: Start a JEB Controller on Windows and log all INFO-level (or above) output to \"controller.log.N\" files (max. 5 rotating files, max. 2 Mb of log per file): jeb_wincon.bat -c --controller --logfiles=controller.log,INFO,5,2","title":"How can I redirect JEB logs to files on disk?"},{"location":"faq.html#i-access-internet-via-a-proxy-can-i-still-use-jeb","text":"Proxy settings can be stored at those two locations: The UI client's settings, stored in jeb-client.cfg . If you are using the UI desktop client, they can be modified via the Options panel. In headless mode, set the proxy settings in jeb-engines.cfg instead. In each aforementioned configuration file, the network proxy data is stored as a key-value pair having the following format: .NetworkProxy = type|hostname|port|<username>|<password>|<whitelist> Allowed types: http , socks . 'username'/'password' can be left blank if your proxy does not require authentication 'whitelist' is an optional, comma-separated list of wildcard hostnames/IPs to which JEB should always attempt to direct-connect (no proxy) A few examples of valid proxy strings: - http|10.0.0.123|8080 - http|10.0.0.123|8080|| - http|10.0.0.123|8080||| - http|10.0.0.123|8080|||*.pnfsoftware.com - socks|proxy0.intranet.com|8088|user|pass|*.pnfsoftware.com Warning Do not forget the leading dot in .NetworkProxy!","title":"I access Internet via a proxy. Can I still use JEB?"},{"location":"faq.html#does-jeb-run-natively-on-apple-silicon-is-rosetta-2-needed-to-run-jeb-on-apple-silicon-machines","text":"JEB (>=4.0-beta.4) can run natively on arm64-powered macOS systems. The Rosetta conversion system is not needed.","title":"Does JEB run natively on Apple Silicon? Is Rosetta 2 needed to run JEB on Apple Silicon machines?"},{"location":"faq.html#jeb-clients-can-no-longer-connect-to-a-jeb-floating-controller-using-ssl-it-used-to-be-the-case-what-happened","text":"Warning This problem only manifests itself 1) with JEB <= 4.2 and 2) for which the controller uses a JDK >= April 2021 and 3) for which the controller is set up to use SSL/HTTPS (the .ControllerProtocol has the value 1) to communicate with floating clients. On April 20 2021, Oracle shipped JDKs deprecating the TLS v1/v1.1 protocols (e.g. JDK 8u291 onward, JDK 11.0.11 onward, etc.), which JEB floating clients <=4.2 require when connecting to a JEB controller. With default Java settings, the floating controller will simply reject such clients. You have 3 options: The solution is to upgrade JEB to 4.2.1/4.3 or above (recommended). A workaround is to tweak the Java settings on the controller: edit your java.security file (located in your JDK folder). You will see that \"TLSv1\" is located in the jdk.tls.disabledAlgorithms entry. Remove it from this entry and add it to the jdk.tls.legacyAlgorithms one. This will allow your JEB controller to accept incoming client requests. Another workaround is to use a slightly older Java build on the controller, for which TLSv1 is not deprecated.","title":"JEB clients can no longer connect to a JEB floating controller using SSL. It used to be the case. What happened?"},{"location":"faq.html#ui","text":"","title":"UI"},{"location":"faq.html#jeb-messages-and-strings-are-in-my-current-non-english-locale-how-do-i-switch-to-english","text":"By default, JEB does its best to display messages in the current user's language settings. You may change the locale to English (or another one of the 10 supported languages ) via the Edit, Language menu. See the Settings for details.","title":"JEB messages and strings are in my current (non-English) locale. How do I switch to English?"},{"location":"faq.html#i-am-trying-to-debug-an-android-application-but-my-device-cannot-be-found","text":"JEB relies on the Android Debug Bridge ( adb ) to debug Android applications. Make sure to: install the Android SDK (or at least have a stand-alone, working adb binary accessible from your PATH - some Linux distributions ship adb and other SDK platform tools in separate, leaner packages) have the SDK path referenced in one of the following environment variables: ANDROID_SDK_ROOT (preferred) or ANDROID_HOME (legacy). To troubleshoot your system, you may enable Developer Mode in your JEB options and examine the logger output. You will see lines like the following indicating how and where JEB is attempting to find adb : [adb] ANDROID_HOME: Environment variable added to list of candidate Android SDK locations [adb] ANDROID_SDK_ROOT: Environment variable NOT found [adb] PATH: added to list of searched folders: (redacted) [adb] Searching for 'adb.exe' in folders, by order: (redacted) [adb] Found and using: C:\\Users\\nicol\\AppData\\Local\\Android\\sdk\\platform-tools\\adb.exe","title":"I am trying to debug an Android application, but my device cannot be found."},{"location":"faq.html#inside-find-text-widgets-or-filter-fields-why-are-my-regular-expressions-invalid-or-not-working","text":"JEB uses Java-style regular expressions, not PCRE, Boost, or other type of regex. Although the differences are minimal and subtle, complex regular expressions need to be carefully crafted and abide by the Java Pattern standard (refer to the \"Comparison to Perl 5\" section specifically).","title":"Inside \"Find text\" widgets or filter fields, why are my regular expressions invalid or not working?"},{"location":"faq.html#i-am-using-ubuntu-1604-lts-the-gui-behaves-strangely-and-jeb-closes-unexpectedly","text":"If you are using Ubuntu 16 with a recent version of JEB, the following error message may be reported in the console: WARNING: GTK+ version too old (micro mismatch) WARNING: SWT requires GTK 3.20.0 WARNING: Detected: 3.18.9 When trying to use menus and widgets, unexpected errors will likely happen, including program termination. The reason is JEB 3.20+ UI framework (SWT) does not work properly with GTK 3.18-, used by Ubuntu 16: recent SWT builds require GTK 3.20+. In order to upgrade GTK without upgrading your entire distro to Ubuntu 18 or Ubuntu 20, you may use the following commands: sudo add-apt-repository ppa:gnome3-team/gnome3-staging sudo add-apt-repository ppa:gnome3-team/gnome3 sudo apt update sudo apt upgrade","title":"I am using Ubuntu 16.04 LTS; the GUI behaves strangely and JEB closes unexpectedly."},{"location":"faq.html#on-linux-i-am-seeing-gtk-error-messages-in-the-console","text":"Most of those messages are harmless. If you are suspecting issues, please email support. However, you may see the following message: \"HoverWidget can not be loaded due to xxxxxxx because there is no underlying browser available. Please ensure that WebKit with its GTK 3.x bindings is installed (WebKit2 API level is preferred). Additionally, please note that GTK4 does not currently have Browser support. Is libwebkitgtk-1.0-0 package installed?\" . It indicates that some pop-up overlays will not work until you install libwebkit2gtk : # find what version is available on your distro apt-cache search libwebkit2gtk # install the package (e.g. here, version 4.0.37) sudo apt install libwebkit2gtk-4.0.37","title":"On Linux, I am seeing GTK error messages in the console."},{"location":"faq.html#i-am-using-an-old-version-of-ubuntu-18-16-and-jeb-crashes-or-behaves-strangely","text":"A workaround is to start JEB with that environment variable set to avoid strange problems: GTK_DEBUG=no-pixel-cache The easiest way to set this up once and for all is to export GTK_DEBUG=no-pixel-cache and then run jeb_linux.sh .","title":"I am using an old version of Ubuntu (18, 16), and JEB crashes or behaves strangely."},{"location":"faq.html#updating","text":"","title":"Updating"},{"location":"faq.html#i-work-in-a-limited-connectivity-environment-how-can-i-update-the-software-manually","text":"The procedure i: Check your registered email address for a JEB update email ( \"JEB xxx is available...\" ) Download the software archive Copy the archive to the root of your JEB folder and rename the file to update.zip Create a text file named update.pwd Store the email-provided password inside this file Start JEB as normal; the update will be installed automatically","title":"I work in a limited-connectivity environment, how can I update the software manually?"},{"location":"faq.html#how-do-i-update-from-jeb-n-to-jeb-n1","text":"At the time of writing, you must install JEB n+1 (e.g. JEB 4) in a separate location. The auto-updater will only notify you that a JEB n+1 build is available for you to install. Check your email to download and install that new version.","title":"How do I update from JEB n to JEB n+1?"},{"location":"faq.html#can-i-update-from-the-command-line","text":"Yes, you can run: $ <jeb_startup_script> -c --check-update After the update is downloaded, execute JEB normally.","title":"Can I update from the command-line?"},{"location":"faq.html#how-can-i-update-my-license-without-updating-the-whole-program","text":"You may update your licensing details without performing a full update. The steps are: Download your latest software archive (link in the JEB software update email). Copy the archive file bin/app/jeb-license.txt to your JEB's bin/app/ folder (overwrite the existing file).","title":"How can I update my license without updating the whole program?"},{"location":"faq.html#jeb-just-auto-updated-and-i-am-now-experiencing-strange-runtime-issues-what-can-i-do","text":"If the issues you are experiencing are showing up after a software update, at seemingly random times during program execution, and involve error messages like \"Error invoking method\" or \"Failed to launch JVM\" , it is likely that your last JEB update did not fully complete. Try to execute your start-up script (eg, on Windows, jeb_wincon.bat ) instead of any native launcher you may have been previously using (such as an OS desktop task bar shortcut). If the issue is recurring, please email Support .","title":"JEB just auto-updated and I am now experiencing strange runtime issues. What can I do?"},{"location":"faq.html#scripting","text":"","title":"Scripting"},{"location":"faq.html#can-i-execute-a-jeb-python-script-from-the-command-line","text":"Yes. Here's how to use the built-in script runner. You will need a Pro license. Make sure your JEB scripts/ folder contains the jython-xxx.jar . Execute your JEB startup script with --srv2 and --script parameters, as well as optional script arguments after -- Example on Windows: $ jeb_wincon.bat -c --srv2 --script = SampleScript.py -- foo bar Use -c --help to learn about other options. API Command-line arguments (in the example above: foo , bar ) can be retrieved via IClientContext . Extensions Alternate ways exist to run scripts or plugins in headless contexts. Read through this guide and associated sample code if you want to know more about writing your own front-end clients.","title":"Can I execute a JEB Python script from the command line?"},{"location":"faq.html#can-i-write-back-end-extensions-plugins-contributions-etc-in-python","text":"Not at the moment. Back-end extensions should be written in Java (or any other language compiling to Java classfile, e.g. Kotlin).","title":"Can I write back-end extensions (plugins, contributions, etc.) in Python?"},{"location":"faq.html#other","text":"","title":"Other"},{"location":"faq.html#is-there-a-public-bugfeature-tracker","text":"Not at the moment. We are pretty responsive when it comes to answering users' queries though. Here's how to reach out: Join us on Slack and ask your question or make suggestions on #general For private inquiries, email us at Support You may also message us on the JEB Google Groups (although we don't use it much these days as it was superseded by the Slack channel) And of course, you can also reach out to us on Tweeter @jebdec","title":"Is there a public bug/feature tracker?"},{"location":"floating.html","text":"Getting Started # JEB Pro Floating licenses provide more flexibility than individual JEB Pro licenses, and can be distributed to many users within an organization. A floating build licensed for N seats will allow any N clients to connect to it concurrently. When a client leaves, its seat is vacated, allowing another JEB client to start by connecting to the Controller. JEB Clients regularly probe the Controller to determine whether or not they are allowed to run. The check is based on the number of seats available in your licensed build: for example, a floating license for 5 seats allows 5 different users to run JEB concurrently. In order to start the Controller, use the --controller flag along with the -c flag: Windows $ jeb_wincon.bat -c --controller Linux $ jeb_linux.sh -c --controller macOS $ jeb_macos.sh -c --controller Additional Controller-specific command-line flags ( --interface , --port , --protocol ) are detailed below. After starting the Controller, follow the prompt: You will be asked to input your password, accept the license agreement, and generate a license key. Sample log output: C:\\jeb>jeb_wincon.bat -c --controller JEB decryption password: *************** ... <EULA> ... Write \"yes\" to agree, then press enter: yes Hello Nicolas Falliere. Set up your JEB controller by generating a license key. This one-time operation will only take a few seconds. Please visit https://www.pnfsoftware.com/genlk, and use the following \"license data\" blob to generate a key License data: ............................................. Input your license key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Mode: Controller for floating clients Note: X client(s) may simultaneously connect to this controller instance Listening on 0.0.0.0/0.0.0.0:23477... If you need to customize the Controller's address or protocol, you may now stop it with the Ctrl+C keyboard command. Controller Settings # After the first step is completed successfully, executing the controller should display something like the following: C:\\jeb>jeb_wincon.bat -c --controller Mode: Controller for floating clients Note: X client(s) may simultaneously connect to this controller instance Listening on 0.0.0.0/0.0.0.0:23477... As can be seen, by default, the controller is listening on port 23477 on all interfaces, and uses the HTTP protocol . This can be changed by editing the configuration file bin/jeb-client.cfg and adding entries: .ControllerInterface = ... (default: 23477) .ControllerPort = ... (default: all interfaces) .ControllerProtocol = ... (default: 0 (HTTP)) Protocols currently supported are HTTP (0, the default) and HTTPS (1). Examples # Example: the Controller listens on all interfaces, port 30000, default protocol (HTTP): .ControllerPort = 30000 Example: the Controller listens on all interfaces, default port (23477), uses HTTPS (protocol 1): .ControllerProtocol = 1 Example: the Controller listens exclusively on localhost, port 30000, uses the default protocol HTTP: .ControllerInterface = localhost .ControllerPort = 35000 Example: the Controller listens on all interfaces, port 35000, explicitly uses HTTP (protocol 0): .ControllerPort = 35000 .ControllerProtocol = 0 Example: the Controller listens on 10.0.0.25, port 8443, and uses HTTPS instead of HTTP: .ControllerInterface = 10.0.0.25 .ControllerPort = 8443 .ControllerProtocol = 1 Client Settings # Start your desktop client using one of the standard start-up scripts. For example, on a Windows machine: Windows $ jeb_wincon.bat Linux $ jeb_linux.sh macOS $ jeb_macos.sh Your JEB client settings should mirror your Controller settings: specify the controller hostname/interface, port, and protocol, in your client's jeb-client.cfg. The first time you start your JEB UI client, a dialog box will request you to specify your Controller's location. You will also have the opportunity to configure your proxy settings, if you are using one. You may also configure your client's settings by directly editing jeb-client.cfg . Examples # Example: the Controller to connect to is at 192.168.23.45, default port (23477), default protocol (HTTP): .ControllerInterface = 192.168.23.45 Example: the Controller to connect to is at some-network.com, port 30000, protocol HTTP (explicitly specified): .ControllerInterface = some-network.com .ControllerPort = 35000 .ControllerProtocol = 0 Example: the Controller to connect to is at 10.0.0.25, port 8443, protocol HTTPS: .ControllerInterface = 10.0.0.25 .ControllerPort = 8443 .ControllerProtocol = 1 Technical Notes # JEB Clients as well as JEB Controller are the same binary file: there is no separate package for the Controller. The --controller flag and other floating-specific flags are only available for Floating builds. The Controller should be started before Clients. Clients regularly 'ping' the Controller. Therefore, the Controller should always be reachable by running instances of JEB client. To minimize potential problems due to network latency, it is recommended to run JEB and the Controller within the same local network (if possible). By default, the Controller listens on all interfaces, on port 23477, and uses the HTTP protocol for communication with its clients. This can be changed by setting the .ControllerInterface , .ControllerPort , .ControllerProtocol values in your configuration file. By default, the Controller and clients use HTTP for communication. In order to use HTTPS, make sure to set the .ControllerProtocol value in your configuration file to 1. (HTTPS is only available for JEB 3.0.6 and above.) JEB client instance and the Controller may be run in different environments (e.g., a Controller on Linux, Clients on Windows or macOS, etc.) The controller property .ControllerMessage is used to provide messages, visible by clients on the Controller portal. Your controller portal can be reached by visiting the web page: ControllerProtocol://ControllerInterface:ControllerPort , e.g. http://10.0.0.25:23477 or https://192.168.12.23:35000. It displays information about the controller capacity and currently connected clients. Controller settings can be provided by command-line flags --interface= , --port= , --protocol= . They take precedence over the settings in jeb-client.cfg . Examples: Start a controller on Linux, port 36000, listen on interfaces specified in the configuration file (or all if none are specified): jeb_linux.sh -c --controller --port=36000 Start a Windows client: jeb_windows.sh -c --controller --interface=192.168.0.56 --port=36000 Updating the Controller # There is no auto-update feature in the controller. The update procedure is: Check your registered email address for a JEB update email ( \"JEB xxx is available...\" ) Download the software archive Copy the archive to the root of your JEB folder and rename the file to update.zip Create a text file named update.pwd Store the email-provided password inside this file Start your controller as normal (e.g., ... -c --controller ); the update will be installed automatically Troubleshooting # Issues with SSL (Protocol 1) with JEB<=4.2 # If JEB clients cannot connect to a JEB floating controller when using SSL, see a possible reason below: Warning This problem only manifests itself 1) with JEB <= 4.2 and 2) for which the controller uses a JDK >= April 2021 and 3) for which the controller is set up to use SSL/HTTPS (the .ControllerProtocol has the value 1) to communicate with floating clients. On April 20 2021, Oracle shipped JDKs deprecating the TLS v1/v1.1 protocols (e.g. JDK 8u291 onward, JDK 11.0.11 onward, etc.), which JEB floating clients <=4.2 require when connecting to a JEB controller. With default Java settings, the floating controller will simply reject such clients. You have 3 options: The recommended solution is to upgrade JEB to 4.3 (dated July 13 2020) or above. A workaround is to tweak the Java settings on the controller: edit your java.security file (located in your JDK folder). You will see that \"TLSv1\" is located in the jdk.tls.disabledAlgorithms entry. Remove it from this entry and add it to the jdk.tls.legacyAlgorithms one. This will allow your JEB controller to accept incoming client requests. Another workaround is to use a slightly older Java build on the controller, for which TLSv1 is not deprecated.","title":"Floating Controller"},{"location":"floating.html#getting-started","text":"JEB Pro Floating licenses provide more flexibility than individual JEB Pro licenses, and can be distributed to many users within an organization. A floating build licensed for N seats will allow any N clients to connect to it concurrently. When a client leaves, its seat is vacated, allowing another JEB client to start by connecting to the Controller. JEB Clients regularly probe the Controller to determine whether or not they are allowed to run. The check is based on the number of seats available in your licensed build: for example, a floating license for 5 seats allows 5 different users to run JEB concurrently. In order to start the Controller, use the --controller flag along with the -c flag: Windows $ jeb_wincon.bat -c --controller Linux $ jeb_linux.sh -c --controller macOS $ jeb_macos.sh -c --controller Additional Controller-specific command-line flags ( --interface , --port , --protocol ) are detailed below. After starting the Controller, follow the prompt: You will be asked to input your password, accept the license agreement, and generate a license key. Sample log output: C:\\jeb>jeb_wincon.bat -c --controller JEB decryption password: *************** ... <EULA> ... Write \"yes\" to agree, then press enter: yes Hello Nicolas Falliere. Set up your JEB controller by generating a license key. This one-time operation will only take a few seconds. Please visit https://www.pnfsoftware.com/genlk, and use the following \"license data\" blob to generate a key License data: ............................................. Input your license key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Mode: Controller for floating clients Note: X client(s) may simultaneously connect to this controller instance Listening on 0.0.0.0/0.0.0.0:23477... If you need to customize the Controller's address or protocol, you may now stop it with the Ctrl+C keyboard command.","title":"Getting Started"},{"location":"floating.html#controller-settings","text":"After the first step is completed successfully, executing the controller should display something like the following: C:\\jeb>jeb_wincon.bat -c --controller Mode: Controller for floating clients Note: X client(s) may simultaneously connect to this controller instance Listening on 0.0.0.0/0.0.0.0:23477... As can be seen, by default, the controller is listening on port 23477 on all interfaces, and uses the HTTP protocol . This can be changed by editing the configuration file bin/jeb-client.cfg and adding entries: .ControllerInterface = ... (default: 23477) .ControllerPort = ... (default: all interfaces) .ControllerProtocol = ... (default: 0 (HTTP)) Protocols currently supported are HTTP (0, the default) and HTTPS (1).","title":"Controller Settings"},{"location":"floating.html#examples","text":"Example: the Controller listens on all interfaces, port 30000, default protocol (HTTP): .ControllerPort = 30000 Example: the Controller listens on all interfaces, default port (23477), uses HTTPS (protocol 1): .ControllerProtocol = 1 Example: the Controller listens exclusively on localhost, port 30000, uses the default protocol HTTP: .ControllerInterface = localhost .ControllerPort = 35000 Example: the Controller listens on all interfaces, port 35000, explicitly uses HTTP (protocol 0): .ControllerPort = 35000 .ControllerProtocol = 0 Example: the Controller listens on 10.0.0.25, port 8443, and uses HTTPS instead of HTTP: .ControllerInterface = 10.0.0.25 .ControllerPort = 8443 .ControllerProtocol = 1","title":"Examples"},{"location":"floating.html#client-settings","text":"Start your desktop client using one of the standard start-up scripts. For example, on a Windows machine: Windows $ jeb_wincon.bat Linux $ jeb_linux.sh macOS $ jeb_macos.sh Your JEB client settings should mirror your Controller settings: specify the controller hostname/interface, port, and protocol, in your client's jeb-client.cfg. The first time you start your JEB UI client, a dialog box will request you to specify your Controller's location. You will also have the opportunity to configure your proxy settings, if you are using one. You may also configure your client's settings by directly editing jeb-client.cfg .","title":"Client Settings"},{"location":"floating.html#examples_1","text":"Example: the Controller to connect to is at 192.168.23.45, default port (23477), default protocol (HTTP): .ControllerInterface = 192.168.23.45 Example: the Controller to connect to is at some-network.com, port 30000, protocol HTTP (explicitly specified): .ControllerInterface = some-network.com .ControllerPort = 35000 .ControllerProtocol = 0 Example: the Controller to connect to is at 10.0.0.25, port 8443, protocol HTTPS: .ControllerInterface = 10.0.0.25 .ControllerPort = 8443 .ControllerProtocol = 1","title":"Examples"},{"location":"floating.html#technical-notes","text":"JEB Clients as well as JEB Controller are the same binary file: there is no separate package for the Controller. The --controller flag and other floating-specific flags are only available for Floating builds. The Controller should be started before Clients. Clients regularly 'ping' the Controller. Therefore, the Controller should always be reachable by running instances of JEB client. To minimize potential problems due to network latency, it is recommended to run JEB and the Controller within the same local network (if possible). By default, the Controller listens on all interfaces, on port 23477, and uses the HTTP protocol for communication with its clients. This can be changed by setting the .ControllerInterface , .ControllerPort , .ControllerProtocol values in your configuration file. By default, the Controller and clients use HTTP for communication. In order to use HTTPS, make sure to set the .ControllerProtocol value in your configuration file to 1. (HTTPS is only available for JEB 3.0.6 and above.) JEB client instance and the Controller may be run in different environments (e.g., a Controller on Linux, Clients on Windows or macOS, etc.) The controller property .ControllerMessage is used to provide messages, visible by clients on the Controller portal. Your controller portal can be reached by visiting the web page: ControllerProtocol://ControllerInterface:ControllerPort , e.g. http://10.0.0.25:23477 or https://192.168.12.23:35000. It displays information about the controller capacity and currently connected clients. Controller settings can be provided by command-line flags --interface= , --port= , --protocol= . They take precedence over the settings in jeb-client.cfg . Examples: Start a controller on Linux, port 36000, listen on interfaces specified in the configuration file (or all if none are specified): jeb_linux.sh -c --controller --port=36000 Start a Windows client: jeb_windows.sh -c --controller --interface=192.168.0.56 --port=36000","title":"Technical Notes"},{"location":"floating.html#updating-the-controller","text":"There is no auto-update feature in the controller. The update procedure is: Check your registered email address for a JEB update email ( \"JEB xxx is available...\" ) Download the software archive Copy the archive to the root of your JEB folder and rename the file to update.zip Create a text file named update.pwd Store the email-provided password inside this file Start your controller as normal (e.g., ... -c --controller ); the update will be installed automatically","title":"Updating the Controller"},{"location":"floating.html#troubleshooting","text":"","title":"Troubleshooting"},{"location":"floating.html#issues-with-ssl-protocol-1-with-jeb42","text":"If JEB clients cannot connect to a JEB floating controller when using SSL, see a possible reason below: Warning This problem only manifests itself 1) with JEB <= 4.2 and 2) for which the controller uses a JDK >= April 2021 and 3) for which the controller is set up to use SSL/HTTPS (the .ControllerProtocol has the value 1) to communicate with floating clients. On April 20 2021, Oracle shipped JDKs deprecating the TLS v1/v1.1 protocols (e.g. JDK 8u291 onward, JDK 11.0.11 onward, etc.), which JEB floating clients <=4.2 require when connecting to a JEB controller. With default Java settings, the floating controller will simply reject such clients. You have 3 options: The recommended solution is to upgrade JEB to 4.3 (dated July 13 2020) or above. A workaround is to tweak the Java settings on the controller: edit your java.security file (located in your JDK folder). You will see that \"TLSv1\" is located in the jdk.tls.disabledAlgorithms entry. Remove it from this entry and add it to the jdk.tls.legacyAlgorithms one. This will allow your JEB controller to accept incoming client requests. Another workaround is to use a slightly older Java build on the controller, for which TLSv1 is not deprecated.","title":"Issues with SSL (Protocol 1) with JEB&lt;=4.2"},{"location":"misc.html","text":"This section describes miscellaneous features offered by the UI client. Saving and Loading # A JEB project can be persisted to a file on disk called a JEB Database file. They have a .jdb2 extension. JDB2 files can be shared among users, and reloaded at a later time. They can grow significantly larger than the original artifact(s), as they contain the analysis results for all - or most of all, see below - units in your project. They are encrypted and compressed . Each JEB plugin/module is responsible for providing persistence of their result units. All PNF Software modules support persistence. Warning Make sure to load a JDB2 with a version of JEB equal or newer than the one that generated that JDB2. Quick Save # The analysis of large artifacts, yielding potentially hundreds or thousands of units, can translate into very large JDB2. For such projects, the UI client may offer the user to \"quick-save\" instead of performing a regular \"full-save\". Quick saves are almost instantaneous, and generate lean JDB2 files. However, not all data is persisted in QuickSave'd JDB2. At the time of writing, QuickSave is supported for APK/DEX units and Native Code analysis units. The data items saved in a QuickSave JDB2 are: comments (primary inline, primary pre) labels renamed items (packages, classes, methods, fields, etc.) identifier names project properties Note: currently, the GUI client auto-suggests Quick-save for APK having a size of 10+ Mb. See the back-end property .project.PersistenceStrategy to customize whether quick-save should be always used, never used, or used on-demand. Notifications # Notifications are generated by modules when they encounter areas of interest during analysis of their input data. The menu entry File, Notifications allows the user to view notifications for all units produced in the currently opened project. In the example below, the Android DEX plugin has generated a notification indicating that the Android app contained multiple DEX files, and that those were merged successfully: Notifications are generated at the discretion of the analysis modules. They can be classified in one of nine levels: Type Description AREA_OF_INTEREST A generic type to signify an area of interest within a unit. CORRUPTION Input corruption has been detected. DEPRECATED_FEATURE The unit has detected features that have been deprecated. ERROR A generic type to signify an error in the unit. INFO A generic type similar to AREA_OF_INTEREST. MALICIOUS The intent is malicious. POTENTIALLY_HARMFUL This type indicates usage of a feature not recommended by guidelines due to its potential dangerousness. UNSUPPORTED_FEATURE Some input cannot be parsed because of a limitation within the unit itself. WARNING A generic type to signify a warning in the unit. Note See this reference page for additional details on notification types. Exporting Output # Users may export analyzed data via one the sub-commands in the File, Export menu entries: Export some or all decompilations. Export all binary units to multiple files on disk Export the active fragment to raw text or html (with coloration similar to JEB's text views). Make sure to focus a code view or a decompiled code view before attempting to run this command. This command is accessible via the File, Export menu entry. Project Properties # The properties of a project can be examined by right-clicking the project node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the project node is selected. The name is customizable. The default name is always derived from the primary artifact, with a JDB2 extension. This extension stands for \"JEB Database Version 2\", and represent a serialized version of your project which users can save and load on their JEB version 2 software. The creation and modification timestamps are read-only. The user-notes are writable and saved with the JDB2. Artifact Properties # Similarly to Project properties, the properties of an artifact can be examined by right-clicking the artifact node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the artifact node is selected. Unit Properties # Similar to Project and Artifact properties, the properties of a unit can be examined by right-clicking the corresponding unit node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the unit node is selected. The unit name is customizable, however, we recommend users to not change unit names . The unit type corresponds to the module type that created the unit (in this example, 'apk') The creation timestamp is the time at which the unit was created from its parent artifact or unit The status field indicates potential problems: N/A means the unit was processed properly, and its contents can be examined; other string messages can be reported by modules to indicate processing error, or simply, lack of processing in the case of lazy processing. If the unit is backed by bytes, on a file or in memory, the size is also specified Listing Parsers # The full list of input processor plugins (whose term was simplified to parsers in the UI) loaded within your JEB instance context can be seen by running the File, Plugins, Parsers command. Parsers can be selectively disabled if needed. For example, if you would like JEB to not process Zip files as such (i.e., treat them as plain binary files), you may disable the zip parser. API Technically speaking, parsers are JEB plugins that implement the IUnitIdentifier interface. Refer to the Developing with JEB section of this guide for more information. Adding Artifacts # Commonly, most projects will contain a single artifact file, such as a binary executable or an application file. However, you may add as many artifacts as you want to a project Select the menu entry File, Add an Artifact to add an artifact to an existing project. The newly added artifact will be processed, and added to the current project tree: Reparsing Data # This advanced feature is available by right-clicking a unit in the Project Explorer view, and selecting Parse at... : Reparsing allows users to (re)parse a unit or parts of a unit by specifying explicitly what the input data should be parsed as. For instance, you may have input data identified as XML data, and initially parsed as such - therefore yielding an XML unit. However, you may discover that this XML data contains bytes that would correspond to a Zip file (eg, starting with PK... ). By reparsing the XML data at the given Zip header offset using the Zip module, you ask JEB to process that data as Zip and create a zip unit from it: Reparsing can be helpful when dealing with complicated, obfuscated, or multi-layered files.","title":"Miscellaneous"},{"location":"misc.html#saving-and-loading","text":"A JEB project can be persisted to a file on disk called a JEB Database file. They have a .jdb2 extension. JDB2 files can be shared among users, and reloaded at a later time. They can grow significantly larger than the original artifact(s), as they contain the analysis results for all - or most of all, see below - units in your project. They are encrypted and compressed . Each JEB plugin/module is responsible for providing persistence of their result units. All PNF Software modules support persistence. Warning Make sure to load a JDB2 with a version of JEB equal or newer than the one that generated that JDB2.","title":"Saving and Loading"},{"location":"misc.html#quick-save","text":"The analysis of large artifacts, yielding potentially hundreds or thousands of units, can translate into very large JDB2. For such projects, the UI client may offer the user to \"quick-save\" instead of performing a regular \"full-save\". Quick saves are almost instantaneous, and generate lean JDB2 files. However, not all data is persisted in QuickSave'd JDB2. At the time of writing, QuickSave is supported for APK/DEX units and Native Code analysis units. The data items saved in a QuickSave JDB2 are: comments (primary inline, primary pre) labels renamed items (packages, classes, methods, fields, etc.) identifier names project properties Note: currently, the GUI client auto-suggests Quick-save for APK having a size of 10+ Mb. See the back-end property .project.PersistenceStrategy to customize whether quick-save should be always used, never used, or used on-demand.","title":"Quick Save"},{"location":"misc.html#notifications","text":"Notifications are generated by modules when they encounter areas of interest during analysis of their input data. The menu entry File, Notifications allows the user to view notifications for all units produced in the currently opened project. In the example below, the Android DEX plugin has generated a notification indicating that the Android app contained multiple DEX files, and that those were merged successfully: Notifications are generated at the discretion of the analysis modules. They can be classified in one of nine levels: Type Description AREA_OF_INTEREST A generic type to signify an area of interest within a unit. CORRUPTION Input corruption has been detected. DEPRECATED_FEATURE The unit has detected features that have been deprecated. ERROR A generic type to signify an error in the unit. INFO A generic type similar to AREA_OF_INTEREST. MALICIOUS The intent is malicious. POTENTIALLY_HARMFUL This type indicates usage of a feature not recommended by guidelines due to its potential dangerousness. UNSUPPORTED_FEATURE Some input cannot be parsed because of a limitation within the unit itself. WARNING A generic type to signify a warning in the unit. Note See this reference page for additional details on notification types.","title":"Notifications"},{"location":"misc.html#exporting-output","text":"Users may export analyzed data via one the sub-commands in the File, Export menu entries: Export some or all decompilations. Export all binary units to multiple files on disk Export the active fragment to raw text or html (with coloration similar to JEB's text views). Make sure to focus a code view or a decompiled code view before attempting to run this command. This command is accessible via the File, Export menu entry.","title":"Exporting Output"},{"location":"misc.html#project-properties","text":"The properties of a project can be examined by right-clicking the project node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the project node is selected. The name is customizable. The default name is always derived from the primary artifact, with a JDB2 extension. This extension stands for \"JEB Database Version 2\", and represent a serialized version of your project which users can save and load on their JEB version 2 software. The creation and modification timestamps are read-only. The user-notes are writable and saved with the JDB2.","title":"Project Properties"},{"location":"misc.html#artifact-properties","text":"Similarly to Project properties, the properties of an artifact can be examined by right-clicking the artifact node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the artifact node is selected.","title":"Artifact Properties"},{"location":"misc.html#unit-properties","text":"Similar to Project and Artifact properties, the properties of a unit can be examined by right-clicking the corresponding unit node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the unit node is selected. The unit name is customizable, however, we recommend users to not change unit names . The unit type corresponds to the module type that created the unit (in this example, 'apk') The creation timestamp is the time at which the unit was created from its parent artifact or unit The status field indicates potential problems: N/A means the unit was processed properly, and its contents can be examined; other string messages can be reported by modules to indicate processing error, or simply, lack of processing in the case of lazy processing. If the unit is backed by bytes, on a file or in memory, the size is also specified","title":"Unit Properties"},{"location":"misc.html#listing-parsers","text":"The full list of input processor plugins (whose term was simplified to parsers in the UI) loaded within your JEB instance context can be seen by running the File, Plugins, Parsers command. Parsers can be selectively disabled if needed. For example, if you would like JEB to not process Zip files as such (i.e., treat them as plain binary files), you may disable the zip parser. API Technically speaking, parsers are JEB plugins that implement the IUnitIdentifier interface. Refer to the Developing with JEB section of this guide for more information.","title":"Listing Parsers"},{"location":"misc.html#adding-artifacts","text":"Commonly, most projects will contain a single artifact file, such as a binary executable or an application file. However, you may add as many artifacts as you want to a project Select the menu entry File, Add an Artifact to add an artifact to an existing project. The newly added artifact will be processed, and added to the current project tree:","title":"Adding Artifacts"},{"location":"misc.html#reparsing-data","text":"This advanced feature is available by right-clicking a unit in the Project Explorer view, and selecting Parse at... : Reparsing allows users to (re)parse a unit or parts of a unit by specifying explicitly what the input data should be parsed as. For instance, you may have input data identified as XML data, and initially parsed as such - therefore yielding an XML unit. However, you may discover that this XML data contains bytes that would correspond to a Zip file (eg, starting with PK... ). By reparsing the XML data at the given Zip header offset using the Zip module, you ask JEB to process that data as Zip and create a zip unit from it: Reparsing can be helpful when dealing with complicated, obfuscated, or multi-layered files.","title":"Reparsing Data"},{"location":"native.html","text":"JEB is fully-equipped to perform native code analysis of binary files compiled for Windows (PE), Linux and variants (ELF), or most other platforms, including headless firmware files. Info Find additional documentation about JEB's native analysis pipeline (code analysis and decompilation) on our blog: List of posts tagged Native Code . Decompilers # JEB Pro ships with analysis modules, including gendec decompilers for Intel x86, ARM, MIPS, RISC-V, Ethereum, WebAssembly, and more. gendec is a deobfuscating decompiler that will attempt to clean and restructure binary code as much as it can. It ships with many built-in optimizers, including advanced ones such as control-flow unflattener, opaque predicate cleaner, various code cleaners, etc. and is also extensible for users that wish to craft their own IR plugins. Find out more about gendec on our blog . Siglibs # JEB supports the creation of signature libraries ( siglibs ) for library code recognition. JEB Pro includes complete library signature sets for: Android NDK libraries (ARM/ARM64). Common libraries (libc, libc++, zlib, etc.) are signed from NDK v11 up to the latest version (v20 as of 11/19). Microsoft Visual Studio libraries (x86/x86-64). C runtime libraries and standard C++ libraries are signed from Visual Studio 2003 up to Visual Studio 2019. Note Users can generate their own signature libraries: Native Signatures Generation (blog) ; Android NDK signatures presentation Android NDK Library Signatures (blog) Typelibs # JEB supports the creation of type libraries ( typelibs ) for common Windows and Linux subsystems, including: Android NDK on ARM 32-bit Android NDK on ARM 64-bit Android NDK on x86 32-bit Android NDK on x86 64-bit Windows win32 on Intel x86 32-bit Windows win32 on Intel x86 64-bit Windows win32 on ARM 32-bit Windows win32 on ARM 64-bit Windows DDK on Intel x86 32-bit Windows DDK on Intel x86 64-bit Linux glibc on Intel x86 32-bit Linux glibc on ARM 32-bit Linux glibc on MIPS 32-bit Note Users can generate their own type libraries: Native Types and Typelibs (blog) Native Code Actions # Common native code actions can Be found in the Native menu: Analysis Types # Standard Analysis # Leave the default settings. Quick Analysis # The simplest and fastest type of initial analysis can be achieved with the following settings: Analysis Style: select LAZY NO DATA Advanced Analysis: Disabled RTTI recovery: Disabled Global Analysis: Disabled Signatures Package Loading (siglib): Disabled Tail call analysis: Disabled Switch Analysis: Disabled Section to be completed","title":"Native Code Analysis"},{"location":"native.html#decompilers","text":"JEB Pro ships with analysis modules, including gendec decompilers for Intel x86, ARM, MIPS, RISC-V, Ethereum, WebAssembly, and more. gendec is a deobfuscating decompiler that will attempt to clean and restructure binary code as much as it can. It ships with many built-in optimizers, including advanced ones such as control-flow unflattener, opaque predicate cleaner, various code cleaners, etc. and is also extensible for users that wish to craft their own IR plugins. Find out more about gendec on our blog .","title":"Decompilers"},{"location":"native.html#siglibs","text":"JEB supports the creation of signature libraries ( siglibs ) for library code recognition. JEB Pro includes complete library signature sets for: Android NDK libraries (ARM/ARM64). Common libraries (libc, libc++, zlib, etc.) are signed from NDK v11 up to the latest version (v20 as of 11/19). Microsoft Visual Studio libraries (x86/x86-64). C runtime libraries and standard C++ libraries are signed from Visual Studio 2003 up to Visual Studio 2019. Note Users can generate their own signature libraries: Native Signatures Generation (blog) ; Android NDK signatures presentation Android NDK Library Signatures (blog)","title":"Siglibs"},{"location":"native.html#typelibs","text":"JEB supports the creation of type libraries ( typelibs ) for common Windows and Linux subsystems, including: Android NDK on ARM 32-bit Android NDK on ARM 64-bit Android NDK on x86 32-bit Android NDK on x86 64-bit Windows win32 on Intel x86 32-bit Windows win32 on Intel x86 64-bit Windows win32 on ARM 32-bit Windows win32 on ARM 64-bit Windows DDK on Intel x86 32-bit Windows DDK on Intel x86 64-bit Linux glibc on Intel x86 32-bit Linux glibc on ARM 32-bit Linux glibc on MIPS 32-bit Note Users can generate their own type libraries: Native Types and Typelibs (blog)","title":"Typelibs"},{"location":"native.html#native-code-actions","text":"Common native code actions can Be found in the Native menu:","title":"Native Code Actions"},{"location":"native.html#analysis-types","text":"","title":"Analysis Types"},{"location":"native.html#standard-analysis","text":"Leave the default settings.","title":"Standard Analysis"},{"location":"native.html#quick-analysis","text":"The simplest and fastest type of initial analysis can be achieved with the following settings: Analysis Style: select LAZY NO DATA Advanced Analysis: Disabled RTTI recovery: Disabled Global Analysis: Disabled Signatures Package Loading (siglib): Disabled Tail call analysis: Disabled Switch Analysis: Disabled Section to be completed","title":"Quick Analysis"},{"location":"settings.html","text":"This section describes settings and additional configuration panels offered by the UI client. Theme # JEB ships with three themes: a default theme: which will be light if the system rendered the application widgets with a white or light colored background (as is the default on most operating systems) which will be dark if the application widgets provided by the operating system were dark a Dark theme a Light (~sepia) fall-back theme Toggle from Default to Dark to Light via the Edit, Theme command, or the MOD1+Shift+Alt+T keyboard shortcut (MOD1= Ctrl on Windows/Linux, Command on macOS). Note The fall-back light theme was added mostly for macOS users running JEB with recent JDK (>8) whose system is configured in Dark Mode but prefer running JEB with lighter colors. Default theme Default theme on a Dark Mode system Dark Theme Light Theme Styles and Fonts # The Edit menu (or the Application menu on Mac) allows users to customize the styles of interactive item as well as the code font used by most JEB views. Make sure to select a fixed font. JEB tries its best to select the most appropriate font on your system. If that fails, and you wish to select a font manually, we recommend Consolas on Windows, Menlo/Monaco on Mac, or DejaVu Sans Mono on Linux. Unicode JEB supports Unicode. While the aforementioned fonts have good support for a variety of common non-ASCII planes (CJK, Cyrillic, etc.), you might need to use a different font to properly examine strings written in exotic locales. Keyboard Shortcuts # Most JEB command handlers can be triggered by keyboard shortcuts. The default shortcuts are visible when visualizing menu items. To customize keyboard shortcuts: in JEB's bin/ folder, copy jeb-shortcuts.cfg.TEMPLATE to jeb-shortcuts.cfg edit jeb-shortcuts.cfg : uncomment the command lines for which you wish to use custom keyboard shortcuts Refer to the jeb-shortcuts.cfg.TEMPLATE file in your bin/ folder for details: #------------------------------------------------------------------------------ # JEB Custom Keyboard Shortcuts #------------------------------------------------------------------------------ # 1) Rename or copy this file to jeb-shortcuts.cfg # 2) Uncomment and add your own keyboard shortcuts for the actions for which you'd like to override the default shortcuts # Example: by default, Jump is mapped to the 'G' key; the following line (minus the # character) can be used to remap the action to CTRL+J: #jump=Ctrl+J # *** CUSTOMIZABLE HANDLERS *** #runScript= #runLastScript= #share= ... Example: Changing the shortcut for the 'Comment' action to ';' (instead of '/') Locale # The UI client front-end is available in English as well as 10 additional languages. Select your preferred language via the Edit menu: Note The back-end components (modules and plugins) are not localized at the moment. Only front-end components were localized. Non-English locales having partial support at the moment are: Chinese, French, German, Italian, Japanese, Korean, Portuguese, Russian, Spanish, Turkish. Simple Options # Simple options are accessible via the Edit or Application menu. Two panels, General and Development , offer a partial view of JEB's configuration files, described in upcoming sections. General options # You may customize your packaged plugins directory. Packaged plugins are third-party Jar modules that add functionality to JEB: they can be parsers, disassemblers, decompilers, debuggers, code analyzers, etc. Customize your auto-update options. http and socks proxy are supported. Specify your log levels (normal, debug, warning only, etc.). Log messages are output in the Logger window. The 'Specific Project Properties' button is not shown when no project is loaded Development options # The Development mode enables verbose logging for increased insight into the program. The plugin classpath and classname widgets allow setting up non-packaged Java plugins, which makes developing them easier. All Options # Most JEB options are stored in two configuration files, jeb-client.cfg (front-end options) and jeb-engines.cfg (back-end options). You may configure them via the Options Tree dialogs accessible by pressing the 'Xxx Properties' buttons. Warning The 'Specific Project Properties' is used to modify the back-end properties of your current project only. Front-end properties Front-end options # See this document . Back-end options # See this document .","title":"Settings"},{"location":"settings.html#theme","text":"JEB ships with three themes: a default theme: which will be light if the system rendered the application widgets with a white or light colored background (as is the default on most operating systems) which will be dark if the application widgets provided by the operating system were dark a Dark theme a Light (~sepia) fall-back theme Toggle from Default to Dark to Light via the Edit, Theme command, or the MOD1+Shift+Alt+T keyboard shortcut (MOD1= Ctrl on Windows/Linux, Command on macOS). Note The fall-back light theme was added mostly for macOS users running JEB with recent JDK (>8) whose system is configured in Dark Mode but prefer running JEB with lighter colors. Default theme Default theme on a Dark Mode system Dark Theme Light Theme","title":"Theme"},{"location":"settings.html#styles-and-fonts","text":"The Edit menu (or the Application menu on Mac) allows users to customize the styles of interactive item as well as the code font used by most JEB views. Make sure to select a fixed font. JEB tries its best to select the most appropriate font on your system. If that fails, and you wish to select a font manually, we recommend Consolas on Windows, Menlo/Monaco on Mac, or DejaVu Sans Mono on Linux. Unicode JEB supports Unicode. While the aforementioned fonts have good support for a variety of common non-ASCII planes (CJK, Cyrillic, etc.), you might need to use a different font to properly examine strings written in exotic locales.","title":"Styles and Fonts"},{"location":"settings.html#keyboard-shortcuts","text":"Most JEB command handlers can be triggered by keyboard shortcuts. The default shortcuts are visible when visualizing menu items. To customize keyboard shortcuts: in JEB's bin/ folder, copy jeb-shortcuts.cfg.TEMPLATE to jeb-shortcuts.cfg edit jeb-shortcuts.cfg : uncomment the command lines for which you wish to use custom keyboard shortcuts Refer to the jeb-shortcuts.cfg.TEMPLATE file in your bin/ folder for details: #------------------------------------------------------------------------------ # JEB Custom Keyboard Shortcuts #------------------------------------------------------------------------------ # 1) Rename or copy this file to jeb-shortcuts.cfg # 2) Uncomment and add your own keyboard shortcuts for the actions for which you'd like to override the default shortcuts # Example: by default, Jump is mapped to the 'G' key; the following line (minus the # character) can be used to remap the action to CTRL+J: #jump=Ctrl+J # *** CUSTOMIZABLE HANDLERS *** #runScript= #runLastScript= #share= ... Example: Changing the shortcut for the 'Comment' action to ';' (instead of '/')","title":"Keyboard Shortcuts"},{"location":"settings.html#locale","text":"The UI client front-end is available in English as well as 10 additional languages. Select your preferred language via the Edit menu: Note The back-end components (modules and plugins) are not localized at the moment. Only front-end components were localized. Non-English locales having partial support at the moment are: Chinese, French, German, Italian, Japanese, Korean, Portuguese, Russian, Spanish, Turkish.","title":"Locale"},{"location":"settings.html#simple-options","text":"Simple options are accessible via the Edit or Application menu. Two panels, General and Development , offer a partial view of JEB's configuration files, described in upcoming sections.","title":"Simple Options"},{"location":"settings.html#general-options","text":"You may customize your packaged plugins directory. Packaged plugins are third-party Jar modules that add functionality to JEB: they can be parsers, disassemblers, decompilers, debuggers, code analyzers, etc. Customize your auto-update options. http and socks proxy are supported. Specify your log levels (normal, debug, warning only, etc.). Log messages are output in the Logger window. The 'Specific Project Properties' button is not shown when no project is loaded","title":"General options"},{"location":"settings.html#development-options","text":"The Development mode enables verbose logging for increased insight into the program. The plugin classpath and classname widgets allow setting up non-packaged Java plugins, which makes developing them easier.","title":"Development options"},{"location":"settings.html#all-options","text":"Most JEB options are stored in two configuration files, jeb-client.cfg (front-end options) and jeb-engines.cfg (back-end options). You may configure them via the Options Tree dialogs accessible by pressing the 'Xxx Properties' buttons. Warning The 'Specific Project Properties' is used to modify the back-end properties of your current project only. Front-end properties","title":"All Options"},{"location":"settings.html#front-end-options","text":"See this document .","title":"Front-end options"},{"location":"settings.html#back-end-options","text":"See this document .","title":"Back-end options"},{"location":"tips.html","text":"Tips of the Day # Getting Started # Welcome! If this is your first run, you should be presented with an empty JEB workspace. Create a new project by opening a file (menu File, command Open ) to be analyzed: it can be a PE file, an ELF file, an APK or DEX file, or anything else that your JEB build has plugin support for. After an initial analysis pass, your main workspace will display an interactive disassembly listing, as well as a Project tree and a Code Hierarchy tree. You may navigate and modify your analysis via the Actions menu. If you are looking to decompile code, position yourself somewhere in the disassembly and hit the TAB key. Decompiling # In the Disassembly view, right-click and select Decompile , or use the Action menu, Decompile command. You can navigate back to the Disassembly in a similar way. Check your Decompilers # JEB decompilers are plugins. Check which decompilers ship with your build by using the File menu, Decompilers command. JEB Community Edition bundles the x86 decompilers. JEB Android ships with everything Android. JEB Pro ships withs everything. JEB Demo as well, but with several limitations. The Omnibox # The omnibox is a text input box located on the right side of the toolbar (default hotkey: F3). It allows users to search and quickly visualize (and navigate to) any type of item referenced in your JEB project. From strings to code, comments, bookmarks, command names, and text contents. Type anything you can think of in this box. Bookmarks # Bookmark your favorite locations using the Control+F12 hotkey (Command+F12 on macOS). Your project-wide list of bookmarks is accessible with F12. These commands are also accessible from the Navigation menu. Basic Reversing Actions # Common analysis actions are located in the Action menu. They include decompiling, renaming items, viewing cross-references, adding comments, etc. Other actions, specific to a given class of files or analysis, are located in other menus (e.g. Android, Native, Debugger). Units and Documents # In JEB, the analysis of an artifact (typically, an input file) yields objects called \"units\". An artifact usually produces a tree of several units, including code units. Units can be rendered as documents, including text buffers, tables and trees. A code unit will generate a Disassembly document, among many other documents. Android Global Analysis # If you are analyzing an APK or Dex file, it is usually a good idea to run a Global Analysis pass. This analysis will use the decompiler, emulator, and sandboxing engine to find interesting things in the code, such as encrypted strings and constants or reflected accesses. Customizing the Emulator used by the Android Global Analysis # Check out the Emulator Settings command in the Android menu to customize the emulator and sandboxing engine policies and time-outs. Android and Side-effect-free code # This Android analysis setting allows you to specify a list of methods which are guaranteed to have no side-effect (e.g. no field update, directly or indirectly) outside of providing a return value. This list is used by some code optimizers to further enhance decompilations. Control Flow Graph (CFG) View # When located on a disassembled method, press the Space bar to switch from a flat listing to a CFG view of the method. Press Space to switch back to the listing view. Multi-file Projects # JEB can handle more than one file in a single project. The first artifact will determine your project name, but other artifacts can be added whenever needed via the File menu, Add an Artifact command. Multi-format Support # JEB handles any type of file, from raw bytes to PE to ELF to APK to DEX, but also archives, documents, etc. You can explore a file, its structure, and analyze its constituents using the Project Explorer panel. Rebasing Constants # Immediates can be rebased using the B hotkey (or via the Action menu, Convert command). Depending on the code unit, different bases will be offered, including decimal, hexadecimal, octal, character, or binary string. Reopening a View # If you ever close an important view, you can always reopen it by clicking on its corresponding unit in the Project Explorer view, right-click, then Open View command. Exotic Decompilers # Did you know that JEB can decompile all sorts of formats? From Android dex to the classic x86 and Arm, less classic Mips, but also more exotic ones like Ethereum smart contracts compiled to EVM bytecode, or WebAssembly modules. Type Hierarchies # When on a type object (class or interface), use the Action, Type Hierarchy command (hotkey H) to view the selected type hierarchy, such as super-types, sub-types, and implemented interfaces. Method and Fields Overrides # When on a method object, use the Action, Overrides command to check the implementations in sub-classes, as well as parent implementations in super types. The command also works for fields to see overrides (by name) in sub-classes. Organize your Code # JEB supports packages and namespaces. Create packages, move code objects (methods, classes, etc.) to them by drag-and-dropping inside the Code Hierarchy panel, or use the Action menu, Create a Package / Move to a Package commands. This command, like all actions located in the Actions menu, is available for native code as well as dex code. Analyzing Ethereum smart contracts # The Ethereum plugins currently support the analysis of EVM bytecode contracts (ewasm contracts are also supported, with the help of the wasm plugins for JEB). Open a contract using the File menu, Open Smart Contract command. The contract node will be named \"DecompiledContract\". Blanket Renaming # The action \"Auto-Rename All\" allows the renaming of all or a selection of the items in a project. This action is very handy when analyzing an obfuscated file whose meaningless names create confusion. One Decompilation, One Tab # The \"Do not replace Views\" command, located in the Navigation menu, instructs the GUI client to keep tabs holding a similar view type to stay open when a different view of the same type is opened (else, the tab contents would simply be updated). It is handy when you need to have multiple decompilations opened in separate views. Bulk decompilations # If you need to decompile all code and export it to disk, check the File menu, Export Decompilation command. You will be able to select which part of your project should be decompiled and where it should be written to. Notifications # All plugins can issue sticky notifications that will be saved in the project (as opposed to pure log messages, which are not persisted). The notifications dialog can be opened from the toolbar or File menu. Double-click an entry or click Navigate to jump to the appropriate unit document and address (if the notification has an address attached to it). Dark Theme vs Light Theme # Use the Switch Theme command (in the Edit menu) to switch from your system-recommended theme to a Dark theme or Light (sepia) theme. Scripting in Python # The JEB API is a comprehensive application programming interface used by JEB clients (including the main GUI program) to communicate with the back-end. Power-users can write JEB extensions that make use of the API to script tasks, have custom plugins, etc. To get accustomed to the API, it is best to start writing Python script (2.7 syntax) doing relatively simple things. JEB ships with many samples, located in the scripts/samples/ folder. Bring up the Scripts selector dialog with F2. You can execute, create, or edit existing scripts. In the example below, the UI API is used to create a custom graph object showing relationship between various code items in a code object. Writing extensions in Java # The JEB API is a comprehensive application programming interface used by JEB clients (including the main GUI program) to communicate with the back-end. Power-users can write JEB extensions that make use of the API to script tasks, have custom plugins, etc. Unlike JEB Python scripts (see the previous tip), extensions written in Java can be loaded as full JEB plugins, that will live alongside other JEB plugins for as long as needed. Our GitHub repository provides several open-source plugins, such as a diem VM (move) decompiler or PDF parser. Need more Tips? # Press F1 at any time to consult the full Manual, either offline (it is bundled along with the API reference in your JEB's doc folder) or online if your workstation is connected to the Internet. Register your Copy # If you want to receive individual software update emails, make sure to register your software. The only piece of information we'll be storing is an email address. See the Help menu, Register command. (If your licensed build is an indivudual build, e.g. JEB Pro single-user, you may not need to register since you will be receiving email updates automatically.) Getting the Preview builds # We sometimes publish Release Preview builds, such as Beta builds, that will contain early fixes or features. If you wish to receive them, make sure to switch to the BETA or ALPHA update channel (located in the Help menu, Update Channel sub-menu). Set your Settings # When you open a file for analysis, a Core Settings panel will open up. Advanced users should get familiar with that panel as it allows customizing many settings before kicking in the analysis of the file. The initially-selected tree node depend on your input file type, but you may customize any other settings. Native Code Analysis Settings # When analyzing native executables, you can customize JEB processing through \"Engine Properties\" panel. For example, you can provide a specific memory base address, or select which tail calls' detection method should be used. Rendering Options # In JEB's code views (assembly code, C code, ...) you can customize many rendering options on the fly with \"Rendering Options\" widget (available from \"Edit\" menu, or from contextual menu). Signing Native Routines # You can create signatures for native routines you analyzed, such that they will be automatically identified when you encounter them again (by loading the corresponding signature package). All modifications you made to the original routines will then be imported (names, comments, labels). Such signatures can be created from \"Native\" menu, or using default shortcut \"S\". Replacing Immediates Constants by Field Constants # Immediate can be replaced by fields using Action, Replace... You may use existing field constants, or create or attach values to existing fields. Making a class anonymous # Often times, obfuscators remove annotations and other hints indicating that a class is an anonymous member of a method. Dex units support manually anonymizing classes, either via scripting or using the GUI client. To make a class anonymous using the GUI client: in the code hierarchy, drag the class item node and drop it onto the target method item node. If it is deemed possible, the class will be made anonymous. Make sure to redecompile the target method (or its containing class) to see the updated result in decompiled code. Highlighting interesting code # Use the Action menu, Toggle Highlight command (hotkey: Ctrl+M on Windows/Linux, Command+M on macOS) to toggle line highlights on and off. Like everything else, highlights can also be accessed programmatically (they are stored in unit metadata groups) and can be set via scripts, e.g. to automatically highlight areas of interest and make them pop-out during a quick visual pass. Reversing Simatic S7 PLC Programs # JEB Pro ships with extensions to acquire, analyze, disassemble, and decompile S7-300/S7-400 PLC programs. Acquire blocks via File, Acquire Simatic S7 Blocks or pack PLC blocks in a zip archive with the '.s7zip' extension. We encourage users to visit our blog to read up on reverse-engineering S7 blocks and learn about how to use this JEB extension: https://www.pnfsoftware.com/blog/reversing-simatic-s7-plc-programs","title":"Tips"},{"location":"tips.html#tips-of-the-day","text":"","title":"Tips of the Day"},{"location":"tips.html#getting-started","text":"Welcome! If this is your first run, you should be presented with an empty JEB workspace. Create a new project by opening a file (menu File, command Open ) to be analyzed: it can be a PE file, an ELF file, an APK or DEX file, or anything else that your JEB build has plugin support for. After an initial analysis pass, your main workspace will display an interactive disassembly listing, as well as a Project tree and a Code Hierarchy tree. You may navigate and modify your analysis via the Actions menu. If you are looking to decompile code, position yourself somewhere in the disassembly and hit the TAB key.","title":"Getting Started"},{"location":"tips.html#decompiling","text":"In the Disassembly view, right-click and select Decompile , or use the Action menu, Decompile command. You can navigate back to the Disassembly in a similar way.","title":"Decompiling"},{"location":"tips.html#check-your-decompilers","text":"JEB decompilers are plugins. Check which decompilers ship with your build by using the File menu, Decompilers command. JEB Community Edition bundles the x86 decompilers. JEB Android ships with everything Android. JEB Pro ships withs everything. JEB Demo as well, but with several limitations.","title":"Check your Decompilers"},{"location":"tips.html#the-omnibox","text":"The omnibox is a text input box located on the right side of the toolbar (default hotkey: F3). It allows users to search and quickly visualize (and navigate to) any type of item referenced in your JEB project. From strings to code, comments, bookmarks, command names, and text contents. Type anything you can think of in this box.","title":"The Omnibox"},{"location":"tips.html#bookmarks","text":"Bookmark your favorite locations using the Control+F12 hotkey (Command+F12 on macOS). Your project-wide list of bookmarks is accessible with F12. These commands are also accessible from the Navigation menu.","title":"Bookmarks"},{"location":"tips.html#basic-reversing-actions","text":"Common analysis actions are located in the Action menu. They include decompiling, renaming items, viewing cross-references, adding comments, etc. Other actions, specific to a given class of files or analysis, are located in other menus (e.g. Android, Native, Debugger).","title":"Basic Reversing Actions"},{"location":"tips.html#units-and-documents","text":"In JEB, the analysis of an artifact (typically, an input file) yields objects called \"units\". An artifact usually produces a tree of several units, including code units. Units can be rendered as documents, including text buffers, tables and trees. A code unit will generate a Disassembly document, among many other documents.","title":"Units and Documents"},{"location":"tips.html#android-global-analysis","text":"If you are analyzing an APK or Dex file, it is usually a good idea to run a Global Analysis pass. This analysis will use the decompiler, emulator, and sandboxing engine to find interesting things in the code, such as encrypted strings and constants or reflected accesses.","title":"Android Global Analysis"},{"location":"tips.html#customizing-the-emulator-used-by-the-android-global-analysis","text":"Check out the Emulator Settings command in the Android menu to customize the emulator and sandboxing engine policies and time-outs.","title":"Customizing the Emulator used by the Android Global Analysis"},{"location":"tips.html#android-and-side-effect-free-code","text":"This Android analysis setting allows you to specify a list of methods which are guaranteed to have no side-effect (e.g. no field update, directly or indirectly) outside of providing a return value. This list is used by some code optimizers to further enhance decompilations.","title":"Android and Side-effect-free code"},{"location":"tips.html#control-flow-graph-cfg-view","text":"When located on a disassembled method, press the Space bar to switch from a flat listing to a CFG view of the method. Press Space to switch back to the listing view.","title":"Control Flow Graph (CFG) View"},{"location":"tips.html#multi-file-projects","text":"JEB can handle more than one file in a single project. The first artifact will determine your project name, but other artifacts can be added whenever needed via the File menu, Add an Artifact command.","title":"Multi-file Projects"},{"location":"tips.html#multi-format-support","text":"JEB handles any type of file, from raw bytes to PE to ELF to APK to DEX, but also archives, documents, etc. You can explore a file, its structure, and analyze its constituents using the Project Explorer panel.","title":"Multi-format Support"},{"location":"tips.html#rebasing-constants","text":"Immediates can be rebased using the B hotkey (or via the Action menu, Convert command). Depending on the code unit, different bases will be offered, including decimal, hexadecimal, octal, character, or binary string.","title":"Rebasing Constants"},{"location":"tips.html#reopening-a-view","text":"If you ever close an important view, you can always reopen it by clicking on its corresponding unit in the Project Explorer view, right-click, then Open View command.","title":"Reopening a View"},{"location":"tips.html#exotic-decompilers","text":"Did you know that JEB can decompile all sorts of formats? From Android dex to the classic x86 and Arm, less classic Mips, but also more exotic ones like Ethereum smart contracts compiled to EVM bytecode, or WebAssembly modules.","title":"Exotic Decompilers"},{"location":"tips.html#type-hierarchies","text":"When on a type object (class or interface), use the Action, Type Hierarchy command (hotkey H) to view the selected type hierarchy, such as super-types, sub-types, and implemented interfaces.","title":"Type Hierarchies"},{"location":"tips.html#method-and-fields-overrides","text":"When on a method object, use the Action, Overrides command to check the implementations in sub-classes, as well as parent implementations in super types. The command also works for fields to see overrides (by name) in sub-classes.","title":"Method and Fields Overrides"},{"location":"tips.html#organize-your-code","text":"JEB supports packages and namespaces. Create packages, move code objects (methods, classes, etc.) to them by drag-and-dropping inside the Code Hierarchy panel, or use the Action menu, Create a Package / Move to a Package commands. This command, like all actions located in the Actions menu, is available for native code as well as dex code.","title":"Organize your Code"},{"location":"tips.html#analyzing-ethereum-smart-contracts","text":"The Ethereum plugins currently support the analysis of EVM bytecode contracts (ewasm contracts are also supported, with the help of the wasm plugins for JEB). Open a contract using the File menu, Open Smart Contract command. The contract node will be named \"DecompiledContract\".","title":"Analyzing Ethereum smart contracts"},{"location":"tips.html#blanket-renaming","text":"The action \"Auto-Rename All\" allows the renaming of all or a selection of the items in a project. This action is very handy when analyzing an obfuscated file whose meaningless names create confusion.","title":"Blanket Renaming"},{"location":"tips.html#one-decompilation-one-tab","text":"The \"Do not replace Views\" command, located in the Navigation menu, instructs the GUI client to keep tabs holding a similar view type to stay open when a different view of the same type is opened (else, the tab contents would simply be updated). It is handy when you need to have multiple decompilations opened in separate views.","title":"One Decompilation, One Tab"},{"location":"tips.html#bulk-decompilations","text":"If you need to decompile all code and export it to disk, check the File menu, Export Decompilation command. You will be able to select which part of your project should be decompiled and where it should be written to.","title":"Bulk decompilations"},{"location":"tips.html#notifications","text":"All plugins can issue sticky notifications that will be saved in the project (as opposed to pure log messages, which are not persisted). The notifications dialog can be opened from the toolbar or File menu. Double-click an entry or click Navigate to jump to the appropriate unit document and address (if the notification has an address attached to it).","title":"Notifications"},{"location":"tips.html#dark-theme-vs-light-theme","text":"Use the Switch Theme command (in the Edit menu) to switch from your system-recommended theme to a Dark theme or Light (sepia) theme.","title":"Dark Theme vs Light Theme"},{"location":"tips.html#scripting-in-python","text":"The JEB API is a comprehensive application programming interface used by JEB clients (including the main GUI program) to communicate with the back-end. Power-users can write JEB extensions that make use of the API to script tasks, have custom plugins, etc. To get accustomed to the API, it is best to start writing Python script (2.7 syntax) doing relatively simple things. JEB ships with many samples, located in the scripts/samples/ folder. Bring up the Scripts selector dialog with F2. You can execute, create, or edit existing scripts. In the example below, the UI API is used to create a custom graph object showing relationship between various code items in a code object.","title":"Scripting in Python"},{"location":"tips.html#writing-extensions-in-java","text":"The JEB API is a comprehensive application programming interface used by JEB clients (including the main GUI program) to communicate with the back-end. Power-users can write JEB extensions that make use of the API to script tasks, have custom plugins, etc. Unlike JEB Python scripts (see the previous tip), extensions written in Java can be loaded as full JEB plugins, that will live alongside other JEB plugins for as long as needed. Our GitHub repository provides several open-source plugins, such as a diem VM (move) decompiler or PDF parser.","title":"Writing extensions in Java"},{"location":"tips.html#need-more-tips","text":"Press F1 at any time to consult the full Manual, either offline (it is bundled along with the API reference in your JEB's doc folder) or online if your workstation is connected to the Internet.","title":"Need more Tips?"},{"location":"tips.html#register-your-copy","text":"If you want to receive individual software update emails, make sure to register your software. The only piece of information we'll be storing is an email address. See the Help menu, Register command. (If your licensed build is an indivudual build, e.g. JEB Pro single-user, you may not need to register since you will be receiving email updates automatically.)","title":"Register your Copy"},{"location":"tips.html#getting-the-preview-builds","text":"We sometimes publish Release Preview builds, such as Beta builds, that will contain early fixes or features. If you wish to receive them, make sure to switch to the BETA or ALPHA update channel (located in the Help menu, Update Channel sub-menu).","title":"Getting the Preview builds"},{"location":"tips.html#set-your-settings","text":"When you open a file for analysis, a Core Settings panel will open up. Advanced users should get familiar with that panel as it allows customizing many settings before kicking in the analysis of the file. The initially-selected tree node depend on your input file type, but you may customize any other settings.","title":"Set your Settings"},{"location":"tips.html#native-code-analysis-settings","text":"When analyzing native executables, you can customize JEB processing through \"Engine Properties\" panel. For example, you can provide a specific memory base address, or select which tail calls' detection method should be used.","title":"Native Code Analysis Settings"},{"location":"tips.html#rendering-options","text":"In JEB's code views (assembly code, C code, ...) you can customize many rendering options on the fly with \"Rendering Options\" widget (available from \"Edit\" menu, or from contextual menu).","title":"Rendering Options"},{"location":"tips.html#signing-native-routines","text":"You can create signatures for native routines you analyzed, such that they will be automatically identified when you encounter them again (by loading the corresponding signature package). All modifications you made to the original routines will then be imported (names, comments, labels). Such signatures can be created from \"Native\" menu, or using default shortcut \"S\".","title":"Signing Native Routines"},{"location":"tips.html#replacing-immediates-constants-by-field-constants","text":"Immediate can be replaced by fields using Action, Replace... You may use existing field constants, or create or attach values to existing fields.","title":"Replacing Immediates Constants by Field Constants"},{"location":"tips.html#making-a-class-anonymous","text":"Often times, obfuscators remove annotations and other hints indicating that a class is an anonymous member of a method. Dex units support manually anonymizing classes, either via scripting or using the GUI client. To make a class anonymous using the GUI client: in the code hierarchy, drag the class item node and drop it onto the target method item node. If it is deemed possible, the class will be made anonymous. Make sure to redecompile the target method (or its containing class) to see the updated result in decompiled code.","title":"Making a class anonymous"},{"location":"tips.html#highlighting-interesting-code","text":"Use the Action menu, Toggle Highlight command (hotkey: Ctrl+M on Windows/Linux, Command+M on macOS) to toggle line highlights on and off. Like everything else, highlights can also be accessed programmatically (they are stored in unit metadata groups) and can be set via scripts, e.g. to automatically highlight areas of interest and make them pop-out during a quick visual pass.","title":"Highlighting interesting code"},{"location":"tips.html#reversing-simatic-s7-plc-programs","text":"JEB Pro ships with extensions to acquire, analyze, disassemble, and decompile S7-300/S7-400 PLC programs. Acquire blocks via File, Acquire Simatic S7 Blocks or pack PLC blocks in a zip archive with the '.s7zip' extension. We encourage users to visit our blog to read up on reverse-engineering S7 blocks and learn about how to use this JEB extension: https://www.pnfsoftware.com/blog/reversing-simatic-s7-plc-programs","title":"Reversing Simatic S7 PLC Programs"},{"location":"views.html","text":"To visualize a unit, double-click on its node in the Project Explorer panel, or right-click and select Open, View . Views # The view for a unit is a placeholder for one or more fragments , representing unit documents . For example, a Dex unit (which is the analysis result of an Android Dex file by the Dex plugin) is rendered by multiple fragments, including: A Description static text view A Hex Dump view An Assembly interactive text view (as well as its associated Graph view) A Strings interactive table view A Code Hierarchy interactive tree view etc. Addressing # Some types of documents provide addressing support. Addressing support is a necessary requirement to enable interactive actions such as navigation and cross-referencing. The address of the caret, if any, is provided in the status bar View auto-replacement # By default, if a unit U1 of type T has a view opened, requesting to view another unit U2 of the same type T will swap the view of U1 by U2's. Example: a decompiled piece of code is being viewed; another decompilation (e.g. another method) is being opened; the previous view will be replaced. This is the default behavior to avoid rapidly cluttering the workspace with tens or hundreds of views. However, if this does not suit your workflow habits, 'view replacement' can be disabled in the Options ( .ui.DoNotReplaceViews ) or via the Navigation menu. The 'Do not replace views' option can be enabled or disabled via the Navigation menu Documents # The following sub-sections provide examples of common fragments and views encountered when analyzing binary files: Description Documents # The Description document is a standard buffer of text provided by all units. It contains a small body of text presenting various characteristics of the unit, including whether or not it contains children units. A description fragment Hex Dump Documents # The Hex Dump document is a hexadecimal representation of the input artifact. This document can efficiently represent artifacts of a size up to 2^63 bytes. Helper widgets are provided for easy visualization of unpacked byte sequences. A hexadecimal dump fragment Text Documents # Units commonly provide interactive text documents to represent their contents. Text documents are addressable. Those views can efficiently represent arbitrarily large bodies of text - up to billions of lines if necessary. The navigation bar, vertically positioned on the right-hand side of the document by default, allows navigating the document. Examples include: assembly documents, xml documents, decompiled code documents, etc. A disassembly text fragment An XML text fragment A decompiled code text fragment Navigation bar # By default, the navigation bar of a text document is a vertical bar located on the right side. It can be positioned horizontally as well, refer to this Client setting . Navigation bar in a text fragment The green line represents the location of your viewport within the document, i.e., the first line on screen. The yellow arrow represents the caret position. In the example above, the caret is located well outside the viewport. The orange line is mostly of use to plugin developers: it indicates which portion of the document is currently loaded in memory. The bar can be zoomed in and out using mouse scrolling. Hovering over an area of the bar will roughly indicate what text is located at that position: click to navigate there. Zoomed in navigation bar The bar above was zoomed in. The vertical line in red indicates what portion of the document is now represented by the entire bar . It allows for finer fast navigation in long disassembly listings. Finally, and most importantly, the bar can receive visual contributions from units and documents. It is for example used by code library recognition plugins to highlight parts of the document which contain library code. Below, an example of the bar (set horizontally for clarity) when analyzing a ShadowHammer malware sample with Visual Studio 2010 signatures on : A navigation bar with library code highlighted in cyan In this case, the cyan color represents library code. Table Documents # Units may provide table documents to represent their contents. Table documents are addressable. A strings table fragment Tree Documents # Units may provide tree documents to represent their contents. Tree documents are addressable. Interactive Trees # Code hierarchies are interactive trees that allow navigation to code items, such as methods or routines. Two code hierarchy trees (one for a Dex unit, another one for an x64 unit) next to each other Static Table Trees # Parsed certificate can be represented as static table tree documents. For example, the APK module produces such documents. A static tree Another example of a table tree (for which each node is a row within a table) is the global structure of a PDF document produced by the PDF plugin. Another static tree Mime-typed Documents # A unit may issue mime-typed documents. It is up to front-end clients to implement rendering engines for some of those types. For example, the official UI client render various image types. Custom Documents # Specialized units, such as debugger or native code units, offer access to specific data that does not fit in standard document categories. It is up to the front-end to render whatever is deemed necessary. For example, the UI client produces many specialized views to represent debugger units (such as breakpoints, threads, locals, memory, ..). Those views are described in sections dealing with specialized units, e.g. debuggers or native disassemblers .","title":"Views"},{"location":"views.html#views","text":"The view for a unit is a placeholder for one or more fragments , representing unit documents . For example, a Dex unit (which is the analysis result of an Android Dex file by the Dex plugin) is rendered by multiple fragments, including: A Description static text view A Hex Dump view An Assembly interactive text view (as well as its associated Graph view) A Strings interactive table view A Code Hierarchy interactive tree view etc.","title":"Views"},{"location":"views.html#addressing","text":"Some types of documents provide addressing support. Addressing support is a necessary requirement to enable interactive actions such as navigation and cross-referencing. The address of the caret, if any, is provided in the status bar","title":"Addressing"},{"location":"views.html#view-auto-replacement","text":"By default, if a unit U1 of type T has a view opened, requesting to view another unit U2 of the same type T will swap the view of U1 by U2's. Example: a decompiled piece of code is being viewed; another decompilation (e.g. another method) is being opened; the previous view will be replaced. This is the default behavior to avoid rapidly cluttering the workspace with tens or hundreds of views. However, if this does not suit your workflow habits, 'view replacement' can be disabled in the Options ( .ui.DoNotReplaceViews ) or via the Navigation menu. The 'Do not replace views' option can be enabled or disabled via the Navigation menu","title":"View auto-replacement"},{"location":"views.html#documents","text":"The following sub-sections provide examples of common fragments and views encountered when analyzing binary files:","title":"Documents"},{"location":"views.html#description-documents","text":"The Description document is a standard buffer of text provided by all units. It contains a small body of text presenting various characteristics of the unit, including whether or not it contains children units. A description fragment","title":"Description Documents"},{"location":"views.html#hex-dump-documents","text":"The Hex Dump document is a hexadecimal representation of the input artifact. This document can efficiently represent artifacts of a size up to 2^63 bytes. Helper widgets are provided for easy visualization of unpacked byte sequences. A hexadecimal dump fragment","title":"Hex Dump Documents"},{"location":"views.html#text-documents","text":"Units commonly provide interactive text documents to represent their contents. Text documents are addressable. Those views can efficiently represent arbitrarily large bodies of text - up to billions of lines if necessary. The navigation bar, vertically positioned on the right-hand side of the document by default, allows navigating the document. Examples include: assembly documents, xml documents, decompiled code documents, etc. A disassembly text fragment An XML text fragment A decompiled code text fragment","title":"Text Documents"},{"location":"views.html#navigation-bar","text":"By default, the navigation bar of a text document is a vertical bar located on the right side. It can be positioned horizontally as well, refer to this Client setting . Navigation bar in a text fragment The green line represents the location of your viewport within the document, i.e., the first line on screen. The yellow arrow represents the caret position. In the example above, the caret is located well outside the viewport. The orange line is mostly of use to plugin developers: it indicates which portion of the document is currently loaded in memory. The bar can be zoomed in and out using mouse scrolling. Hovering over an area of the bar will roughly indicate what text is located at that position: click to navigate there. Zoomed in navigation bar The bar above was zoomed in. The vertical line in red indicates what portion of the document is now represented by the entire bar . It allows for finer fast navigation in long disassembly listings. Finally, and most importantly, the bar can receive visual contributions from units and documents. It is for example used by code library recognition plugins to highlight parts of the document which contain library code. Below, an example of the bar (set horizontally for clarity) when analyzing a ShadowHammer malware sample with Visual Studio 2010 signatures on : A navigation bar with library code highlighted in cyan In this case, the cyan color represents library code.","title":"Navigation bar"},{"location":"views.html#table-documents","text":"Units may provide table documents to represent their contents. Table documents are addressable. A strings table fragment","title":"Table Documents"},{"location":"views.html#tree-documents","text":"Units may provide tree documents to represent their contents. Tree documents are addressable.","title":"Tree Documents"},{"location":"views.html#interactive-trees","text":"Code hierarchies are interactive trees that allow navigation to code items, such as methods or routines. Two code hierarchy trees (one for a Dex unit, another one for an x64 unit) next to each other","title":"Interactive Trees"},{"location":"views.html#static-table-trees","text":"Parsed certificate can be represented as static table tree documents. For example, the APK module produces such documents. A static tree Another example of a table tree (for which each node is a row within a table) is the global structure of a PDF document produced by the PDF plugin. Another static tree","title":"Static Table Trees"},{"location":"views.html#mime-typed-documents","text":"A unit may issue mime-typed documents. It is up to front-end clients to implement rendering engines for some of those types. For example, the official UI client render various image types.","title":"Mime-typed Documents"},{"location":"views.html#custom-documents","text":"Specialized units, such as debugger or native code units, offer access to specific data that does not fit in standard document categories. It is up to the front-end to render whatever is deemed necessary. For example, the UI client produces many specialized views to represent debugger units (such as breakpoints, threads, locals, memory, ..). Those views are described in sections dealing with specialized units, e.g. debuggers or native disassemblers .","title":"Custom Documents"},{"location":"webassembly.html","text":"Info This manual page assumes familiarity with common JEB actions and views . We also assume a minimal amount of knowledge of WebAssembly code and low-level details. For readers that would like to get up to speed with the basics of wasm from a reverse-engineering point of view, we recommend reading our technical paper Reversing WebAssembly Note The wasm decompiler update shipping with JEB 4, whose pre-release is planned for Q2 2020, fills up several gaps present in the first version of the decompiler, e.g. floating point support, casting and reinterpret opcodes, etc. JEB Pro can be used to analyze and decompile WebAssembly binary modules (wasm). The decompiler produces C-like code. Three modules, relying on the Native Code Analysis Pipeline, handle WebAssembly binaries: a wasm binary parser, a disassembler extension, and a decompiler extension. A Project Explorer view with wasm module and wasm bytecode units After opening a wasm binary in JEB, it will be recognized and processed as such by the WebAssembly plugin: - The top-level unit node, under the blue-dot artifact node, represents the module itself. - Its first child node is named \"wasmbc image\", and represents a memory view of the entire WebAssembly module, with code and data. The module unit # Overview fragment The Overview fragment displays standard information. Note the following interesting facts: The word-size is set to 32-bit, as the plugin assumes a wasm32 environment. The endianness is little endian. The start of image is set to 0, and the virtual image size to 2Gb: the entire module will be sparsely mapped within this memory range. Wasm binaries do not embed standard metadata that would hold compilation timestamps (they could be added to a custom section though). Sections fragment The Sections fragment represents an unmodified list of wasm sections. The in-memory size and offset are irrelevant and set to zero. Note that the example above shows a custom dylink section, most likely indicating a binary compiled with emcc and the flag SIDE_MODULE=1 . The Segments and Symbols tabs detail how the wasm plugin laid out and transformed the elements of the wasm module in order to allow the underlying code plugin to process it. Pseudo segments # wasm module pseudo-segments The concept of mappable segments does not exist per-say in WebAssembly. However, in order to allow JEB code plugins (disassemblers, decompilers, etc.) to function, the wasm plugin creates the following pseudo sections: .data starts at address 0 and maps the single Memory section (along with the Data elements that initialize it) .table starts at address 0x4000000 and holds a table of pointers to the functions referenced in the Table section (initialized by the Element section) .code starts at address 0x50000000 and contains the bytecode of all internal functions, in order of index: the first function body of size S0 is at address 0x50000000, the second at address 0x50000000+S0, the third at 0x50000000+S0+S1, etc. .globals starts at address 0x60000000 and maps the internal globals as standard global variables; practically, wasm' globals (accessible by {SET,GET}_GLOBAL operators) and wasm' memory bytes (accessible by load/store operators) are being treated as equals by JEB. .imports starts at address 0x70000000 contains pointer references to the imported (external) function section entries and global section entries The image is set to be mapped in the [0, 0x80000000) range. Sections are sparsely mapped; only used bytes are allocated. The start addresses are flexible and can be adjusted if needed Symbols # wasm module pseudo-symbols Symbols generated by the wasm plugin are of four types, and can have a variety of attributes: FUNCTION for internal functions PTRUNCTION for imported functions and referenced internal functions VARIABLE for globals PTRVARIABLE for imported globals Code View # The interactive disassembly window shows the pseudo virtual memory representing the entire WebAssembly module, as explained in the above section. The screenshot below shows the disassembly area of an internal function. Note that JEB's representation of a function's bytecode is linear and matches the underlying binary code. The green columns prefixing the instruction indicate the current block depth and current operand stack height, pre-execution. wasm bytecode code view, showing a disassembly snippet The snapshot below shows the beginning of the .data virtual segment, representing the WebAssembly Data section. The Code view is interactive. However, code modification (i.e., tampering with routine bodies) is forbidden since they would introduce inconsistencies in the function index space. wasm bytecode code view, showing a data area Decompilation # The WebAssembly decompiler plugin for JEB uses JEB's decompilation pipeline to produce pseudo C code. As such, the plugin consists of a wasm-to-IR converter and additional analyzer extensions. Slots on the operand stack are converted to standard, routine context IR variables. As of the time of writing, the wasm decompiler has the following limitations: The global, advanced analysis normally provided the decompiler is partially disabled (the advanced analysis is responsible, for instance, to discover register values and callsite targets during a fast static analysis phase, and subsequently annotate the assembly listing). There is no support for floating point operation conversion. Memory stack frames, due to their dynamic (and optional) nature in WebAssembly are currently not accessible and customizable. Those limitations will be addressed as the decompiler plugin matures. wasm bytecode disassembly and corresponding decompiled code","title":"WebAssembly Analysis"},{"location":"webassembly.html#the-module-unit","text":"Overview fragment The Overview fragment displays standard information. Note the following interesting facts: The word-size is set to 32-bit, as the plugin assumes a wasm32 environment. The endianness is little endian. The start of image is set to 0, and the virtual image size to 2Gb: the entire module will be sparsely mapped within this memory range. Wasm binaries do not embed standard metadata that would hold compilation timestamps (they could be added to a custom section though). Sections fragment The Sections fragment represents an unmodified list of wasm sections. The in-memory size and offset are irrelevant and set to zero. Note that the example above shows a custom dylink section, most likely indicating a binary compiled with emcc and the flag SIDE_MODULE=1 . The Segments and Symbols tabs detail how the wasm plugin laid out and transformed the elements of the wasm module in order to allow the underlying code plugin to process it.","title":"The module unit"},{"location":"webassembly.html#pseudo-segments","text":"wasm module pseudo-segments The concept of mappable segments does not exist per-say in WebAssembly. However, in order to allow JEB code plugins (disassemblers, decompilers, etc.) to function, the wasm plugin creates the following pseudo sections: .data starts at address 0 and maps the single Memory section (along with the Data elements that initialize it) .table starts at address 0x4000000 and holds a table of pointers to the functions referenced in the Table section (initialized by the Element section) .code starts at address 0x50000000 and contains the bytecode of all internal functions, in order of index: the first function body of size S0 is at address 0x50000000, the second at address 0x50000000+S0, the third at 0x50000000+S0+S1, etc. .globals starts at address 0x60000000 and maps the internal globals as standard global variables; practically, wasm' globals (accessible by {SET,GET}_GLOBAL operators) and wasm' memory bytes (accessible by load/store operators) are being treated as equals by JEB. .imports starts at address 0x70000000 contains pointer references to the imported (external) function section entries and global section entries The image is set to be mapped in the [0, 0x80000000) range. Sections are sparsely mapped; only used bytes are allocated. The start addresses are flexible and can be adjusted if needed","title":"Pseudo segments"},{"location":"webassembly.html#symbols","text":"wasm module pseudo-symbols Symbols generated by the wasm plugin are of four types, and can have a variety of attributes: FUNCTION for internal functions PTRUNCTION for imported functions and referenced internal functions VARIABLE for globals PTRVARIABLE for imported globals","title":"Symbols"},{"location":"webassembly.html#code-view","text":"The interactive disassembly window shows the pseudo virtual memory representing the entire WebAssembly module, as explained in the above section. The screenshot below shows the disassembly area of an internal function. Note that JEB's representation of a function's bytecode is linear and matches the underlying binary code. The green columns prefixing the instruction indicate the current block depth and current operand stack height, pre-execution. wasm bytecode code view, showing a disassembly snippet The snapshot below shows the beginning of the .data virtual segment, representing the WebAssembly Data section. The Code view is interactive. However, code modification (i.e., tampering with routine bodies) is forbidden since they would introduce inconsistencies in the function index space. wasm bytecode code view, showing a data area","title":"Code View"},{"location":"webassembly.html#decompilation","text":"The WebAssembly decompiler plugin for JEB uses JEB's decompilation pipeline to produce pseudo C code. As such, the plugin consists of a wasm-to-IR converter and additional analyzer extensions. Slots on the operand stack are converted to standard, routine context IR variables. As of the time of writing, the wasm decompiler has the following limitations: The global, advanced analysis normally provided the decompiler is partially disabled (the advanced analysis is responsible, for instance, to discover register values and callsite targets during a fast static analysis phase, and subsequently annotate the assembly listing). There is no support for floating point operation conversion. Memory stack frames, due to their dynamic (and optional) nature in WebAssembly are currently not accessible and customizable. Those limitations will be addressed as the decompiler plugin matures. wasm bytecode disassembly and corresponding decompiled code","title":"Decompilation"},{"location":"workspace.html","text":"When starting the UI client without specifying an input file, JEB will display an empty workspace that's using a three-part layout: Project explorer on the left side Logger and Console at the bottom Empty area in the center Starting an Analysis # To start an analysis, open a file (or reload a saved analysis stored in a .jdb2 file) via the File menu. A new project will be created, the input file will be processed and analyzed. Example: Processing an APK file # If your input file was an Android application, the app is processed by various Android analysis plugins: The APK plugin takes care of unbundling the app, decoding the manifest and resources The DEX plugin performs the analysis and disassembly of the DEX bytecode file (or files) The XML parser analyzes XML resources The Certificate plugin analyzes the certificate ... and so on. JEB performs recursive analysis on input artifacts and units, using the loaded parser plugins . The project explorer tree should display a Bytecode node, representing the DEX unit (more on the concept of units later). The DEX views should be opened automatically by the UI client, as they are detected as the principal views of an APK artifact. Your workspace should look like: The workspace can be customized by the user: Views can be dragged and dropped, resized, stacked and docked with other views Views can be detached and placed in separate windows - something particularly useful for multi-monitor setups. Terminology # The Project Explorer contains three types of nodes: The top-most entity accessible within the UI client is a project . Currently, the UI client can only handle a single project per session. A project contains various artifacts , which represent data to be analyzed. Artifacts are usually files read from the local file system The analysis of artifacts yield units (and sub-units ). E.g., the analysis of an Android DEX file artifact will yield at least one DEX unit representing the bytecode of that DEX file. Users of the graphical client interact with units through views that contain fragments representing various aspects of a unit. Fragments are rendered in tabs, selectable at the bottom of a view. Most units are interactive . Users can interact with them through a variety of ways, including via actions , available in the similarly-named menu. The screen capture below summarizes common elements present and visible in the workspace when analyzing a file: Back-end JEB objects # The Project Explorer elements are representing back-end components documented in the API reference . The image below summarizes a project's top-most components hierarchically:","title":"Workspace"},{"location":"workspace.html#starting-an-analysis","text":"To start an analysis, open a file (or reload a saved analysis stored in a .jdb2 file) via the File menu. A new project will be created, the input file will be processed and analyzed.","title":"Starting an Analysis"},{"location":"workspace.html#example-processing-an-apk-file","text":"If your input file was an Android application, the app is processed by various Android analysis plugins: The APK plugin takes care of unbundling the app, decoding the manifest and resources The DEX plugin performs the analysis and disassembly of the DEX bytecode file (or files) The XML parser analyzes XML resources The Certificate plugin analyzes the certificate ... and so on. JEB performs recursive analysis on input artifacts and units, using the loaded parser plugins . The project explorer tree should display a Bytecode node, representing the DEX unit (more on the concept of units later). The DEX views should be opened automatically by the UI client, as they are detected as the principal views of an APK artifact. Your workspace should look like: The workspace can be customized by the user: Views can be dragged and dropped, resized, stacked and docked with other views Views can be detached and placed in separate windows - something particularly useful for multi-monitor setups.","title":"Example: Processing an APK file"},{"location":"workspace.html#terminology","text":"The Project Explorer contains three types of nodes: The top-most entity accessible within the UI client is a project . Currently, the UI client can only handle a single project per session. A project contains various artifacts , which represent data to be analyzed. Artifacts are usually files read from the local file system The analysis of artifacts yield units (and sub-units ). E.g., the analysis of an Android DEX file artifact will yield at least one DEX unit representing the bytecode of that DEX file. Users of the graphical client interact with units through views that contain fragments representing various aspects of a unit. Fragments are rendered in tabs, selectable at the bottom of a view. Most units are interactive . Users can interact with them through a variety of ways, including via actions , available in the similarly-named menu. The screen capture below summarizes common elements present and visible in the workspace when analyzing a file:","title":"Terminology"},{"location":"workspace.html#back-end-jeb-objects","text":"The Project Explorer elements are representing back-end components documented in the API reference . The image below summarizes a project's top-most components hierarchically:","title":"Back-end JEB objects"},{"location":"dev/1-getting-started-with-parsers.html","text":"Warning This tutorial is deprecated, and will be rewritten to account for JEB 4 API changes. JEB Plugin Development Tutorial part 1/8 The JEB API provides the ability to develop parser plugins (referred to as parsers ) for any file type. All native JEB plugins use that same API. A parser can process binary data, textual data, or even the output of other parsers, which is the case for debugger or decompiler plugins. This series of tutorials will help developers understand the major features and organization of the JEB API, and will guide them through the development of their own parsers and plugins. We will use the official front-end - the UI client - throughout this series, although extensions development is in no way constricted to the use of a particular front-end. Load a parser # There are two ways to load plugins. Release model # Copy the jar plugin to your plugins folder. You can configure your plugins folder via the Edit, Options menu (or Preferences on Mac). Refer to that section for additional details. If you are using third-party (aka, non native) plugins, the release model is easy to use. For example, head over to our GitHub account. You will find a few open-source parsers, such as an Android OAT parser . Instead of compiling them from source, you may decide to use the pre-compiled jars, available in the release section. With the release model, the classname is defined in the Jar manifest. There is nothing to configure in the options. If you have a jar plugin that you would like to use, simply drop it in the plugins folder . Then, restart JEB. Your plugin will be automatically loaded. Development model # In that case, you need to specify the classpath of your plugin, as well as its classname (that is, the fully-qualified name of the plugin class, as we will describe later). You can modify these options in the same dialog box, in the Development tab: The development model is ideal when actively developing a plugin, and dealing with compiled Java classfiles that have not been packaged yet. Check if a parser is loaded # As we explained earlier in this guide, You can check if your parser is loaded by opening the parsers dialog: Note that you may also disable parsers, by ticking or unticking the checkbox in front of the parser type. Develop a new parser # JEB plugins are developed in Java. We recommend you to use the Eclipse IDE for plugins development. Create a new Java project In Eclipse: File, New, Java Project - use the default settings Add the API to your project. The API can be included by adding the Jar reference to your build path In Eclipse: right click on your project, select Build path, Add external archives . The API file is contained in the JEB application under bin/cl/jeb.jar . Link the javadoc to jeb.jar: it is located in doc/apidoc.zip In Eclipse: right click on your project and select Build path, configure build path. Expand jeb.jar and edit the javadoc location Set the Archive path textbobx to point to your apidoc.zip file Set the Path within Archive textbox to reference Create a new class that implements IPlugin : it will be the entry point of your project. In Eclipse: the project is automatically compiled in a bin/ directory For example: package com.jeb.sample ; import com.pnfsoftware.jeb.core.IPlugin ; // simplest plugin type public class SamplePlugin implements IPlugin { @Override public IPluginInformation getPluginInformation () { return new PluginInformation ( \"Sample\" , \"Description\" , \"PNF Software\" , Version . create ( 1 , 0 )); } } Open JEB and add your project bin folder to the Plugin Classpath entries and add the classname: com.jeb.sample.SamplePlugin . Restart JEB, you should see a message in the Logger panel: Development plugin loaded: class com.jeb.sample.SamplePlugin This means that your project is correctly configured and that you can start the development of your plugin!","title":"Part 1: Getting Started with Parsers"},{"location":"dev/1-getting-started-with-parsers.html#load-a-parser","text":"There are two ways to load plugins.","title":"Load a parser"},{"location":"dev/1-getting-started-with-parsers.html#release-model","text":"Copy the jar plugin to your plugins folder. You can configure your plugins folder via the Edit, Options menu (or Preferences on Mac). Refer to that section for additional details. If you are using third-party (aka, non native) plugins, the release model is easy to use. For example, head over to our GitHub account. You will find a few open-source parsers, such as an Android OAT parser . Instead of compiling them from source, you may decide to use the pre-compiled jars, available in the release section. With the release model, the classname is defined in the Jar manifest. There is nothing to configure in the options. If you have a jar plugin that you would like to use, simply drop it in the plugins folder . Then, restart JEB. Your plugin will be automatically loaded.","title":"Release model"},{"location":"dev/1-getting-started-with-parsers.html#development-model","text":"In that case, you need to specify the classpath of your plugin, as well as its classname (that is, the fully-qualified name of the plugin class, as we will describe later). You can modify these options in the same dialog box, in the Development tab: The development model is ideal when actively developing a plugin, and dealing with compiled Java classfiles that have not been packaged yet.","title":"Development model"},{"location":"dev/1-getting-started-with-parsers.html#check-if-a-parser-is-loaded","text":"As we explained earlier in this guide, You can check if your parser is loaded by opening the parsers dialog: Note that you may also disable parsers, by ticking or unticking the checkbox in front of the parser type.","title":"Check if a parser is loaded"},{"location":"dev/1-getting-started-with-parsers.html#develop-a-new-parser","text":"JEB plugins are developed in Java. We recommend you to use the Eclipse IDE for plugins development. Create a new Java project In Eclipse: File, New, Java Project - use the default settings Add the API to your project. The API can be included by adding the Jar reference to your build path In Eclipse: right click on your project, select Build path, Add external archives . The API file is contained in the JEB application under bin/cl/jeb.jar . Link the javadoc to jeb.jar: it is located in doc/apidoc.zip In Eclipse: right click on your project and select Build path, configure build path. Expand jeb.jar and edit the javadoc location Set the Archive path textbobx to point to your apidoc.zip file Set the Path within Archive textbox to reference Create a new class that implements IPlugin : it will be the entry point of your project. In Eclipse: the project is automatically compiled in a bin/ directory For example: package com.jeb.sample ; import com.pnfsoftware.jeb.core.IPlugin ; // simplest plugin type public class SamplePlugin implements IPlugin { @Override public IPluginInformation getPluginInformation () { return new PluginInformation ( \"Sample\" , \"Description\" , \"PNF Software\" , Version . create ( 1 , 0 )); } } Open JEB and add your project bin folder to the Plugin Classpath entries and add the classname: com.jeb.sample.SamplePlugin . Restart JEB, you should see a message in the Logger panel: Development plugin loaded: class com.jeb.sample.SamplePlugin This means that your project is correctly configured and that you can start the development of your plugin!","title":"Develop a new parser"},{"location":"dev/2-creating-simple-parser.html","text":"Warning This tutorial is deprecated, and will be rewritten to account for JEB 4 API changes. JEB Plugin Development Tutorial part 2/8 The source code for part 2 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial2 branch: git checkout tutorial2 Sample file # In this parser development tutorial, we will consider a simple Javascript parser. Let's start with a definition of a test file: # Javascript function a () { alert ( \"a called\" ); } function b () { var b = \"b called\" ; alert ( b ); } Parser Objective # Our parser will split the input JavaScript file into several parts, one for each JavaScript function(). Defined variables will will be displayed in a supplementary tab in a table. This initial goal is to detect and display the contents of the file. The secondary goal is to define and manage several views, and show how to use the delegation mechanism. Generic Parser # First, let's open this js file without modifying anything in JEB. JEB analyzes the input artifact and built the project as following: The top-level project represents your current workspace. The artifact represents the file that was opened. (If you choose \"File, Add an Artifact...\" from the menu, a new artifact will be added at the same level.) The children of the artifact are the units . Their icon can be specified, if none, you will see the default one . JEB provides a default generic parser that displays any file. It contains two fragments: a Description panel with generic information related to unit an Hex Dump view which displays the content of the object as hexadecimal. Detect the js file # Upon loading a file, the first step JEB takes is ask all parsers if they are able to handle the input artifact (in our case, a file). So, the first step is to add the detection for this JavaScript (js) file. For the sake of making this tutorial simple, we will suppose that all our js files start with a \"#Javascript\" tag. In part 1 , we learned that IPlugin is the entry point of the plugin; however, it only defines a getPluginInformation() method. Let's start to check all classes/interfaces that extend IPlugin (in Eclipse, right click on IPlugin, Open Type Hierarchy ). What we have here: our own plugin SamplePlugin class IEnginesPlugin for Engines plugins (refer to separate tutorial) IUnitIdentifier for Parser plugins. To free developers from the task of implementing all methods of IUnitIdentifier, the abstract class AbstractUnitIdentifier is provided. Let's extend it instead of IPlugin or IUnitIdentifier. We see that only two methods are not implemented: canIdentify : used to detect if the parser should to be used (the one we were looking for!) prepare : used to create an IUnit that will perform the processing Let's check canIdentify parameters in the API: IInput is a reference to the input file or stream, we can read data from here. IUnitCreator is the parent that created this unit (parsers are producing units or type IUnit). We will use this parameter in the tutorial explaining how delegation works. canIdentify could use IInput.getHeader, IInput.getStream or other method to detect specific file type. Here, we will use AbstractUnitIdentifier.checkBytes which provides an easy way to check header as you can see: private final static byte [] JS_HEADER = \"#Javascript\" . getBytes (); @Override public boolean canIdentify ( IInput input , IUnitCreator parent ) { return checkBytes ( input , 0 , JS_HEADER ); } We are now ready, let's start JEB. Note: you may see the following error in the logger: Unit plugin class com.jeb.sample.SamplePlugin must have a public no-argument constructor This means that you did not provide a default constructor without argument. Let's use this one: public SamplePlugin () { super ( \"Javascript\" , 0 ); } Open test.js. You should see this: The default parser did not create the generic unit for js file! That's because there is nothing defined in the prepare method. Keep on reading. Build a unit # Look back at the prepare method. It should return an IUnit . The IUnit will be the main processing class, so it is recommended to build a dedicated class. Just like we did for IPlugin, we will use one of the default convenience abstract classes provided: AbstractUnit . public class SampleUnit extends AbstractUnit { public SampleUnit ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent , IPropertyDefinitionManager pdm ) { super ( \"js\" , name , unitProcessor , parent , pdm ); } @Override public boolean process () { // indicates that the processing is already done: process won't be called again in future setProcessed ( true ); // default is false. True indicates that processing is successful. return true ; } } and the code of the caller: @Override public IUnit prepare ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent ) { return new SampleUnit ( name , input , unitProcessor , parent , pdm ); } You can test your parser: Not very exciting. The content of the file is not even displayed. AbstractUnit is a simple unit with the description panel. Its constructor does not use the IInput. Let's try something else: what are all available subclasses that we have: Let's use another default implementation: AbstractBinaryUnit . public class SampleUnit extends AbstractBinaryUnit { public SampleUnit ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent , IPropertyDefinitionManager pdm ) { super ( null , input , \"js\" , name , unitProcessor , parent , pdm ); } } So, now we have 2 tabs for a single unit. Each tab is a representation of a JEB Document. Default documents for a Binary Unit are Description and Hex Dump. They both display text. Note: the description Document is a default document that is always attached to a unit. You can modify its content by overriding IUnit.getDescription. Add a Document # JEB provides the ability for units to produce all sorts of documents to be represented by clients. There are three types of documents, and default implementations are provided: Text buffers (for arbitrary long line-based documents) Tables Trees and table trees Let's start with the simplest document: a text document. We will use the provided AsciiDocument implementation. The display is delegated to an IUnitFormatter. This display can be modified by overriding the IUnit.getFormatter method. @Override public IUnitFormatter getFormatter () { return new UnitFormatterAdapter ( new AbstractUnitRepresentation ( \"javascript raw code\" , true ) { @Override public IGenericDocument getDocument () { return new AsciiDocument ( getInput ()); } }); } The result is what we expected:","title":"Part 2: Creating a Simple Parser"},{"location":"dev/2-creating-simple-parser.html#sample-file","text":"In this parser development tutorial, we will consider a simple Javascript parser. Let's start with a definition of a test file: # Javascript function a () { alert ( \"a called\" ); } function b () { var b = \"b called\" ; alert ( b ); }","title":"Sample file"},{"location":"dev/2-creating-simple-parser.html#parser-objective","text":"Our parser will split the input JavaScript file into several parts, one for each JavaScript function(). Defined variables will will be displayed in a supplementary tab in a table. This initial goal is to detect and display the contents of the file. The secondary goal is to define and manage several views, and show how to use the delegation mechanism.","title":"Parser Objective"},{"location":"dev/2-creating-simple-parser.html#generic-parser","text":"First, let's open this js file without modifying anything in JEB. JEB analyzes the input artifact and built the project as following: The top-level project represents your current workspace. The artifact represents the file that was opened. (If you choose \"File, Add an Artifact...\" from the menu, a new artifact will be added at the same level.) The children of the artifact are the units . Their icon can be specified, if none, you will see the default one . JEB provides a default generic parser that displays any file. It contains two fragments: a Description panel with generic information related to unit an Hex Dump view which displays the content of the object as hexadecimal.","title":"Generic Parser"},{"location":"dev/2-creating-simple-parser.html#detect-the-js-file","text":"Upon loading a file, the first step JEB takes is ask all parsers if they are able to handle the input artifact (in our case, a file). So, the first step is to add the detection for this JavaScript (js) file. For the sake of making this tutorial simple, we will suppose that all our js files start with a \"#Javascript\" tag. In part 1 , we learned that IPlugin is the entry point of the plugin; however, it only defines a getPluginInformation() method. Let's start to check all classes/interfaces that extend IPlugin (in Eclipse, right click on IPlugin, Open Type Hierarchy ). What we have here: our own plugin SamplePlugin class IEnginesPlugin for Engines plugins (refer to separate tutorial) IUnitIdentifier for Parser plugins. To free developers from the task of implementing all methods of IUnitIdentifier, the abstract class AbstractUnitIdentifier is provided. Let's extend it instead of IPlugin or IUnitIdentifier. We see that only two methods are not implemented: canIdentify : used to detect if the parser should to be used (the one we were looking for!) prepare : used to create an IUnit that will perform the processing Let's check canIdentify parameters in the API: IInput is a reference to the input file or stream, we can read data from here. IUnitCreator is the parent that created this unit (parsers are producing units or type IUnit). We will use this parameter in the tutorial explaining how delegation works. canIdentify could use IInput.getHeader, IInput.getStream or other method to detect specific file type. Here, we will use AbstractUnitIdentifier.checkBytes which provides an easy way to check header as you can see: private final static byte [] JS_HEADER = \"#Javascript\" . getBytes (); @Override public boolean canIdentify ( IInput input , IUnitCreator parent ) { return checkBytes ( input , 0 , JS_HEADER ); } We are now ready, let's start JEB. Note: you may see the following error in the logger: Unit plugin class com.jeb.sample.SamplePlugin must have a public no-argument constructor This means that you did not provide a default constructor without argument. Let's use this one: public SamplePlugin () { super ( \"Javascript\" , 0 ); } Open test.js. You should see this: The default parser did not create the generic unit for js file! That's because there is nothing defined in the prepare method. Keep on reading.","title":"Detect the js file"},{"location":"dev/2-creating-simple-parser.html#build-a-unit","text":"Look back at the prepare method. It should return an IUnit . The IUnit will be the main processing class, so it is recommended to build a dedicated class. Just like we did for IPlugin, we will use one of the default convenience abstract classes provided: AbstractUnit . public class SampleUnit extends AbstractUnit { public SampleUnit ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent , IPropertyDefinitionManager pdm ) { super ( \"js\" , name , unitProcessor , parent , pdm ); } @Override public boolean process () { // indicates that the processing is already done: process won't be called again in future setProcessed ( true ); // default is false. True indicates that processing is successful. return true ; } } and the code of the caller: @Override public IUnit prepare ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent ) { return new SampleUnit ( name , input , unitProcessor , parent , pdm ); } You can test your parser: Not very exciting. The content of the file is not even displayed. AbstractUnit is a simple unit with the description panel. Its constructor does not use the IInput. Let's try something else: what are all available subclasses that we have: Let's use another default implementation: AbstractBinaryUnit . public class SampleUnit extends AbstractBinaryUnit { public SampleUnit ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent , IPropertyDefinitionManager pdm ) { super ( null , input , \"js\" , name , unitProcessor , parent , pdm ); } } So, now we have 2 tabs for a single unit. Each tab is a representation of a JEB Document. Default documents for a Binary Unit are Description and Hex Dump. They both display text. Note: the description Document is a default document that is always attached to a unit. You can modify its content by overriding IUnit.getDescription.","title":"Build a unit"},{"location":"dev/2-creating-simple-parser.html#add-a-document","text":"JEB provides the ability for units to produce all sorts of documents to be represented by clients. There are three types of documents, and default implementations are provided: Text buffers (for arbitrary long line-based documents) Tables Trees and table trees Let's start with the simplest document: a text document. We will use the provided AsciiDocument implementation. The display is delegated to an IUnitFormatter. This display can be modified by overriding the IUnit.getFormatter method. @Override public IUnitFormatter getFormatter () { return new UnitFormatterAdapter ( new AbstractUnitRepresentation ( \"javascript raw code\" , true ) { @Override public IGenericDocument getDocument () { return new AsciiDocument ( getInput ()); } }); } The result is what we expected:","title":"Add a Document"},{"location":"dev/3-documents-delegation.html","text":"Warning This tutorial is deprecated, and will be rewritten to account for JEB 4 API changes. JEB Plugin Development Tutorial part 3/8 The source code for part 3 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial3 branch: git checkout tutorial3 Process the input # In the previous part, we built a single document that displays the whole JavaScript file. Imagine we have large functions that we would like to split using the following simple rule: one function per document . Let's detail the flow of execution around IUnit : When opening a new file, all the IPlugin.canIdentify methods are called. If identified, the method IPlugin.prepare is called, which will create a new unit. When opening the unit, if the unit was not previously processed, the method IUnit.process method will be called. At last, IUnit.getFormatter is used to display the result of processing. The process method is where the heavy-lifting of your parser should be located. If you need to pre-process data, you may call the process method in IUnitIdentifier.prepare . Since we don't need it for now, we won't do it. So let's start with implementing process() . First, we need to extract the JavaScript and split this test block into two functions. For the sake of this tutorial, we will use Mozilla Rhino to deal with JavaScript lexing and parsing. You can download it here . First, add rhino-*.jar to your eclipse project (you can attach the javadoc to this .jar, the process is like adding javadoc to jeb.jar). Then, use the following snippet to extract the Functions from JavaScript: private static final ILogger logger = GlobalLog . getLogger ( SampleUnit . class ); private AstRoot root = null ; private List < FunctionNode > functions = new ArrayList < FunctionNode > (); @Override public boolean process () { // parse the javascript IRFactory factory = new IRFactory (); try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( getInput (). getStream ())); reader . readLine (); // ignore first line with #Javascript root = factory . parse ( reader , null , 0 ); } catch ( IOException e ) { logger . catching ( e ); return false ; } // save functions List < AstNode > statements = root . getStatements (); for ( AstNode statement : statements ) { if ( statement . getType () == Token . FUNCTION ) { functions . add (( FunctionNode ) statement ); } } // done setProcessed ( true ); return true ; } As you can see here, process() is only extracting data: FunctionNode objects are saved in the functions list. Note: JEB provides global logging facility that you can use anytime to send messages in the Logger panel. Do not hesitate to use it to investigate your code. We also recommend you enable the Development Mode in the Options panel: this will allow logging of debug and trace messages. import com.pnfsoftware.jeb.util.logging.GlobalLog ; import com.pnfsoftware.jeb.util.logging.ILogger ; public class Xxx { private static final ILogger logger = GlobalLog . getLogger ( Xxx . class ); ... Add a Document per function # Now, let's modify the getFormatter method to change rendering, adding as many tabs (documents) as defined functions. @Override public IUnitFormatter getFormatter () { UnitFormatterAdapter adapter = new UnitFormatterAdapter ( new AbstractUnitRepresentation ( \"javascript raw code\" , true ) { @Override public IGenericDocument getDocument () { return new AsciiDocument ( getInput ()); } }); if ( functions != null ) { for ( final FunctionNode function : functions ) { adapter . addDocumentPresentation ( new AbstractUnitRepresentation ( function . getName ()) { @Override public IGenericDocument getDocument () { return new AsciiDocument ( new BytesInput ( function . toSource (). getBytes ())); } }); } } return adapter ; } We called the method UnitFormatterAdapter.addDocumentPresentation to add more documents. Note: since AsciiDocument requires an IInput as entry, we used the most appropriate implementation: Now, start JEB. Note You will probably see this exception: java.lang.NoClassDefFoundError: org/mozilla/javascript/IRFactory . Remember that js.jar was not added to JEB classpath. Add it to your plugin classpath (in the Options panel - refer to Part 1 of this tutorial). If all works well, you shall to see two additional tabs: Delegate to another Unit # These new documents are great but what if we have lots of functions? We will have lots of tabs and it will become unreadable. One solution would be to add these FunctionNodes as children unit of the test.js unit node. We can delegate the creation of those units to the unit processor. Here is a short explanation of delegation: assume have a zip file containing pdf, apk, js... You do not want to write a single parser that manages all those file types. A better approach is to have a Zip parser that will delegate parsing of its contents. That puts the Unit Processor in charge of finding the best Unit that match the file type: DEX Unit, Pdf Unit... and even our new Javascript Unit. Info More on delegation here . So how to do it? You need to slightly modify process(): // save functions List < AstNode > statements = root . getStatements (); for ( AstNode statement : statements ) { if ( statement . getType () == Token . FUNCTION ) { FunctionNode function = ( FunctionNode ) statement ; functions . add ( function ); IUnit jsUnit = getUnitProcessor (). process ( function . getName (), new BytesInput ( function . toSource (). getBytes ()), this ); if ( jsUnit != null ) { addChildUnit ( jsUnit ); } } } You should be able to see a generic binary output for a and b . Assignment # Build a simple JavascriptPlugin that takes advantage of the delegation. The solution lies in branch tutorial3 of this sample plugin repository. Do not forget to register the parser plugin's classname in the options panel. You should obtain something like this:","title":"Part 3: Documents and Delegation"},{"location":"dev/3-documents-delegation.html#process-the-input","text":"In the previous part, we built a single document that displays the whole JavaScript file. Imagine we have large functions that we would like to split using the following simple rule: one function per document . Let's detail the flow of execution around IUnit : When opening a new file, all the IPlugin.canIdentify methods are called. If identified, the method IPlugin.prepare is called, which will create a new unit. When opening the unit, if the unit was not previously processed, the method IUnit.process method will be called. At last, IUnit.getFormatter is used to display the result of processing. The process method is where the heavy-lifting of your parser should be located. If you need to pre-process data, you may call the process method in IUnitIdentifier.prepare . Since we don't need it for now, we won't do it. So let's start with implementing process() . First, we need to extract the JavaScript and split this test block into two functions. For the sake of this tutorial, we will use Mozilla Rhino to deal with JavaScript lexing and parsing. You can download it here . First, add rhino-*.jar to your eclipse project (you can attach the javadoc to this .jar, the process is like adding javadoc to jeb.jar). Then, use the following snippet to extract the Functions from JavaScript: private static final ILogger logger = GlobalLog . getLogger ( SampleUnit . class ); private AstRoot root = null ; private List < FunctionNode > functions = new ArrayList < FunctionNode > (); @Override public boolean process () { // parse the javascript IRFactory factory = new IRFactory (); try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( getInput (). getStream ())); reader . readLine (); // ignore first line with #Javascript root = factory . parse ( reader , null , 0 ); } catch ( IOException e ) { logger . catching ( e ); return false ; } // save functions List < AstNode > statements = root . getStatements (); for ( AstNode statement : statements ) { if ( statement . getType () == Token . FUNCTION ) { functions . add (( FunctionNode ) statement ); } } // done setProcessed ( true ); return true ; } As you can see here, process() is only extracting data: FunctionNode objects are saved in the functions list. Note: JEB provides global logging facility that you can use anytime to send messages in the Logger panel. Do not hesitate to use it to investigate your code. We also recommend you enable the Development Mode in the Options panel: this will allow logging of debug and trace messages. import com.pnfsoftware.jeb.util.logging.GlobalLog ; import com.pnfsoftware.jeb.util.logging.ILogger ; public class Xxx { private static final ILogger logger = GlobalLog . getLogger ( Xxx . class ); ...","title":"Process the input"},{"location":"dev/3-documents-delegation.html#add-a-document-per-function","text":"Now, let's modify the getFormatter method to change rendering, adding as many tabs (documents) as defined functions. @Override public IUnitFormatter getFormatter () { UnitFormatterAdapter adapter = new UnitFormatterAdapter ( new AbstractUnitRepresentation ( \"javascript raw code\" , true ) { @Override public IGenericDocument getDocument () { return new AsciiDocument ( getInput ()); } }); if ( functions != null ) { for ( final FunctionNode function : functions ) { adapter . addDocumentPresentation ( new AbstractUnitRepresentation ( function . getName ()) { @Override public IGenericDocument getDocument () { return new AsciiDocument ( new BytesInput ( function . toSource (). getBytes ())); } }); } } return adapter ; } We called the method UnitFormatterAdapter.addDocumentPresentation to add more documents. Note: since AsciiDocument requires an IInput as entry, we used the most appropriate implementation: Now, start JEB. Note You will probably see this exception: java.lang.NoClassDefFoundError: org/mozilla/javascript/IRFactory . Remember that js.jar was not added to JEB classpath. Add it to your plugin classpath (in the Options panel - refer to Part 1 of this tutorial). If all works well, you shall to see two additional tabs:","title":"Add a Document per function"},{"location":"dev/3-documents-delegation.html#delegate-to-another-unit","text":"These new documents are great but what if we have lots of functions? We will have lots of tabs and it will become unreadable. One solution would be to add these FunctionNodes as children unit of the test.js unit node. We can delegate the creation of those units to the unit processor. Here is a short explanation of delegation: assume have a zip file containing pdf, apk, js... You do not want to write a single parser that manages all those file types. A better approach is to have a Zip parser that will delegate parsing of its contents. That puts the Unit Processor in charge of finding the best Unit that match the file type: DEX Unit, Pdf Unit... and even our new Javascript Unit. Info More on delegation here . So how to do it? You need to slightly modify process(): // save functions List < AstNode > statements = root . getStatements (); for ( AstNode statement : statements ) { if ( statement . getType () == Token . FUNCTION ) { FunctionNode function = ( FunctionNode ) statement ; functions . add ( function ); IUnit jsUnit = getUnitProcessor (). process ( function . getName (), new BytesInput ( function . toSource (). getBytes ()), this ); if ( jsUnit != null ) { addChildUnit ( jsUnit ); } } } You should be able to see a generic binary output for a and b .","title":"Delegate to another Unit"},{"location":"dev/3-documents-delegation.html#assignment","text":"Build a simple JavascriptPlugin that takes advantage of the delegation. The solution lies in branch tutorial3 of this sample plugin repository. Do not forget to register the parser plugin's classname in the options panel. You should obtain something like this:","title":"Assignment"},{"location":"dev/4-tables-trees.html","text":"Warning This tutorial is deprecated, and will be rewritten to account for JEB 4 API changes. JEB Plugin Development Tutorial part 4/8 The interfaces ITextDocument , ITableDocument and ITreeDocument are designed to provide buffered data: data is not generated nor displayed entirely (which could lead to performance/memory problem). It is split into Parts (eg, ITableDocumentPart ). When implementing an IXxxDocument , you can choose to render the full model (for instance if the model is relatively small) or just one or more parts. A client requests as many parts as they see fit. Those indications are hints; ultimately, your plugin has the final say in how many parts it decides to return. Now, let's check two types of documents that we haven't seen yet: Table and Tree . Table # For simple tables, you can use StaticTableDocument . See below an example of a Table having 2 columns, and containing 2 rows. private ITableDocument getStatisticsTable () { List < TableRow > rows = new ArrayList <> (); rows . add ( new TableRow ( new Cell ( \"Length\" ), new Cell ( Integer . toString ( root . getLength ())))); rows . add ( new TableRow ( new Cell ( \"Type\" ), new Cell ( Integer . toString ( root . getType ())))); return new StaticTableDocument ( Arrays . asList ( \"Property\" , \"Value\" ), rows ); } Assignment Update the getFormatter() method accordingly to include new Documents (use the IUnitFormatter.addPresentation() method). The result should look like: Tree # For simple trees, you can use StaticTreeDocument . See below an example of a Tree that displays all function parameters. private ITreeDocument getFunctionsTree () { List < Node > treeRoot = new ArrayList <> (); try { if ( functions != null ) { for ( FunctionNode function : functions ) { treeRoot . add ( buildFunctionNode ( function )); } } } catch ( Exception e ) { logger . catching ( e ); } return new StaticTreeDocument ( treeRoot ); } private Node buildFunctionNode ( FunctionNode function ) { Node functionNode = new Node ( function . getName ()); if ( function . getParamCount () > 0 ) { for ( AstNode var : function . getParams ()) { functionNode . addChild ( new Node ((( Name ) var ). getIdentifier ())); } } return functionNode ; }","title":"Part 4: Tables and Trees"},{"location":"dev/4-tables-trees.html#table","text":"For simple tables, you can use StaticTableDocument . See below an example of a Table having 2 columns, and containing 2 rows. private ITableDocument getStatisticsTable () { List < TableRow > rows = new ArrayList <> (); rows . add ( new TableRow ( new Cell ( \"Length\" ), new Cell ( Integer . toString ( root . getLength ())))); rows . add ( new TableRow ( new Cell ( \"Type\" ), new Cell ( Integer . toString ( root . getType ())))); return new StaticTableDocument ( Arrays . asList ( \"Property\" , \"Value\" ), rows ); } Assignment Update the getFormatter() method accordingly to include new Documents (use the IUnitFormatter.addPresentation() method). The result should look like:","title":"Table"},{"location":"dev/4-tables-trees.html#tree","text":"For simple trees, you can use StaticTreeDocument . See below an example of a Tree that displays all function parameters. private ITreeDocument getFunctionsTree () { List < Node > treeRoot = new ArrayList <> (); try { if ( functions != null ) { for ( FunctionNode function : functions ) { treeRoot . add ( buildFunctionNode ( function )); } } } catch ( Exception e ) { logger . catching ( e ); } return new StaticTreeDocument ( treeRoot ); } private Node buildFunctionNode ( FunctionNode function ) { Node functionNode = new Node ( function . getName ()); if ( function . getParamCount () > 0 ) { for ( AstNode var : function . getParams ()) { functionNode . addChild ( new Node ((( Name ) var ). getIdentifier ())); } } return functionNode ; }","title":"Tree"},{"location":"dev/5-development-tips.html","text":"Warning This tutorial is deprecated, and will be rewritten to account for JEB 4 API changes. JEB Plugin Development Tutorial part 5/8 This tutorial aggregates a collection of tips that can help you during plugin development. Logging # Creating Loggers # Creating a new logger with the JEB API is simple: private static final ILogger logger = GlobalLog . getLogger ( MyClass . class ); It is good practice to create one logger per class. Loggers can be customized one by one, or globally via the GlobalLog factory. Using Loggers # There are several level of logs (error, warning, info, ...) and the logger methods use 2 parameters: the message to display the parameters of the message, as it is done for String.format() method. logger . info ( \"Hello %s\" , \"World\" ); Enabling Debug and Trace levels # By default, debug and trace logs are not displayed. You can activate them by ticking the Development mode in the Options menu: Logging destinations # By default, JEB sends log data to the Logger view in the UI client. Additional sinks can be added, such as buffers or output streams. For instance, if you would like to collect all logs to a file named jeb-test-output.log in your TEMP folder, your plugin could execute the following: String foldername = System . getProperty ( \"java.io.tmpdir\" ); File folder = foldername != null ? new File ( foldername ): TestData . getTestDataRoot (); File file = new File ( folder , \"jeb-test-output.log\" ); GlobalLog . addDestinationStream ( new PrintStream ( file )); Note Be careful, GlobalLog is a global factory object, that impacts the entire application. Debugging # If you are familiar with Eclipse and development tools in general, you know how useful proper debugging facility are: the program can be stopped and paused, current variables can be examined, etc. It is especially handy when troubleshooting a corner-case problem in your plugin. JEB can be debugged using a method called remote debugging . What you need to do is: Configure JEB to listen for debug connections Connect Eclipse to JEB Debugging setup: step-by-step # Start JEB using the following command-line from your JEB base directory: Windows/Linux java -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/app/jeb.jar.jar macOS java -XstartOnFirstThread -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/app/jeb.jar JEB is not started yet: it is waiting for a debugger connection on port 8001 Go to Eclipse: Select Run, Debug Configuration... Create a new entry in Remote Java Application and change the port to 8001 (keep the host as localhost ) Select Debug JEB should be launched and you may be able to stop when putting breakpoints in code. In practice, the true entry-point of a plugin is its no-argument constructor. You may decide to place a breakpoint there. You may also choose to stop in the canIdentify() method, which is appropriate for processor plugins such as this sample JavaScript parser.","title":"Part 5: Development Tips"},{"location":"dev/5-development-tips.html#logging","text":"","title":"Logging"},{"location":"dev/5-development-tips.html#creating-loggers","text":"Creating a new logger with the JEB API is simple: private static final ILogger logger = GlobalLog . getLogger ( MyClass . class ); It is good practice to create one logger per class. Loggers can be customized one by one, or globally via the GlobalLog factory.","title":"Creating Loggers"},{"location":"dev/5-development-tips.html#using-loggers","text":"There are several level of logs (error, warning, info, ...) and the logger methods use 2 parameters: the message to display the parameters of the message, as it is done for String.format() method. logger . info ( \"Hello %s\" , \"World\" );","title":"Using Loggers"},{"location":"dev/5-development-tips.html#enabling-debug-and-trace-levels","text":"By default, debug and trace logs are not displayed. You can activate them by ticking the Development mode in the Options menu:","title":"Enabling Debug and Trace levels"},{"location":"dev/5-development-tips.html#logging-destinations","text":"By default, JEB sends log data to the Logger view in the UI client. Additional sinks can be added, such as buffers or output streams. For instance, if you would like to collect all logs to a file named jeb-test-output.log in your TEMP folder, your plugin could execute the following: String foldername = System . getProperty ( \"java.io.tmpdir\" ); File folder = foldername != null ? new File ( foldername ): TestData . getTestDataRoot (); File file = new File ( folder , \"jeb-test-output.log\" ); GlobalLog . addDestinationStream ( new PrintStream ( file )); Note Be careful, GlobalLog is a global factory object, that impacts the entire application.","title":"Logging destinations"},{"location":"dev/5-development-tips.html#debugging","text":"If you are familiar with Eclipse and development tools in general, you know how useful proper debugging facility are: the program can be stopped and paused, current variables can be examined, etc. It is especially handy when troubleshooting a corner-case problem in your plugin. JEB can be debugged using a method called remote debugging . What you need to do is: Configure JEB to listen for debug connections Connect Eclipse to JEB","title":"Debugging"},{"location":"dev/5-development-tips.html#debugging-setup-step-by-step","text":"Start JEB using the following command-line from your JEB base directory: Windows/Linux java -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/app/jeb.jar.jar macOS java -XstartOnFirstThread -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/app/jeb.jar JEB is not started yet: it is waiting for a debugger connection on port 8001 Go to Eclipse: Select Run, Debug Configuration... Create a new entry in Remote Java Application and change the port to 8001 (keep the host as localhost ) Select Debug JEB should be launched and you may be able to stop when putting breakpoints in code. In practice, the true entry-point of a plugin is its no-argument constructor. You may decide to place a breakpoint there. You may also choose to stop in the canIdentify() method, which is appropriate for processor plugins such as this sample JavaScript parser.","title":"Debugging setup: step-by-step"},{"location":"dev/6-releasing-plugin.html","text":"Warning This tutorial is deprecated, and will be rewritten to account for JEB 4 API changes. JEB Plugin Development Tutorial part 6/8 When your plugin is ready, you may be looking into some way to share it. It is not convenient to hand out classfiles, not to mention changing Classpath and Classnames in the JEB Options panel. The solution is to package your plugin: this page shows you how to build a jar file containing your JEB plugin. Ant Build File # First, make sure to have a JEB_HOME environment variable pointing to your JEB directory. Then, use the following Ant build.xml file to build the sample JavaScript plugin. <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <project basedir= \".\" default= \"build\" name= \"jebplugin\" > <property name= \"jebjar\" value= \"${env.JEB_HOME}/bin/cl/jeb.jar\" /> <property name= \"jebpath\" value= \"/home/clucas/jeb-2.0.6.201508260620/bin/cl/jeb.jar\" /> <property name= \"outfile\" value= \"out/JebJavascriptPlugin.jar\" /> <property name= \"entryclass\" value= \"com.jeb.sample.JavascriptPlugin\" /> <property name= \"extcp_build\" value= \"lib/js.jar\" /> <property name= \"extcp_manifest\" value= \"lib/js.jar\" /> <target name= \"build\" depends= \"compile,package\" /> <target name= \"compile\" > <delete dir= \"bin\" /> <mkdir dir= \"bin\" /> <javac debug= \"true\" debuglevel= \"source,lines,vars\" destdir= \"bin\" includeantruntime= \"false\" source= \"1.7\" target= \"1.7\" > <src path= \"src\" /> <classpath> <pathelement location= \"${jebpath}\" /> <pathelement path= \"${extcp_build}\" /> </classpath> </javac> </target> <target name= \"package\" > <delete file= \"${outfile}\" /> <jar destfile= \"${outfile}\" > <manifest> <attribute name= \"Class-Path\" value= \"${extcp_manifest}\" /> <attribute name= \"JebPlugin-entryclass\" value= \"${entryclass}\" /> </manifest> <fileset dir= \"bin\" /> <fileset dir= \".\" includes= \"README.md\" /> </jar> </target> </project> Building the Plugin # You can run the build.xml directly from eclipse or execute the Ant command. It will generate a jar which has 2 specific entries in the manifest: Class-Path to indicate the required external libraries. JebPlugin-entryclass to indicate the classname, ie your plugin entry-point Copy both JebJavascriptPlugin.jar and js.jar to your plugin folder. You can remove the classpath and classnames entries related to JavascriptPlugin and js.jar. Note The best approach is to have one project per plugin. Assignment: Split the project and generate JavascriptPlugin.jar and HashJavascriptPlugin.jar. Remove all classpaths and classnames to check that it works. Generic Build Template # The following Ant template can be customized for your own plugins needs: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <!-- Sample Ant build file used to build and package a JEB plugin. - Requirements: set up the JEB_HOME environment variable to point to your JEB installation folder. - Customize the outfile, entryclass, extcp_build, and extcp_manifest properties. --> <project basedir= \".\" default= \"build\" name= \"jebplugin\" > <fail message= \"Set the plugin version number: ant -Dversion=x.y.z\" > <condition> <not> <isset property= \"version\" /> </not> </condition> </fail> <echo message= \"Plugin version: ${version}\" /> <property environment= \"env\" /> <echo message= \"JEB_HOME: ${env.JEB_HOME}\" /> <property name= \"jebjar\" value= \"${env.JEB_HOME}/bin/cl/jeb.jar\" /> <echo message= \"JEB Core expected at location: ${jebjar}\" /> <fail message= \"Please set JEB_HOME environment variable to point to your JEB installation folder\" > <condition> <not> <available file= \"${jebjar}\" /> </not> </condition> </fail> <property name= \"debuglevel\" value= \"source,lines,vars\" /> <property name= \"target\" value= \"1.7\" /> <property name= \"source\" value= \"1.7\" /> <!-- Mandatory properties --> <property name= \"outfile\" value= \"CUSTOMIZE\" /> <property name= \"entryclass\" value= \"CUSTOMIZE\" /> <!-- External libraries, for build process (semi-colon separated) --> <property name= \"extcp_build\" value= \"\" /> <!-- External libraries, for Manifest (space separated) --> <property name= \"extcp_manifest\" value= \"\" /> <target name= \"build\" depends= \"clean,compile,package\" /> <target name= \"audit\" depends= \"clean,compile-audit\" /> <target name= \"clean\" > <delete dir= \"bin\" /> <mkdir dir= \"bin\" /> </target> <target name= \"compile\" > <delete dir= \"bin\" /> <mkdir dir= \"bin\" /> <javac debug= \"true\" debuglevel= \"${debuglevel}\" destdir= \"bin\" includeantruntime= \"false\" source= \"${source}\" target= \"${target}\" encoding= \"UTF-8\" > <src path= \"src/main/java\" /> <classpath> <pathelement location= \"${jebjar}\" /> <pathelement path= \"${extcp_build}\" /> </classpath> </javac> </target> <target name= \"package\" > <delete file= \"${outfile}\" /> <jar destfile= \"${outfile}\" > <manifest> <attribute name= \"Class-Path\" value= \"${extcp_manifest}\" /> <attribute name= \"JebPlugin-entryclass\" value= \"${entryclass}\" /> <attribute name= \"JebPlugin-version\" value= \"${version}\" /> </manifest> <fileset dir= \"bin\" /> <!-- copy resources --> <fileset dir= \"src/main/java\" excludes= \"**/*.java\" /> <fileset dir= \".\" includes= \"README.md\" /> </jar> </target> </project>","title":"Part 6: Releasing a Plugin"},{"location":"dev/6-releasing-plugin.html#ant-build-file","text":"First, make sure to have a JEB_HOME environment variable pointing to your JEB directory. Then, use the following Ant build.xml file to build the sample JavaScript plugin. <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <project basedir= \".\" default= \"build\" name= \"jebplugin\" > <property name= \"jebjar\" value= \"${env.JEB_HOME}/bin/cl/jeb.jar\" /> <property name= \"jebpath\" value= \"/home/clucas/jeb-2.0.6.201508260620/bin/cl/jeb.jar\" /> <property name= \"outfile\" value= \"out/JebJavascriptPlugin.jar\" /> <property name= \"entryclass\" value= \"com.jeb.sample.JavascriptPlugin\" /> <property name= \"extcp_build\" value= \"lib/js.jar\" /> <property name= \"extcp_manifest\" value= \"lib/js.jar\" /> <target name= \"build\" depends= \"compile,package\" /> <target name= \"compile\" > <delete dir= \"bin\" /> <mkdir dir= \"bin\" /> <javac debug= \"true\" debuglevel= \"source,lines,vars\" destdir= \"bin\" includeantruntime= \"false\" source= \"1.7\" target= \"1.7\" > <src path= \"src\" /> <classpath> <pathelement location= \"${jebpath}\" /> <pathelement path= \"${extcp_build}\" /> </classpath> </javac> </target> <target name= \"package\" > <delete file= \"${outfile}\" /> <jar destfile= \"${outfile}\" > <manifest> <attribute name= \"Class-Path\" value= \"${extcp_manifest}\" /> <attribute name= \"JebPlugin-entryclass\" value= \"${entryclass}\" /> </manifest> <fileset dir= \"bin\" /> <fileset dir= \".\" includes= \"README.md\" /> </jar> </target> </project>","title":"Ant Build File"},{"location":"dev/6-releasing-plugin.html#building-the-plugin","text":"You can run the build.xml directly from eclipse or execute the Ant command. It will generate a jar which has 2 specific entries in the manifest: Class-Path to indicate the required external libraries. JebPlugin-entryclass to indicate the classname, ie your plugin entry-point Copy both JebJavascriptPlugin.jar and js.jar to your plugin folder. You can remove the classpath and classnames entries related to JavascriptPlugin and js.jar. Note The best approach is to have one project per plugin. Assignment: Split the project and generate JavascriptPlugin.jar and HashJavascriptPlugin.jar. Remove all classpaths and classnames to check that it works.","title":"Building the Plugin"},{"location":"dev/6-releasing-plugin.html#generic-build-template","text":"The following Ant template can be customized for your own plugins needs: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <!-- Sample Ant build file used to build and package a JEB plugin. - Requirements: set up the JEB_HOME environment variable to point to your JEB installation folder. - Customize the outfile, entryclass, extcp_build, and extcp_manifest properties. --> <project basedir= \".\" default= \"build\" name= \"jebplugin\" > <fail message= \"Set the plugin version number: ant -Dversion=x.y.z\" > <condition> <not> <isset property= \"version\" /> </not> </condition> </fail> <echo message= \"Plugin version: ${version}\" /> <property environment= \"env\" /> <echo message= \"JEB_HOME: ${env.JEB_HOME}\" /> <property name= \"jebjar\" value= \"${env.JEB_HOME}/bin/cl/jeb.jar\" /> <echo message= \"JEB Core expected at location: ${jebjar}\" /> <fail message= \"Please set JEB_HOME environment variable to point to your JEB installation folder\" > <condition> <not> <available file= \"${jebjar}\" /> </not> </condition> </fail> <property name= \"debuglevel\" value= \"source,lines,vars\" /> <property name= \"target\" value= \"1.7\" /> <property name= \"source\" value= \"1.7\" /> <!-- Mandatory properties --> <property name= \"outfile\" value= \"CUSTOMIZE\" /> <property name= \"entryclass\" value= \"CUSTOMIZE\" /> <!-- External libraries, for build process (semi-colon separated) --> <property name= \"extcp_build\" value= \"\" /> <!-- External libraries, for Manifest (space separated) --> <property name= \"extcp_manifest\" value= \"\" /> <target name= \"build\" depends= \"clean,compile,package\" /> <target name= \"audit\" depends= \"clean,compile-audit\" /> <target name= \"clean\" > <delete dir= \"bin\" /> <mkdir dir= \"bin\" /> </target> <target name= \"compile\" > <delete dir= \"bin\" /> <mkdir dir= \"bin\" /> <javac debug= \"true\" debuglevel= \"${debuglevel}\" destdir= \"bin\" includeantruntime= \"false\" source= \"${source}\" target= \"${target}\" encoding= \"UTF-8\" > <src path= \"src/main/java\" /> <classpath> <pathelement location= \"${jebjar}\" /> <pathelement path= \"${extcp_build}\" /> </classpath> </javac> </target> <target name= \"package\" > <delete file= \"${outfile}\" /> <jar destfile= \"${outfile}\" > <manifest> <attribute name= \"Class-Path\" value= \"${extcp_manifest}\" /> <attribute name= \"JebPlugin-entryclass\" value= \"${entryclass}\" /> <attribute name= \"JebPlugin-version\" value= \"${version}\" /> </manifest> <fileset dir= \"bin\" /> <!-- copy resources --> <fileset dir= \"src/main/java\" excludes= \"**/*.java\" /> <fileset dir= \".\" includes= \"README.md\" /> </jar> </target> </project>","title":"Generic Build Template"},{"location":"dev/7-unit-interactivity.html","text":"Warning This tutorial is deprecated, and will be rewritten to account for JEB 4 API changes. JEB Plugin Development Tutorial part 7/8 The source code for part 7 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial7 branch: git checkout tutorial7 Syntax Highlighting # Let's dive deeper and implement the first thing we want to get from an editor: syntax highlighting. This will allow us to uncover more corners of the JEB API. We will need to add item highlights on some parts of the text. Remember our sample, we will use only a single part: function a () { alert ( \"a called\" ); } A standard editor highlights keywords: they are specific words (reserved, most of the time) that are related to a language. In JavaScript, they are \"function\", \"var\", \"if\", \"else\"... Other interesting artifacts that could be highlighted are strings. In this tutorial, we will highlight functions, variables and strings surrounded by double-quotes. We want to modify only the display, not interact with the model (eg, renaming, formatting), so we will only look at ITextDocument . It has two important features: it builds ITextDocumentPart it has a coordinate to/from address conversion system. We will see this later. Let's concentrate on the ITextDocumentPart . The interface defines two methods: one returns a list of ILine objects: the part is split into lines. the other one returns a list of IAnchor objects. Anchors act the same as chapters for a book: an anchor indicates the beginning of a new section. If you don't need it, you can use a single anchor for the entire document. Remember that a part represents a part of the document (for buffered document) or can include the whole document. So the list of lines can be all the lines or just the lines of a part. We won't treat buffered document in this tutorial to keep things simple. Once again, let's check only the most important object, ILine . It contains: a CharSequence : the text line a List of ITextItem . As said in the API: A text item is used to identify a particular sequence of characters. This looks like what we were looking for. We will need to add ITextItem to our current model. The TextItem default implementation can be used. It takes as argument: the start offset of the keyword the length of the keyword an ItemClassIdentifiers identifier to apply a specific semantic and eventually, style, to your element. You can configure the display of these styles in the Edit, Fonts and Style... panel. Assignment Clone the sample code and checkout the tutorial7 branch. It already displays functions using a special ItemClassIdentifiers. Try to do the same for the var keyword and string constants. Notifications # JEB is a security-oriented product: its aim is to help you analyze malicious code and pin-point potential areas of interest. Notifications can be used to show areas that are noteworthy; styles can be attached to notifications to highlight their corresponding elements on rendering. Notifications are global to a unit, they should be generated when the processor plugin process() -es the input. For the sake of this tutorial, we want to highlight the usage of function \"alert\" because it can block the UI unreasonably. The AbstractUnit interface exposes the following method: public addtNotifications(IUnitNotification unit); We will use the default implementation: UnitNotification . In the process() method of your JavaScript plugin, add the following snippet: root . visit ( new NodeVisitor () { @Override public boolean visit ( AstNode node ) { switch ( node . getType ()) { case Token . EXPR_VOID : case Token . EXPR_RESULT : break ; case Token . CALL : visitTarget ((( FunctionCall ) node ). getTarget ()); break ; default : break ; } return true ; } private void visitTarget ( AstNode target ) { if ( target . getType () == Token . NAME ) { if ((( Name ) target ). getIdentifier (). equals ( \"alert\" )) { // Add notification addNotification ( new UnitNotification ( NotificationType . POTENTIALLY_HARMFUL , String . format ( \"alert is detected at position %d\" , target . getAbsolutePosition ()))); } } } } ); The visit() method recursively process all the elements. When we have a JavaScript function call, we check the name and add a notification if the function is \"alert\". Now, you should see something new in the UI: If you want to see all notifications as soon as the file is opened in JEB, you will need to slightly modify your code. Since the process() method is only called on opening an IUnit, the best is to call it directly after IUnit creation: public IUnit prepare ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent ) { IUnit sampleUnit = new SampleUnit ( name , input , unitProcessor , parent , pdm ); sampleUnit . process (); // forces children calculation return sampleUnit ; } Always be careful to add this line somewhere in the process() method to indicate that the processing should not be done once again: setProcessed ( true ); Now, we see something interesting on the screenshot: there is an address column that is blank. IUnitNotification defines an address binding which can be used to jump to the related section. Let's see how to use it. Addressing # To be able to jump to a correct Address , we need to define a binding from Unit addressing (address) to a position in a Document (coordinates). ITextDocument uses ICoordinates : it contains the anchor id, a line number relative to the anchor, and the position (column offset) in the line. Addresses, however, are user-defined (in this context, the user is the plugin developer): it is up to user to define them and their granularity. For instance, you can choose to support addresses: at function level/ element level. For example: \"function a\", \"function a / statement 1\" at byte level. For example, using absolute byte address in file: \"0x1A\", \"0x89\" at any other level. For example, at each line, each character for that line, etc. The important aspect of addresses is that an address must not be directly tied to a Document (your implementation of Document can change: if you add a beautifier, if you decide to format your document on a single line, if you use a tree/table for your representation, etc.). Of course, there should still be a way to make the link between the two addressing systems: Note Refer to the technical draft \"Positioning within inputs, units, and documents\" for additional details on addressing. At last, an address must identify an object/position in a unique way. Otherwise, you wouldn't know where to jump. For our sample JavaScript plugin, we will use the addressing using AstNode.getAbsolutePosition() . When jumping from Notification Panel, we have the current address (Absolute position), and we will jump to an ICoordinates in the ITextDocument. So the main method to implement is: public ICoordinates addressToCoordinates(String address); Assignment Implement the addressToCoordinates method. There is also another column in the Notification Panel called \"Label\": it represents the label of the address. You can indicate here a human readable label: for example, the name of the function. To display label, we need to inherit from IInteractiveUnit and implement String getAddressLabel(String address) to see changes in the Notification Panel. Assignment Implement the getAddressLabel method. A solution to the assignments can be found by checking out the branch tutorial7_solution of the sample code . You may have noticed that IInteractiveUnit provides a lot of methods. We will focus on it in the next part!","title":"Part 7: Interactivity"},{"location":"dev/7-unit-interactivity.html#syntax-highlighting","text":"Let's dive deeper and implement the first thing we want to get from an editor: syntax highlighting. This will allow us to uncover more corners of the JEB API. We will need to add item highlights on some parts of the text. Remember our sample, we will use only a single part: function a () { alert ( \"a called\" ); } A standard editor highlights keywords: they are specific words (reserved, most of the time) that are related to a language. In JavaScript, they are \"function\", \"var\", \"if\", \"else\"... Other interesting artifacts that could be highlighted are strings. In this tutorial, we will highlight functions, variables and strings surrounded by double-quotes. We want to modify only the display, not interact with the model (eg, renaming, formatting), so we will only look at ITextDocument . It has two important features: it builds ITextDocumentPart it has a coordinate to/from address conversion system. We will see this later. Let's concentrate on the ITextDocumentPart . The interface defines two methods: one returns a list of ILine objects: the part is split into lines. the other one returns a list of IAnchor objects. Anchors act the same as chapters for a book: an anchor indicates the beginning of a new section. If you don't need it, you can use a single anchor for the entire document. Remember that a part represents a part of the document (for buffered document) or can include the whole document. So the list of lines can be all the lines or just the lines of a part. We won't treat buffered document in this tutorial to keep things simple. Once again, let's check only the most important object, ILine . It contains: a CharSequence : the text line a List of ITextItem . As said in the API: A text item is used to identify a particular sequence of characters. This looks like what we were looking for. We will need to add ITextItem to our current model. The TextItem default implementation can be used. It takes as argument: the start offset of the keyword the length of the keyword an ItemClassIdentifiers identifier to apply a specific semantic and eventually, style, to your element. You can configure the display of these styles in the Edit, Fonts and Style... panel. Assignment Clone the sample code and checkout the tutorial7 branch. It already displays functions using a special ItemClassIdentifiers. Try to do the same for the var keyword and string constants.","title":"Syntax Highlighting"},{"location":"dev/7-unit-interactivity.html#notifications","text":"JEB is a security-oriented product: its aim is to help you analyze malicious code and pin-point potential areas of interest. Notifications can be used to show areas that are noteworthy; styles can be attached to notifications to highlight their corresponding elements on rendering. Notifications are global to a unit, they should be generated when the processor plugin process() -es the input. For the sake of this tutorial, we want to highlight the usage of function \"alert\" because it can block the UI unreasonably. The AbstractUnit interface exposes the following method: public addtNotifications(IUnitNotification unit); We will use the default implementation: UnitNotification . In the process() method of your JavaScript plugin, add the following snippet: root . visit ( new NodeVisitor () { @Override public boolean visit ( AstNode node ) { switch ( node . getType ()) { case Token . EXPR_VOID : case Token . EXPR_RESULT : break ; case Token . CALL : visitTarget ((( FunctionCall ) node ). getTarget ()); break ; default : break ; } return true ; } private void visitTarget ( AstNode target ) { if ( target . getType () == Token . NAME ) { if ((( Name ) target ). getIdentifier (). equals ( \"alert\" )) { // Add notification addNotification ( new UnitNotification ( NotificationType . POTENTIALLY_HARMFUL , String . format ( \"alert is detected at position %d\" , target . getAbsolutePosition ()))); } } } } ); The visit() method recursively process all the elements. When we have a JavaScript function call, we check the name and add a notification if the function is \"alert\". Now, you should see something new in the UI: If you want to see all notifications as soon as the file is opened in JEB, you will need to slightly modify your code. Since the process() method is only called on opening an IUnit, the best is to call it directly after IUnit creation: public IUnit prepare ( String name , IInput input , IUnitProcessor unitProcessor , IUnitCreator parent ) { IUnit sampleUnit = new SampleUnit ( name , input , unitProcessor , parent , pdm ); sampleUnit . process (); // forces children calculation return sampleUnit ; } Always be careful to add this line somewhere in the process() method to indicate that the processing should not be done once again: setProcessed ( true ); Now, we see something interesting on the screenshot: there is an address column that is blank. IUnitNotification defines an address binding which can be used to jump to the related section. Let's see how to use it.","title":"Notifications"},{"location":"dev/7-unit-interactivity.html#addressing","text":"To be able to jump to a correct Address , we need to define a binding from Unit addressing (address) to a position in a Document (coordinates). ITextDocument uses ICoordinates : it contains the anchor id, a line number relative to the anchor, and the position (column offset) in the line. Addresses, however, are user-defined (in this context, the user is the plugin developer): it is up to user to define them and their granularity. For instance, you can choose to support addresses: at function level/ element level. For example: \"function a\", \"function a / statement 1\" at byte level. For example, using absolute byte address in file: \"0x1A\", \"0x89\" at any other level. For example, at each line, each character for that line, etc. The important aspect of addresses is that an address must not be directly tied to a Document (your implementation of Document can change: if you add a beautifier, if you decide to format your document on a single line, if you use a tree/table for your representation, etc.). Of course, there should still be a way to make the link between the two addressing systems: Note Refer to the technical draft \"Positioning within inputs, units, and documents\" for additional details on addressing. At last, an address must identify an object/position in a unique way. Otherwise, you wouldn't know where to jump. For our sample JavaScript plugin, we will use the addressing using AstNode.getAbsolutePosition() . When jumping from Notification Panel, we have the current address (Absolute position), and we will jump to an ICoordinates in the ITextDocument. So the main method to implement is: public ICoordinates addressToCoordinates(String address); Assignment Implement the addressToCoordinates method. There is also another column in the Notification Panel called \"Label\": it represents the label of the address. You can indicate here a human readable label: for example, the name of the function. To display label, we need to inherit from IInteractiveUnit and implement String getAddressLabel(String address) to see changes in the Notification Panel. Assignment Implement the getAddressLabel method. A solution to the assignments can be found by checking out the branch tutorial7_solution of the sample code . You may have noticed that IInteractiveUnit provides a lot of methods. We will focus on it in the next part!","title":"Addressing"},{"location":"dev/8-more-interactivity.html","text":"Warning This tutorial is deprecated, and will be rewritten to account for JEB 4 API changes. JEB Plugin Development Tutorial part 8/8 The source code for part 8 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial8 branch: git checkout tutorial8 User Actions # CanExecute # JEB provides the ability to interact with the units. Those units are called interactive units . The simplest way to interact with units is through well-known actions . The actions have to be implemented by the plugin developer. An action has an ActionContext as a parameter, which allows the plugin to retrieve: the action id: one defined in the Actions class. It indicates which action is involved (Comment, Rename...) the address: the current position in the document the item id: we will discuss it later. First, why are all these actions grayed out? Because canExecuteAction() does not return true - yet. public boolean canExecuteAction ( ActionContext actionContext ) { logger . info ( \"%s called with address %s and actionId %d\" , \"canExecuteAction\" , actionContext . getAddress (), actionContext . getActionId ()); return false ; } As you can see in the logs, this method is called each time you move the caret in the document. What if we try to return true instead of false? As expected, all actions become clickable. Note that you can also use the toolbar icons or, even better, the keyboard shortcuts. Nothing happens when you click on any action: it is up to the plugin developer to implement the desired feature. We will implement a simple action: renaming of a String . (Note: we could as well rename functions, methods, variables... but we need to check in the model where they are used to replace all occurrences, consistently. The added complexity is out-of-scope in this API introduction tutorial.) First, we need to activate the rename feature when we are on a String: Assignment Save the string references and test if the caret in on a String. PrepareExecution # When clicking on the \"Rename\" action button, the method IInteractiveUnit.prepareExecution() is called. Its goal is to prepare the execution of the code and, in the case of renaming, it also provides the initial value that we want to edit: it is called before displaying the following pop up: You need to return true in the prepareExecution method to indicate that the processing should continue. The prepareExecution method has one more parameter of type IActionData . To fill up the name field, we need to retrieve the correct Action Data type: Use ActionRenameData to prefill the rename field with its current value. public boolean prepareExecution ( ActionContext actionContext , IActionData actionData ) { if ( actionContext . getActionId () == Actions . RENAME ) { StringLiteral string = getElementAt ( actionContext . getAddress (), strings ); if ( string != null ) { (( ActionRenameData ) actionData ). setCurrentName ( string . getValue ()); return true ; } } return false ; } Note that IActionData embeds a generic map to pass discretionary objects from prepareExecution to executeAction method. ExecuteAction # The executeAction method is the last step: it performs the action and modifies the model. What should we modify now? IInput : this is a pointer to original file, it makes no sense. AstRoot : this is our kind-of model, but there is no way to retrieve the input data (the toString() method has a specific implementation and the toSource() auto-formats and remove comments. IUnit is the central part of your plugin: it is responsible for updating the model and keep coherence regarding all its document. But there is something wrong with the initial design: we don't save a reference Document in the Unit. Documents shall at least work with the same object as IUnit, and at least have a reference on their IUnit in order to retrieve the data (this is a good practice in JEB). Therefore, we will now modify our unit to keep references of all lines (using a List ). One problem that will remain is the mandatory conversion at the ITextDocumentPart level: public List <? extends ILine > getLines The getLines method is called each time you scroll/move around the document, so it would be too costly to recalculate the list of ILines each time it is called. It must be buffered and refreshed on changes: the unit must notify its Documents when the model changes. To make notifications work, you must: Register the notified element: public class JavascriptDocument extends EventSource implements ITextDocument , IEventListener { public JavascriptDocument ( JavascriptUnit unit ) { this . unit = unit ; unit . addListener ( this ); refreshPart (); } // ... public void onEvent ( IEvent e ) { if ( e . getType () == J . UnitChange ) { refreshPart (); this . notifyListeners ( e ); } } } Call the notify method in the executeAction method (on success): notifyListeners ( new JebEvent ( J . UnitChange )); Note Refer to the technical draft \"Staying informed of unit changes\" for more details about unit changes tracking within documents. Assignment Finish the renaming implementation. Navigation # JEB natively manages navigation feature with four predefined actions selectable from menu or directly with shortcuts: Jump To : move caret to a specific address. It uses the ITextDocument.addressToCoordinates() that we already implemented for Notifications. Navigate Forward / Navigate Backward : move caret to the previous/next position (caret position history is saved each time you jump) Follow : jump to an address bound to the current element. The best example is on a function call: you can jump to its definition Assignment Implement Jump To for function names Now, let's look at Follow . We can see that it is active only when we set the caret on strings, var, function... this is because the Follow feature is bound to Items, more precisely, the IActionableItem . When clicking on Follow , if the caret is positioned on an Item, the function IInteractiveUnit.getAddressOfItem() is called. Assignment Implement Follow for function name (it should work on the latest b();) A solution to the assignments can be found by checking out the branch tutorial8 of the sample code .","title":"Part 8: More on Interactivity"},{"location":"dev/8-more-interactivity.html#user-actions","text":"","title":"User Actions"},{"location":"dev/8-more-interactivity.html#canexecute","text":"JEB provides the ability to interact with the units. Those units are called interactive units . The simplest way to interact with units is through well-known actions . The actions have to be implemented by the plugin developer. An action has an ActionContext as a parameter, which allows the plugin to retrieve: the action id: one defined in the Actions class. It indicates which action is involved (Comment, Rename...) the address: the current position in the document the item id: we will discuss it later. First, why are all these actions grayed out? Because canExecuteAction() does not return true - yet. public boolean canExecuteAction ( ActionContext actionContext ) { logger . info ( \"%s called with address %s and actionId %d\" , \"canExecuteAction\" , actionContext . getAddress (), actionContext . getActionId ()); return false ; } As you can see in the logs, this method is called each time you move the caret in the document. What if we try to return true instead of false? As expected, all actions become clickable. Note that you can also use the toolbar icons or, even better, the keyboard shortcuts. Nothing happens when you click on any action: it is up to the plugin developer to implement the desired feature. We will implement a simple action: renaming of a String . (Note: we could as well rename functions, methods, variables... but we need to check in the model where they are used to replace all occurrences, consistently. The added complexity is out-of-scope in this API introduction tutorial.) First, we need to activate the rename feature when we are on a String: Assignment Save the string references and test if the caret in on a String.","title":"CanExecute"},{"location":"dev/8-more-interactivity.html#prepareexecution","text":"When clicking on the \"Rename\" action button, the method IInteractiveUnit.prepareExecution() is called. Its goal is to prepare the execution of the code and, in the case of renaming, it also provides the initial value that we want to edit: it is called before displaying the following pop up: You need to return true in the prepareExecution method to indicate that the processing should continue. The prepareExecution method has one more parameter of type IActionData . To fill up the name field, we need to retrieve the correct Action Data type: Use ActionRenameData to prefill the rename field with its current value. public boolean prepareExecution ( ActionContext actionContext , IActionData actionData ) { if ( actionContext . getActionId () == Actions . RENAME ) { StringLiteral string = getElementAt ( actionContext . getAddress (), strings ); if ( string != null ) { (( ActionRenameData ) actionData ). setCurrentName ( string . getValue ()); return true ; } } return false ; } Note that IActionData embeds a generic map to pass discretionary objects from prepareExecution to executeAction method.","title":"PrepareExecution"},{"location":"dev/8-more-interactivity.html#executeaction","text":"The executeAction method is the last step: it performs the action and modifies the model. What should we modify now? IInput : this is a pointer to original file, it makes no sense. AstRoot : this is our kind-of model, but there is no way to retrieve the input data (the toString() method has a specific implementation and the toSource() auto-formats and remove comments. IUnit is the central part of your plugin: it is responsible for updating the model and keep coherence regarding all its document. But there is something wrong with the initial design: we don't save a reference Document in the Unit. Documents shall at least work with the same object as IUnit, and at least have a reference on their IUnit in order to retrieve the data (this is a good practice in JEB). Therefore, we will now modify our unit to keep references of all lines (using a List ). One problem that will remain is the mandatory conversion at the ITextDocumentPart level: public List <? extends ILine > getLines The getLines method is called each time you scroll/move around the document, so it would be too costly to recalculate the list of ILines each time it is called. It must be buffered and refreshed on changes: the unit must notify its Documents when the model changes. To make notifications work, you must: Register the notified element: public class JavascriptDocument extends EventSource implements ITextDocument , IEventListener { public JavascriptDocument ( JavascriptUnit unit ) { this . unit = unit ; unit . addListener ( this ); refreshPart (); } // ... public void onEvent ( IEvent e ) { if ( e . getType () == J . UnitChange ) { refreshPart (); this . notifyListeners ( e ); } } } Call the notify method in the executeAction method (on success): notifyListeners ( new JebEvent ( J . UnitChange )); Note Refer to the technical draft \"Staying informed of unit changes\" for more details about unit changes tracking within documents. Assignment Finish the renaming implementation.","title":"ExecuteAction"},{"location":"dev/8-more-interactivity.html#navigation","text":"JEB natively manages navigation feature with four predefined actions selectable from menu or directly with shortcuts: Jump To : move caret to a specific address. It uses the ITextDocument.addressToCoordinates() that we already implemented for Notifications. Navigate Forward / Navigate Backward : move caret to the previous/next position (caret position history is saved each time you jump) Follow : jump to an address bound to the current element. The best example is on a function call: you can jump to its definition Assignment Implement Jump To for function names Now, let's look at Follow . We can see that it is active only when we set the caret on strings, var, function... this is because the Follow feature is bound to Items, more precisely, the IActionableItem . When clicking on Follow , if the caret is positioned on an Item, the function IInteractiveUnit.getAddressOfItem() is called. Assignment Implement Follow for function name (it should work on the latest b();) A solution to the assignments can be found by checking out the branch tutorial8 of the sample code .","title":"Navigation"},{"location":"dev/android-scripting.html","text":"This section focuses on writing JEB Python scripts specifically to aid in the analysis of Android applications. Dex units # Recall JEB analysis modules produce IUnit s, visible in the Project Explorer view: Sample Project, Artifact, Units and sub-units IDexUnit and associated classes # The dex unit interface is your entry-point to access dex elements: from com.pnfsoftware.jeb.client.api import IScript from com.pnfsoftware.jeb.core.units.code.android import IDexUnit , IApkUnit class SomeScript ( IScript ): def run ( self , ctx ): prj = ctx . getMainProject () # current project; None if no project is opened dex = prj . findUnit ( IDexUnit ) # find the first dex unit #dexlist = prj.findUnits(IDexUnit) # retrieve a list of dex units #apk = prj.findUnits(IApkUnit) # find the first dex unit for m in dex . getMethods (): print m . getSignature () # print method reference descriptor dex file representation # The diagram below is a high-level view of JEB types holding dex file information. This structure mirrors the dex file format's. (Not all types are represented, refer to the API reference for a complete list.) APK units # Android APK are represented by IApkUnit s. from com.pnfsoftware.jeb.client.api import IScript from com.pnfsoftware.jeb.core.units.code.android import IApkUnit class SomeScript ( IScript ): def run ( self , ctx ): prj = ctx . getMainProject () # current project; None if no project is opened apk = prj . findUnits ( IApkUnit ) # find the first apk unit print ( apk . isDebuggable ()) # ... UI client specifics # When a script is run within the UI client, the ctx provided to the run() method is IGraphicalClientContext (extending IClientContext ). Additional methods are provided to interact with workspace widgets (unit views, fragments, etc.). The diagram below shows the connection between UI elements types and the document types they hold. Reference type: IGraphicalClientContext dexdec units # The entry-point interface is IDexDecompilerUnit , usually a child of an underlying IDexUnit . dexdec units produce IJavaSourceUnit , holding decompiled elements (classes and methods). Accessing the IR # The Dex decompiler plugin can load external Intermediate Representation (IR) plugins that are called during the decompilation pipeline to further refine and optimize a method decompilation. Those plugins can be compiled as jar, and/or written in Java or Python. See this tutorial for a complete step-by-step example on how to write a dexdec IR script plugin, in Python. Reference documentation Accessing the Java AST # Java AST generated by dexdec can be manipulated via the Java AST API. Reference documentation","title":"Scripting for Android Reversing"},{"location":"dev/android-scripting.html#dex-units","text":"Recall JEB analysis modules produce IUnit s, visible in the Project Explorer view: Sample Project, Artifact, Units and sub-units","title":"Dex units"},{"location":"dev/android-scripting.html#idexunit-and-associated-classes","text":"The dex unit interface is your entry-point to access dex elements: from com.pnfsoftware.jeb.client.api import IScript from com.pnfsoftware.jeb.core.units.code.android import IDexUnit , IApkUnit class SomeScript ( IScript ): def run ( self , ctx ): prj = ctx . getMainProject () # current project; None if no project is opened dex = prj . findUnit ( IDexUnit ) # find the first dex unit #dexlist = prj.findUnits(IDexUnit) # retrieve a list of dex units #apk = prj.findUnits(IApkUnit) # find the first dex unit for m in dex . getMethods (): print m . getSignature () # print method reference descriptor","title":"IDexUnit and associated classes"},{"location":"dev/android-scripting.html#dex-file-representation","text":"The diagram below is a high-level view of JEB types holding dex file information. This structure mirrors the dex file format's. (Not all types are represented, refer to the API reference for a complete list.)","title":"dex file representation"},{"location":"dev/android-scripting.html#apk-units","text":"Android APK are represented by IApkUnit s. from com.pnfsoftware.jeb.client.api import IScript from com.pnfsoftware.jeb.core.units.code.android import IApkUnit class SomeScript ( IScript ): def run ( self , ctx ): prj = ctx . getMainProject () # current project; None if no project is opened apk = prj . findUnits ( IApkUnit ) # find the first apk unit print ( apk . isDebuggable ()) # ...","title":"APK units"},{"location":"dev/android-scripting.html#ui-client-specifics","text":"When a script is run within the UI client, the ctx provided to the run() method is IGraphicalClientContext (extending IClientContext ). Additional methods are provided to interact with workspace widgets (unit views, fragments, etc.). The diagram below shows the connection between UI elements types and the document types they hold. Reference type: IGraphicalClientContext","title":"UI client specifics"},{"location":"dev/android-scripting.html#dexdec-units","text":"The entry-point interface is IDexDecompilerUnit , usually a child of an underlying IDexUnit . dexdec units produce IJavaSourceUnit , holding decompiled elements (classes and methods).","title":"dexdec units"},{"location":"dev/android-scripting.html#accessing-the-ir","text":"The Dex decompiler plugin can load external Intermediate Representation (IR) plugins that are called during the decompilation pipeline to further refine and optimize a method decompilation. Those plugins can be compiled as jar, and/or written in Java or Python. See this tutorial for a complete step-by-step example on how to write a dexdec IR script plugin, in Python. Reference documentation","title":"Accessing the IR"},{"location":"dev/android-scripting.html#accessing-the-java-ast","text":"Java AST generated by dexdec can be manipulated via the Java AST API. Reference documentation","title":"Accessing the Java AST"},{"location":"dev/introducing-jeb-extensions.html","text":"JEB offers a rich API that can be used to develop: Scripts : Python scripts can be used to automate simple tasks When run within the UI client, scripts can interact with GUI elements Plugins (aka back-end extensions ): Processor plugins such as disassemblers, file parsers, etc. Engines plugins such as second-pass code analyzers, working on results produced by other plugins, or helpers Decompiler plugins such as IR optimizer plugins for dexdec or gendec Other plugin types include code analysis extensions (to customize native code analysis), contributions (for information overlays), interpreter (command-line processors), etc. Front-end clients , such as: The official UI client Headless clients for automation pipelines Capabilities # Only professional licenses offer full API access. However, all licenses allow script and plugin execution from within the UI client: Licenses Type UI client Other Clients (e.g. command-line) Non-Pro UI scripts no Pro UI scripts + plugins scripts + plugins High-level Architecture # Grasping the high-level concepts of how pieces fit together within JEB will make you a more efficient extensions developer. At the highest-level, JEB is separated into back-end and front-end components: The back-end components are responsible for processing input artifacts. They provide an execution environment for native and third-party plugins, including processor plugins, such as file parsers. The front-end components are responsible for processing input commands and rendering back-end results. A variety of front-ends may be created using the API exposed by the back-end. Note All JEB distributions ship with the UI client front-end that runs on all major desktop operating systems (Windows x86_64, Linux x86_64/aarch64, macOS x86_64/aarch64). The diagram below shows the relationship between back-end and front-end components: High-level architecture diagram Depending on their license type, users may be able to develop third-party plugins and instruct the back-end to load them. This enables power users to craft input processors that cater to their specific needs (e.g., a disassembler for an exotic or virtual CPU). You may verify your API usage capabilities by starting JEB with the -c --license command line flag. Application Programming Interfaces # Clients and extensions (plugins, scripts) use the JEB API. The API reference documentation is available online as well as offline, within your JEB software package (file doc/apidoc.zip ). Scripts vs Plugins # Scripts ... Implement IScript Are called by users to achieve small tasks Example: modify some code, navigate somewhere, display some info, etc. Must be written in Python (they are run in a Jython VM) Ideal for rapid development and prototyping Are executed by JEB on-demand In the GUI client, can be executed via the File menu Plugins ... Implement a specialized sub-type of IPlugin Can perform a variety of tasks, from input processing, disassembling, decompiling, adding functionality to other plugins, event-triggered actions, etc. May be compiled as jar; some plugin types may be written as scripts (Java or Python) Executing Scripts # All versions of JEB can execute client scripts within the UI client. Scripts should be dropped in your scripts/ directory (or any other directory specified in your .ScriptsFolder client option ). Use the File, Scripts, Script Selector... menu command to execute, edit, or create a script. Client scripts are written in Python, and are executed within a 2.7 Jython VM (a Java implementation of the Python VM) Scripts, like any extension, use the JEB API. Client scripts executed inside the UI client also have access to the UI-API , located in the package com.pnfsoftware.jeb.client.ui . Classes of the UI-API allow graphical manipulation of views, fragments, items, etc. (This API is optionally implemented by clients; the desktop client implements it.) You will find a large collection of sample scripts on our public GitHub repository . Executing Engines Plugins # Engines plugins live within the engines context of the JEB back-end. They may execute code continuously, be event-driven, or even be explicitly called by the user. All third-party plugins must be dropped in your coreplugins/ directory (or any other directory specified in your .PluginsFolder back-end option ). Use the File, Engines, Execute, ... menu command to execute an engines plugin. Note Engines plugins are JEB plugins that implement the IEnginesPlugin interface. The full list of engines plugins loaded within your JEB instance context can be seen by running the File, Engines, Plugins command. You may double-click a plugin to execute it. Other Plugins # A collection of open-source plugins can be found on our public GitHub repository .","title":"Introducing JEB Extensions"},{"location":"dev/introducing-jeb-extensions.html#capabilities","text":"Only professional licenses offer full API access. However, all licenses allow script and plugin execution from within the UI client: Licenses Type UI client Other Clients (e.g. command-line) Non-Pro UI scripts no Pro UI scripts + plugins scripts + plugins","title":"Capabilities"},{"location":"dev/introducing-jeb-extensions.html#high-level-architecture","text":"Grasping the high-level concepts of how pieces fit together within JEB will make you a more efficient extensions developer. At the highest-level, JEB is separated into back-end and front-end components: The back-end components are responsible for processing input artifacts. They provide an execution environment for native and third-party plugins, including processor plugins, such as file parsers. The front-end components are responsible for processing input commands and rendering back-end results. A variety of front-ends may be created using the API exposed by the back-end. Note All JEB distributions ship with the UI client front-end that runs on all major desktop operating systems (Windows x86_64, Linux x86_64/aarch64, macOS x86_64/aarch64). The diagram below shows the relationship between back-end and front-end components: High-level architecture diagram Depending on their license type, users may be able to develop third-party plugins and instruct the back-end to load them. This enables power users to craft input processors that cater to their specific needs (e.g., a disassembler for an exotic or virtual CPU). You may verify your API usage capabilities by starting JEB with the -c --license command line flag.","title":"High-level Architecture"},{"location":"dev/introducing-jeb-extensions.html#application-programming-interfaces","text":"Clients and extensions (plugins, scripts) use the JEB API. The API reference documentation is available online as well as offline, within your JEB software package (file doc/apidoc.zip ).","title":"Application Programming Interfaces"},{"location":"dev/introducing-jeb-extensions.html#scripts-vs-plugins","text":"Scripts ... Implement IScript Are called by users to achieve small tasks Example: modify some code, navigate somewhere, display some info, etc. Must be written in Python (they are run in a Jython VM) Ideal for rapid development and prototyping Are executed by JEB on-demand In the GUI client, can be executed via the File menu Plugins ... Implement a specialized sub-type of IPlugin Can perform a variety of tasks, from input processing, disassembling, decompiling, adding functionality to other plugins, event-triggered actions, etc. May be compiled as jar; some plugin types may be written as scripts (Java or Python)","title":"Scripts vs Plugins"},{"location":"dev/introducing-jeb-extensions.html#executing-scripts","text":"All versions of JEB can execute client scripts within the UI client. Scripts should be dropped in your scripts/ directory (or any other directory specified in your .ScriptsFolder client option ). Use the File, Scripts, Script Selector... menu command to execute, edit, or create a script. Client scripts are written in Python, and are executed within a 2.7 Jython VM (a Java implementation of the Python VM) Scripts, like any extension, use the JEB API. Client scripts executed inside the UI client also have access to the UI-API , located in the package com.pnfsoftware.jeb.client.ui . Classes of the UI-API allow graphical manipulation of views, fragments, items, etc. (This API is optionally implemented by clients; the desktop client implements it.) You will find a large collection of sample scripts on our public GitHub repository .","title":"Executing Scripts"},{"location":"dev/introducing-jeb-extensions.html#executing-engines-plugins","text":"Engines plugins live within the engines context of the JEB back-end. They may execute code continuously, be event-driven, or even be explicitly called by the user. All third-party plugins must be dropped in your coreplugins/ directory (or any other directory specified in your .PluginsFolder back-end option ). Use the File, Engines, Execute, ... menu command to execute an engines plugin. Note Engines plugins are JEB plugins that implement the IEnginesPlugin interface. The full list of engines plugins loaded within your JEB instance context can be seen by running the File, Engines, Plugins command. You may double-click a plugin to execute it.","title":"Executing Engines Plugins"},{"location":"dev/introducing-jeb-extensions.html#other-plugins","text":"A collection of open-source plugins can be found on our public GitHub repository .","title":"Other Plugins"},{"location":"dev/other-resources.html","text":"Technical drafts for developers: (available on Google Drive) Parser Delegation MVC and Unit Documents Positioning within Units Units Hierarchy Join us on Slack for interactive discussions if you have questions about the API.","title":"Additional Resources"},{"location":"dev/writing-client-scripts.html","text":"JEB clients can execute Python scripts. Scripts should perform relatively small, light-weight actions They are written using the Python 2.7 syntax and features, and are executed by a Jython VM A interactive console is also provided within the UI client (see the Terminal fragment) Features # Scripts can: use the standard JEB API use the Client API package if run within a client that implements the UI-API, use the JEB UI Client API A client script implements the IScript interface. Upon execution, the script run() entry-point method is provided an IClientContext or derived object, such as an IGraphicalClientContext for UI clients, such as the official UI desktop client. A Simple Script # Here is the simplest of all scripts: from com.pnfsoftware.jeb.client.api import IScript class JEBSampleScript ( IScript ): def run ( self , ctx ): print ( 'Hello, JEB version %s ' % ctx . getSoftwareVersion ()) print ( '- Arguments: %s ' % ctx . getArguments ()) print ( '- Base directory: %s ' % ctx . getBaseDirectory ()) Inside the UI client, scripts can be executed via the File, Scripts menu (F2). More scripts # Check out our GitHub repository for many more sample scripts .","title":"Writing Client Scripts"},{"location":"dev/writing-client-scripts.html#features","text":"Scripts can: use the standard JEB API use the Client API package if run within a client that implements the UI-API, use the JEB UI Client API A client script implements the IScript interface. Upon execution, the script run() entry-point method is provided an IClientContext or derived object, such as an IGraphicalClientContext for UI clients, such as the official UI desktop client.","title":"Features"},{"location":"dev/writing-client-scripts.html#a-simple-script","text":"Here is the simplest of all scripts: from com.pnfsoftware.jeb.client.api import IScript class JEBSampleScript ( IScript ): def run ( self , ctx ): print ( 'Hello, JEB version %s ' % ctx . getSoftwareVersion ()) print ( '- Arguments: %s ' % ctx . getArguments ()) print ( '- Base directory: %s ' % ctx . getBaseDirectory ()) Inside the UI client, scripts can be executed via the File, Scripts menu (F2).","title":"A Simple Script"},{"location":"dev/writing-client-scripts.html#more-scripts","text":"Check out our GitHub repository for many more sample scripts .","title":"More scripts"},{"location":"dev/writing-engines-plugins.html","text":"Engines plugins, just like any JEB extension (parser, script, etc.) use the JEB API. They are loaded when JEB starts. Unlike parsers, their role is not to process input data to produce units; they are meant to perform pointed tasks. They react to events issued by units (an IUnit is an IEventSource ). They can also be called on-demand by clients. From a programmer's standpoint, engines plugins extend the IEnginesPlugin (whereas processor plugins extend the IUnitIdentifier interface). Sample Plugins # Sample plugins can be found on our GitHub account. Examples: Andhook : Android Cryptographic Primitives Hooking using the JEB Debuggers API Androsig : Android library code signing and matching ( no longer maintained ) VTPlugin : pulls sample information from VirusTotal information Skeleton Plugin # Full source code: Sample plugin skeleton on GitHub public class SampleEnginesPlugin implements IEnginesPlugin { private static final ILogger logger = GlobalLog . getLogger ( SampleEnginesPlugin . class ); @Override public IPluginInformation getPluginInformation () { return new PluginInformation ( \"Sample Plugin\" , \"A sample JEB plugin\" , \"PNF Software\" , Version . create ( 1 , 0 )); } @Override public List <? extends IOptionDefinition > getExecutionOptionDefinitions () { return null ; } @Override public void execute ( IEnginesContext context ) { execute ( context , null ); } @Override public void execute ( IEnginesContext engctx , Map < String , String > executionOptions ) { logger . info ( \"Executing sample plugin\" ); } @Override public void dispose () { } }","title":"Writing Engines Plugins"},{"location":"dev/writing-engines-plugins.html#sample-plugins","text":"Sample plugins can be found on our GitHub account. Examples: Andhook : Android Cryptographic Primitives Hooking using the JEB Debuggers API Androsig : Android library code signing and matching ( no longer maintained ) VTPlugin : pulls sample information from VirusTotal information","title":"Sample Plugins"},{"location":"dev/writing-engines-plugins.html#skeleton-plugin","text":"Full source code: Sample plugin skeleton on GitHub public class SampleEnginesPlugin implements IEnginesPlugin { private static final ILogger logger = GlobalLog . getLogger ( SampleEnginesPlugin . class ); @Override public IPluginInformation getPluginInformation () { return new PluginInformation ( \"Sample Plugin\" , \"A sample JEB plugin\" , \"PNF Software\" , Version . create ( 1 , 0 )); } @Override public List <? extends IOptionDefinition > getExecutionOptionDefinitions () { return null ; } @Override public void execute ( IEnginesContext context ) { execute ( context , null ); } @Override public void execute ( IEnginesContext engctx , Map < String , String > executionOptions ) { logger . info ( \"Executing sample plugin\" ); } @Override public void dispose () { } }","title":"Skeleton Plugin"},{"location":"dev/writing-front-ends.html","text":"JEB front-end are also referred to as \"JEB clients\" (or \"JEB third-party clients\", to contrast with the \"official UI desktop client\"). JEB back-end API makes writing new clients (aka, front-ends) an easy task. A client can be: An automated client (for testing, for an automation pipeline) A command-line client A graphical front-end (e.g., the official UI desktop client) ... Info Not all JEB licenses allow the creation of third-party clients. Verify this by checking your license information in the About dialog box. It should show any-client . Typically, JEB Pro licenses allow the execution of third-party clients. High-level Instructions # Use the provided source code template (see below) as a base for your client. The basic steps any client should take are the following: Use JebCoreService to retrieve an instance to ICoreContext Create an IEnginesContext Load a project within that context ( IRuntimeProject ) Add artifacts and process them ( ILiveArtifact ) Retrieve the products ( IUnit ) Proceed as usual with the units We recommend developers to read our tutorial series on parser development to get familiar with units Refer to the our simplified architecture diagrams to better visualize how those components are connected to one another. Source Template # Full source code: Command-line client skeleton on GitHub public class AutoClient { static final ILogger logger = GlobalLog . getLogger ( AutoClient . class ); static { GlobalLog . addDestinationStream ( System . out ); } // TODO: customize (should be replaced by the LicenseKey entry in your bin/jeb-client.cfg file) private static final String licenseKey = \"...\" ; // TODO: customize private static final String baseDir = \"...\" ; public static void main ( String [] argv ) throws Exception { if ( argv . length <= 0 ) { return ; } long t0 = System . currentTimeMillis (); String location = argv [ 0 ] ; List < File > files = AutoUtil . retrieveFiles ( location ); test ( files ); logger . info ( \"Done in %ds\" , ( System . currentTimeMillis () - t0 ) / 1000 ); } /** * Initialize a core. Create a context within that core. Then, for each input artifact, a * project is created and the artifact is loaded within that project. */ public static void test ( List < File > files ) throws Exception { // create or retrieve a core context (engines container) ICoreContext core = JebCoreService . getInstance ( licenseKey ); // create an engines context (project container) IFileDatabase projectdb = new JEB2FileDatabase ( baseDir ); IFileStore filestore = new SimpleFSFileStore ( baseDir ); BaseConfiguration cfg = new BaseConfiguration (); // TODO: customize (alternative is to read your configuration from .cfg file) cfg . setProperty ( \".DevPluginClasspath\" , \"...\" ); // TODO: customize cfg . setProperty ( \".DevPluginClassnames\" , \"...\" ); IConfiguration config = new CommonsConfigurationWrapper ( cfg ); IDataProvider dataProvider = new DataProvider ( null , projectdb , filestore , null , null , config ); IEnginesContext engctx = core . createEnginesContext ( dataProvider , null ); int i = 0 ; for ( File file : files ) { i ++ ; logger . info ( \"Testing file %d/%d : %s ...\" , i , files . size (), file . getName ()); // create or load a project (artifact container) IRuntimeProject prj = engctx . loadProject ( \"ProjectTest\" + i ); // process the artifact, get units ILiveArtifact art = prj . processArtifact ( new Artifact ( file . getName (), new FileInput ( file ))); // proceed with the units List < IUnit > units = art . getUnits (); // TODO: CUSTOMIZE -- this is the important part // Basic tests go here // example: for ( IUnit unit : units ) { logger . info ( \"Unit: %s\" , unit ); //if(unit instanceof Xyz) { // ... //} } engctx . unloadProject ( prj . getKey ()); } // close the engines JebCoreService . getInstance (). closeEnginesContext ( engctx ); } }","title":"Writing Front-Ends"},{"location":"dev/writing-front-ends.html#high-level-instructions","text":"Use the provided source code template (see below) as a base for your client. The basic steps any client should take are the following: Use JebCoreService to retrieve an instance to ICoreContext Create an IEnginesContext Load a project within that context ( IRuntimeProject ) Add artifacts and process them ( ILiveArtifact ) Retrieve the products ( IUnit ) Proceed as usual with the units We recommend developers to read our tutorial series on parser development to get familiar with units Refer to the our simplified architecture diagrams to better visualize how those components are connected to one another.","title":"High-level Instructions"},{"location":"dev/writing-front-ends.html#source-template","text":"Full source code: Command-line client skeleton on GitHub public class AutoClient { static final ILogger logger = GlobalLog . getLogger ( AutoClient . class ); static { GlobalLog . addDestinationStream ( System . out ); } // TODO: customize (should be replaced by the LicenseKey entry in your bin/jeb-client.cfg file) private static final String licenseKey = \"...\" ; // TODO: customize private static final String baseDir = \"...\" ; public static void main ( String [] argv ) throws Exception { if ( argv . length <= 0 ) { return ; } long t0 = System . currentTimeMillis (); String location = argv [ 0 ] ; List < File > files = AutoUtil . retrieveFiles ( location ); test ( files ); logger . info ( \"Done in %ds\" , ( System . currentTimeMillis () - t0 ) / 1000 ); } /** * Initialize a core. Create a context within that core. Then, for each input artifact, a * project is created and the artifact is loaded within that project. */ public static void test ( List < File > files ) throws Exception { // create or retrieve a core context (engines container) ICoreContext core = JebCoreService . getInstance ( licenseKey ); // create an engines context (project container) IFileDatabase projectdb = new JEB2FileDatabase ( baseDir ); IFileStore filestore = new SimpleFSFileStore ( baseDir ); BaseConfiguration cfg = new BaseConfiguration (); // TODO: customize (alternative is to read your configuration from .cfg file) cfg . setProperty ( \".DevPluginClasspath\" , \"...\" ); // TODO: customize cfg . setProperty ( \".DevPluginClassnames\" , \"...\" ); IConfiguration config = new CommonsConfigurationWrapper ( cfg ); IDataProvider dataProvider = new DataProvider ( null , projectdb , filestore , null , null , config ); IEnginesContext engctx = core . createEnginesContext ( dataProvider , null ); int i = 0 ; for ( File file : files ) { i ++ ; logger . info ( \"Testing file %d/%d : %s ...\" , i , files . size (), file . getName ()); // create or load a project (artifact container) IRuntimeProject prj = engctx . loadProject ( \"ProjectTest\" + i ); // process the artifact, get units ILiveArtifact art = prj . processArtifact ( new Artifact ( file . getName (), new FileInput ( file ))); // proceed with the units List < IUnit > units = art . getUnits (); // TODO: CUSTOMIZE -- this is the important part // Basic tests go here // example: for ( IUnit unit : units ) { logger . info ( \"Unit: %s\" , unit ); //if(unit instanceof Xyz) { // ... //} } engctx . unloadProject ( prj . getKey ()); } // close the engines JebCoreService . getInstance (). closeEnginesContext ( engctx ); } }","title":"Source Template"}]}